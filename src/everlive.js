(function () { if (typeof module === "object") { var everliveModule = module; } if (typeof define !== "undefined" && define.amd) { define(function() { return Everlive; }); } (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],3:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],4:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":5}],5:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],6:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],7:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":6,"_process":5,"inherits":3}],8:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":9}],9:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":10,"./lib/stringify":11}],10:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],11:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],12:[function(require,module,exports){

/**
 * Module dependencies.
 */

var ops = require('./ops');
var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = filter;
exports.ops = ops;

/**
 * Filters an `obj` by the given `query` for subdocuments.
 *
 * @return {Object|Boolean} false if no match, or matched subdocs
 * @api public
 */

function filter(obj, query){
  obj = obj || {};
  var ret = {};

  for (var key in query) {
    if (!query.hasOwnProperty(key)) continue;

    // search value
    var val = query[key];

    // split the key into prefix and suffix
    var keys = key.split('.');
    var target = obj;
    var prefix, search;
    var matches = [];

    walk_keys:
    for (var i = 0; i < keys.length; i++) {
      target = target[keys[i]];

      switch (type(target)) {
        case 'array':
          // if it's an array subdocument search we stop here
          prefix = keys.slice(0, i + 1).join('.');
          search = keys.slice(i + 1).join('.');

          debug('searching array "%s"', prefix);

          // we special case operators that don't walk the array
          if (val.$size && !search.length) {
            return compare(val, target);
          }

          // walk subdocs
          var subset = ret[prefix] || target;

          for (var ii = 0; ii < subset.length; ii++) {
            if (search.length) {
              var q = {};
              q[search] = val;
              if ('object' == type(subset[ii])) {
                debug('attempting subdoc search with query %j', q);
                if (filter(subset[ii], q)) {
                  // we ignore the ret value of filter
                  if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                    matches.push(subset[ii]);
                  }
                }
              }
            } else {
              debug('performing simple array item search');
              if (compare(val, subset[ii])) {
                if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                  matches.push(subset[ii]);
                }
              }
            }
          }

          if (matches.length) {
            ret[prefix] = ret[prefix] || [];
            ret[prefix].push.apply(ret[prefix], matches);
          }

          // we don't continue the key search
          break walk_keys;

        case 'undefined':
          // if we can't find the key
          return false;

        case 'object':
          if (null != keys[i + 1]) {
            continue;
          } else if (!compare(val, target)) {
            return false;
          }
          break;

        default:
          if (!compare(val, target)) return false;
      }
    }
  }

  return ret;
}

/**
 * Compares the given matcher with the document value.
 *
 * @param {Mixed} matcher
 * @param {Mixed} value
 * @api private
 */

function compare(matcher, val){
  if ('object' != type(matcher)) {
    return eql(matcher, val);
  }

  var keys = object.keys(matcher);
  if ('$' == keys[0][0]) {
    for (var i = 0; i < keys.length; i++) {
      // special case for sub-object matching
      if ('$elemMatch' == keys[i]) {
        return false !== filter(val, matcher.$elemMatch);
      } else {
        if (!ops[keys[i]](matcher[keys[i]], val)) return false;
      }
    }
    return true;
  } else {
    return eql(matcher, val);
  }
}

},{"./ops":23,"component-type":15,"debug":16,"dot-component":19,"mongo-eql":21,"object-component":22}],13:[function(require,module,exports){

/**
 * Module dependencies.
 */

var mods = require('./mods');
var filter = require('./filter');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = query;

/**
 * Export filter helper.
 */

exports.filter = filter;

/**
 * Export modifiers.
 */

exports.mods = mods;

/**
 * Execute a query.
 *
 * Options:
 *  - `strict` only modify if query matches
 *
 * @param {Object} object to alter
 * @param {Object} query to filter modifications by
 * @param {Object} update object
 * @param {Object} options
 */

function query(obj, query, update, opts){
  obj = obj || {};
  opts = opts || {};
  query = query || {};
  update = update || {};

  // strict mode
  var strict = !!opts.strict;

  var match;
  var log = [];

  if (object.length(query)) {
    match = filter(obj, query);
  }

  if (!strict || false !== match) {
    var keys = object.keys(update);
    var transactions = [];

    for (var i = 0, l = keys.length; i < l; i++) {
      if (mods[keys[i]]) {
        debug('found modifier "%s"', keys[i]);
        for (var key in update[keys[i]]) {
          var pos = key.indexOf('.$.');

          if (~pos) {
            var prefix = key.substr(0, pos);
            var suffix = key.substr(pos + 3);

            if (match[prefix]) {
              debug('executing "%s" %s on first match within "%s"', key, keys[i], prefix);
              var fn = mods[keys[i]](match[prefix][0], suffix, update[keys[i]][key]);
              if (fn) {
                // produce a key name replacing $ with the actual index
                // TODO: this is unnecessarily expensive
                var index = dot.get(obj, prefix).indexOf(match[prefix][0]);
                fn.key = prefix + '.' + index + '.' + suffix;
                fn.op = keys[i];
                transactions.push(fn);
              }
            } else {
              debug('ignoring "%s" %s - no matches within "%s"', key, keys[i], prefix);
            }
          } else {
            var fn = mods[keys[i]](obj, key, update[keys[i]][key]);
            if (fn) {
              fn.key = key;
              fn.op = keys[i];
              transactions.push(fn);
            }
          }
        }
      } else {
        debug('skipping unknown modifier "%s"', keys[i]);
      }
    }

    if (transactions.length) {
      // if we got here error free we process all transactions
      for (var i = 0; i < transactions.length; i++) {
        var fn = transactions[i];
        var val = fn();
        log.push({ op: fn.op, key: fn.key, value: val });
      }
    }
  } else {
    debug('no matches for query %j', query);
  }

  return log;
}

},{"./filter":12,"./mods":14,"component-type":15,"debug":16,"dot-component":19,"object-component":22}],14:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var keys = require('object-component').keys;
var debug = require('debug')('mongo-query');

/**
 * Performs a `$set`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$set = function $set(obj, path, val){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path, true);

  switch (type(obj)) {
    case 'object':
      if (!eql(obj[key], val)) {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (numeric(key)) {
        if (!eql(obj[key], val)) {
          return function(){
            obj[key] = val;
            return val;
          };
        }
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('$set only supports object not ' + type(obj));
  }
};

/**
 * Performs an `$unset`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$unset = function $unset(obj, path){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path);

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        return function(){
          // reminder: `delete arr[1]` === `delete arr['1']` [!]
          delete obj[key];
        };
      } else {
        // we fail silently
        debug('ignoring unset of inexisting key');
      }
  }
};

/**
 * Performs a `$rename`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$rename = function $rename(obj, path, newKey){
  // target = source
  if (path == newKey) {
    throw new Error('$rename source must differ from target');
  }

  // target is parent of source
  if (0 === path.indexOf(newKey + '.')) {
    throw new Error('$rename target may not be a parent of source');
  }

  var p = dot.parent(obj, path);
  var t = type(p);

  if ('object' == t) {
    var key = path.split('.').pop();

    if (p.hasOwnProperty(key)) {
      return function(){
        var val = p[key];
        delete p[key];

        // target does initialize the path
        var newp = dot.parent(obj, newKey, true);

        // and also fails silently upon type mismatch
        if ('object' == type(newp)) {
          newp[newKey.split('.').pop()] = val;
        } else {
          debug('invalid $rename target path type');
        }

        // returns the name of the new key
        return newKey;
      };
    } else {
      debug('ignoring rename from inexisting source');
    }
  } else if ('undefined' != t) {
    throw new Error('$rename source field invalid');
  }
};

/**
 * Performs an `$inc`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$inc = function $inc(obj, path, inc){
  if ('number' != type(inc)) {
    throw new Error('Modifier $inc allowed for numbers only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('number' != type(obj[key])) {
          throw new Error('Cannot apply $inc modifier to non-number');
        }

        return function(){
          obj[key] += inc;
          return inc;
        };
      } else if('object' == type(obj) || numeric(key)){
        return function(){
          obj[key] = inc;
          return inc;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('Cannot apply $inc modifier to non-number');
  }
};

/**
 * Performs an `$pop`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$pop = function $pop(obj, path, val){
  obj = dot.parent(obj, path);
  var key = path.split('.').pop();

  // we make sure the array is not just the parent of the main key
  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        switch (type(obj[key])) {
          case 'array':
            if (obj[key].length) {
              return function(){
                if (-1 == val) {
                  return obj[key].shift();
                } else {
                  // mongodb allows any value to pop
                  return obj[key].pop();
                }
              };
            }
            break;

          case 'undefined':
            debug('ignoring pop to inexisting key');
            break;

          default:
            throw new Error('Cannot apply $pop modifier to non-array');
        }
      } else {
        debug('ignoring pop to inexisting key');
      }
      break;

    case 'undefined':
      debug('ignoring pop to inexisting key');
      break;
  }
};

/**
 * Performs a `$push`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @return {Function} transaction (unless noop)
 */

exports.$push = function $push(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pushAll`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Array} values to push
 * @return {Function} transaction (unless noop)
 */

exports.$pushAll = function $pushAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = val;
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pull`.
 */

exports.$pull = function $pull(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$pullAll`.
 */

exports.$pullAll = function $pullAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$addToSet`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @param {Boolean} internal, true if recursing
 * @return {Function} transaction (unless noop)
 */

exports.$addToSet = function $addToSet(obj, path, val, recursing){
  if (!recursing && 'array' == type(val.$each)) {
    var fns = [];
    for (var i = 0, l = val.$each.length; i < l; i++) {
      var fn = $addToSet(obj, path, val.$each[i], true);
      if (fn) fns.push(fn);
    }
    if (fns.length) {
      return function(){
        var values = [];
        for (var i = 0; i < fns.length; i++) values.push(fns[i]());
        return values;
      };
    } else {
      return;
    }
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Helper for determining if an array has the given value.
 *
 * @param {Array} array
 * @param {Object} value to check
 * @return {Boolean}
 */

function has(array, val){
  for (var i = 0, l = array.length; i < l; i++) {
    if (eql(val, array[i])) return true;
  }
  return false;
}

/**
 * Array#filter function generator for `$pull`/`$pullAll` operations.
 *
 * @param {Array} array of values to match
 * @param {Array} array to populate with results
 * @return {Function} that splices the array
 */

function pull(arr, vals, pulled){
  var indexes = [];

  for (var a = 0; a < arr.length; a++) {
    var val = arr[a];

    for (var i = 0; i < vals.length; i++) {
      var matcher = vals[i];
      if ('object' == type(matcher)) {
        // we only are only interested in obj <-> obj comparisons
        if ('object' == type(val)) {
          var match = false;

          if (keys(matcher).length) {
            for (var i in matcher) {
              if (matcher.hasOwnProperty(i)) {
                // we need at least one matching key to pull
                if (eql(matcher[i], val[i])) {
                  match = true;
                } else {
                  // if a single key doesn't match we move on
                  match = false;
                  break;
                }
              }
            }
          } else if (!keys(val).length) {
            // pull `{}` matches [{}]
            match = true;
          }

          if (match) {
            indexes.push(a);
            pulled.push(val);
            continue;
          }
        } else {
          debug('ignoring pull match against object');
        }
      } else {
        if (eql(matcher, val)) {
          indexes.push(a);
          pulled.push(val);
          continue;
        }
      }
    }
  }

  return function(){
    for (var i = 0; i < indexes.length; i++) {
      var index = indexes[i];
      arr.splice(index - i, 1);
    }
  };
}

/**
 * Helper to determine if a value is numeric.
 *
 * @param {String|Number} value
 * @return {Boolean} true if numeric
 * @api private
 */

function numeric(val){
  return 'number' == type(val) || Number(val) == val;
}

},{"component-type":15,"debug":16,"dot-component":19,"mongo-eql":21,"object-component":22}],15:[function(require,module,exports){
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  val = val.valueOf
    ? val.valueOf()
    : Object.prototype.valueOf.apply(val)

  return typeof val;
};

},{}],16:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":17}],17:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":18}],18:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],19:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('type-component');

/**
 * Gets a certain `path` from the `obj`.
 *
 * @param {Object} target
 * @param {String} key
 * @return {Object} found object, or `undefined
 * @api public
 */

exports.get = function(obj, path){
  if (~path.indexOf('.')) {
    var par = parent(obj, path);
    var mainKey = path.split('.').pop();
    var t = type(par);
    if ('object' == t || 'array' == t) return par[mainKey];
  } else {
    return obj[path];
  }
};

/**
 * Sets the given `path` to `val` in `obj`.
 *
 * @param {Object} target
 * @Param {String} key
 * @param {Object} value
 * @api public
 */

exports.set = function(obj, path, val){
  if (~path.indexOf('.')) {
    var par = parent(obj, path, true);
    var mainKey = path.split('.').pop();
    if (par && 'object' == type(par)) par[mainKey] = val;
  } else {
    obj[path] = val;
  }
};

/**
 * Gets the parent object for a given key (dot notation aware).
 *
 * - If a parent object doesn't exist, it's initialized.
 * - Array index lookup is supported
 *
 * @param {Object} target object
 * @param {String} key
 * @param {Boolean} true if it should initialize the path
 * @api public
 */

exports.parent = parent;

function parent(obj, key, init){
  if (~key.indexOf('.')) {
    var pieces = key.split('.');
    var ret = obj;

    for (var i = 0; i < pieces.length - 1; i++) {
      // if the key is a number string and parent is an array
      if (Number(pieces[i]) == pieces[i] && 'array' == type(ret)) {
        ret = ret[pieces[i]];
      } else if ('object' == type(ret)) {
        if (init && !ret.hasOwnProperty(pieces[i])) {
          ret[pieces[i]] = {};
        }
        if (ret) ret = ret[pieces[i]];
      }
    }

    return ret;
  } else {
    return obj;
  }
}

},{"type-component":20}],20:[function(require,module,exports){

/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function';
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val === Object(val)) return 'object';

  return typeof val;
};

},{}],21:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('component-type');

/**
 * Module exports.
 */

module.exports = eql;

/**
 * MongoDB style value comparisons.
 *
 * @param {Object} matcher
 * @param {Object} value
 * @return {Boolean} true if they match
 */

function eql(matcher, val){
  switch (type(matcher)) {
    case 'null':
    case 'undefined':
      // we treat null as undefined
      return null == val;

    case 'regexp':
      return matcher.test(val);

    case 'array':
      if ('array' == type(val) && matcher.length == val.length) {
        for (var i = 0; i < matcher.length; i++) {
          if (!eql(val[i], matcher[i])) return false;
        }
        return true;
      } else {
        return false;
      }
      break;

    case 'object':
      // object can match keys in any order
      var keys = {};

      // we match all values of `matcher` in `val`
      for (var i in matcher) {
        if (matcher.hasOwnProperty(i)) {
          if (!val.hasOwnProperty(i) || !eql(matcher[i], val[i])) {
            return false;
          }
        }
        keys[i] = true;
      }

      // we make sure `val` doesn't have extra keys
      for (var i in val) {
        if (val.hasOwnProperty(i) && !keys.hasOwnProperty(i)) {
          return false;
        }
      }

      return true;

    default:
      return matcher === val;
  }
}

},{"component-type":15}],22:[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],23:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var type = require('component-type');

/**
 * $ne: not equal.
 */

exports.$ne = function $ne(matcher, val){
  return !eql(matcher, val);
};

/**
 * $gt: greater than.
 */

exports.$gt = function $gt(matcher, val){
  return type(matcher) === 'number' && val > matcher;
};

/**
 * $gte: greater than equal.
 */

exports.$gte = function $gte(matcher, val){
  return type(matcher) === 'number' && val >= matcher;
};

/**
 * $lt: less than.
 */

exports.$lt = function $lt(matcher, val){
  return type(matcher) === 'number' && val < matcher;
};

/**
 * $lte: less than equal.
 */

exports.$lte = function $lte(matcher, val){
  return type(matcher) === 'number' && val <= matcher;
};

/**
 * $regex: supply a regular expression as a string.
 */

exports.$regex = function $regex(matcher, val){
  // TODO: add $options support
  if ('regexp' != type('matcher')) matcher = new RegExp(matcher);
  return matcher.test(val);
};

/**
 * $exists: key exists.
 */

exports.$exists = function $exists(matcher, val){
  if (matcher) {
    return undefined !== val;
  } else {
    return undefined === val;
  }
};

/**
 * $in: value in array.
 */

exports.$in = function $in(matcher, val){
  if ('array' != type(matcher)) return false;
  for (var i = 0; i < matcher.length; i++) {
    if (eql(matcher[i], val)) return true;
  }
  return false;
};

/**
 * $nin: value not in array.
 */

exports.$nin = function $nin(matcher, val){
  return !exports.$in(matcher, val);
};

/**
 * @size: array length
 */

exports.$size = function(matcher, val){
  return Array.isArray(val) && matcher == val.length;
};

},{"component-type":15,"mongo-eql":21}],24:[function(require,module,exports){
var CryptoJS = require('./lib/core').CryptoJS;
require('./lib/enc-base64');
require('./lib/md5');
require('./lib/evpkdf');
require('./lib/cipher-core');
require('./lib/aes');
var JsonFormatter = require('./lib/jsonformatter').JsonFormatter;

exports.CryptoJS = CryptoJS;
exports.JsonFormatter = JsonFormatter;
},{"./lib/aes":25,"./lib/cipher-core":26,"./lib/core":27,"./lib/enc-base64":28,"./lib/evpkdf":29,"./lib/jsonformatter":30,"./lib/md5":31}],25:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Lookup tables
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX_0 = [];
    var SUB_MIX_1 = [];
    var SUB_MIX_2 = [];
    var SUB_MIX_3 = [];
    var INV_SUB_MIX_0 = [];
    var INV_SUB_MIX_1 = [];
    var INV_SUB_MIX_2 = [];
    var INV_SUB_MIX_3 = [];

    // Compute lookup tables
    (function () {
        // Compute double table
        var d = [];
        for (var i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1;
            } else {
                d[i] = (i << 1) ^ 0x11b;
            }
        }

        // Walk GF(2^8)
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; i++) {
            // Compute sbox
            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;

            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];

            // Compute sub bytes, mix columns tables
            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
            SUB_MIX_3[x] = t;

            // Compute inv sub bytes, inv mix columns tables
            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
            INV_SUB_MIX_3[sx] = t;

            // Compute next counter
            if (!x) {
                x = xi = 1;
            } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
    }());

    // Precomputed Rcon lookup
    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    /**
     * AES block cipher algorithm.
     */
    var AES = C_algo.AES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;

            // Compute number of rounds
            var nRounds = this._nRounds = keySize + 6

            // Compute number of key schedule rows
            var ksRows = (nRounds + 1) * 4;

            // Compute key schedule
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                } else {
                    var t = keySchedule[ksRow - 1];

                    if (!(ksRow % keySize)) {
                        // Rot word
                        t = (t << 8) | (t >>> 24);

                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

                        // Mix Rcon
                        t ^= RCON[(ksRow / keySize) | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                    }

                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                }
            }

            // Compute inv key schedule
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;

                if (invKsRow % 4) {
                    var t = keySchedule[ksRow];
                } else {
                    var t = keySchedule[ksRow - 4];
                }

                if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t;
                } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                }
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
        },

        decryptBlock: function (M, offset) {
            // Swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;

            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

            // Inv swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
        },

        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            // Shortcut
            var nRounds = this._nRounds;

            // Get input, add round key
            var s0 = M[offset]     ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];

            // Key schedule row counter
            var ksRow = 4;

            // Rounds
            for (var round = 1; round < nRounds; round++) {
                // Shift rows, sub bytes, mix columns, add round key
                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

                // Update state
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
            }

            // Shift rows, sub bytes, add round key
            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

            // Set output
            M[offset]     = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
        },

        keySize: 256/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
     */
    C.AES = BlockCipher._createHelper(AES);
}());

},{"./core":27}],26:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Cipher core components.
 */
CryptoJS.lib.Cipher || (function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var Base64 = C_enc.Base64;
    var C_algo = C.algo;
    var EvpKDF = C_algo.EvpKDF;

    /**
     * Abstract base cipher template.
     *
     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
     */
    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         *
         * @property {WordArray} iv The IV to use for this operation.
         */
        cfg: Base.extend(),

        /**
         * Creates this cipher in encryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
         */
        createEncryptor: function (key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
        },

        /**
         * Creates this cipher in decryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
         */
        createDecryptor: function (key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
        },

        /**
         * Initializes a newly created cipher.
         *
         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
         */
        init: function (xformMode, key, cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Store transform mode and key
            this._xformMode = xformMode;
            this._key = key;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this cipher to its initial state.
         *
         * @example
         *
         *     cipher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-cipher logic
            this._doReset();
        },

        /**
         * Adds data to be encrypted or decrypted.
         *
         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
         *
         * @return {WordArray} The data after processing.
         *
         * @example
         *
         *     var encrypted = cipher.process('data');
         *     var encrypted = cipher.process(wordArray);
         */
        process: function (dataUpdate) {
            // Append
            this._append(dataUpdate);

            // Process available blocks
            return this._process();
        },

        /**
         * Finalizes the encryption or decryption process.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
         *
         * @return {WordArray} The data after final processing.
         *
         * @example
         *
         *     var encrypted = cipher.finalize();
         *     var encrypted = cipher.finalize('data');
         *     var encrypted = cipher.finalize(wordArray);
         */
        finalize: function (dataUpdate) {
            // Final data update
            if (dataUpdate) {
                this._append(dataUpdate);
            }

            // Perform concrete-cipher logic
            var finalProcessedData = this._doFinalize();

            return finalProcessedData;
        },

        keySize: 128/32,

        ivSize: 128/32,

        _ENC_XFORM_MODE: 1,

        _DEC_XFORM_MODE: 2,

        /**
         * Creates shortcut functions to a cipher's object interface.
         *
         * @param {Cipher} cipher The cipher to create a helper for.
         *
         * @return {Object} An object with encrypt and decrypt shortcut functions.
         *
         * @static
         *
         * @example
         *
         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
         */
        _createHelper: (function () {
            function selectCipherStrategy(key) {
                if (typeof key == 'string') {
                    return PasswordBasedCipher;
                } else {
                    return SerializableCipher;
                }
            }

            return function (cipher) {
                return {
                    encrypt: function (message, key, cfg) {
                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                    },

                    decrypt: function (ciphertext, key, cfg) {
                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                    }
                };
            };
        }())
    });

    /**
     * Abstract base stream cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
     */
    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
        _doFinalize: function () {
            // Process partial blocks
            var finalProcessedBlocks = this._process(!!'flush');

            return finalProcessedBlocks;
        },

        blockSize: 1
    });

    /**
     * Mode namespace.
     */
    var C_mode = C.mode = {};

    /**
     * Abstract base block cipher mode template.
     */
    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
        /**
         * Creates this mode for encryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
         */
        createEncryptor: function (cipher, iv) {
            return this.Encryptor.create(cipher, iv);
        },

        /**
         * Creates this mode for decryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
         */
        createDecryptor: function (cipher, iv) {
            return this.Decryptor.create(cipher, iv);
        },

        /**
         * Initializes a newly created mode.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
         */
        init: function (cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
        }
    });

    /**
     * Cipher Block Chaining mode.
     */
    var CBC = C_mode.CBC = (function () {
        /**
         * Abstract base CBC mode.
         */
        var CBC = BlockCipherMode.extend();

        /**
         * CBC encryptor.
         */
        CBC.Encryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // XOR and encrypt
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);

                // Remember this block to use with next block
                this._prevBlock = words.slice(offset, offset + blockSize);
            }
        });

        /**
         * CBC decryptor.
         */
        CBC.Decryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // Remember this block to use with next block
                var thisBlock = words.slice(offset, offset + blockSize);

                // Decrypt and XOR
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);

                // This block becomes the previous block
                this._prevBlock = thisBlock;
            }
        });

        function xorBlock(words, offset, blockSize) {
            // Shortcut
            var iv = this._iv;

            // Choose mixing block
            if (iv) {
                var block = iv;

                // Remove IV for subsequent blocks
                this._iv = undefined;
            } else {
                var block = this._prevBlock;
            }

            // XOR blocks
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= block[i];
            }
        }

        return CBC;
    }());

    /**
     * Padding namespace.
     */
    var C_pad = C.pad = {};

    /**
     * PKCS #5/7 padding strategy.
     */
    var Pkcs7 = C_pad.Pkcs7 = {
        /**
         * Pads data using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to pad.
         * @param {number} blockSize The multiple that the data should be padded to.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
         */
        pad: function (data, blockSize) {
            // Shortcut
            var blockSizeBytes = blockSize * 4;

            // Count padding bytes
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

            // Create padding word
            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

            // Create padding
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
                paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);

            // Add padding
            data.concat(padding);
        },

        /**
         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to unpad.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
         */
        unpad: function (data) {
            // Get number of padding bytes from last byte
            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

            // Remove padding
            data.sigBytes -= nPaddingBytes;
        }
    };

    /**
     * Abstract base block cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
     */
    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
        /**
         * Configuration options.
         *
         * @property {Mode} mode The block mode to use. Default: CBC
         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
         */
        cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
        }),

        reset: function () {
            // Reset cipher
            Cipher.reset.call(this);

            // Shortcuts
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;

            // Reset block mode
            if (this._xformMode == this._ENC_XFORM_MODE) {
                var modeCreator = mode.createEncryptor;
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                var modeCreator = mode.createDecryptor;

                // Keep at least one block in the buffer for unpadding
                this._minBufferSize = 1;
            }
            this._mode = modeCreator.call(mode, this, iv && iv.words);
        },

        _doProcessBlock: function (words, offset) {
            this._mode.processBlock(words, offset);
        },

        _doFinalize: function () {
            // Shortcut
            var padding = this.cfg.padding;

            // Finalize
            if (this._xformMode == this._ENC_XFORM_MODE) {
                // Pad data
                padding.pad(this._data, this.blockSize);

                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');

                // Unpad data
                padding.unpad(finalProcessedBlocks);
            }

            return finalProcessedBlocks;
        },

        blockSize: 128/32
    });

    /**
     * A collection of cipher parameters.
     *
     * @property {WordArray} ciphertext The raw ciphertext.
     * @property {WordArray} key The key to this ciphertext.
     * @property {WordArray} iv The IV used in the ciphering operation.
     * @property {WordArray} salt The salt used with a key derivation function.
     * @property {Cipher} algorithm The cipher algorithm.
     * @property {Mode} mode The block mode used in the ciphering operation.
     * @property {Padding} padding The padding scheme used in the ciphering operation.
     * @property {number} blockSize The block size of the cipher.
     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
     */
    var CipherParams = C_lib.CipherParams = Base.extend({
        /**
         * Initializes a newly created cipher params object.
         *
         * @param {Object} cipherParams An object with any of the possible cipher parameters.
         *
         * @example
         *
         *     var cipherParams = CryptoJS.lib.CipherParams.create({
         *         ciphertext: ciphertextWordArray,
         *         key: keyWordArray,
         *         iv: ivWordArray,
         *         salt: saltWordArray,
         *         algorithm: CryptoJS.algo.AES,
         *         mode: CryptoJS.mode.CBC,
         *         padding: CryptoJS.pad.PKCS7,
         *         blockSize: 4,
         *         formatter: CryptoJS.format.OpenSSL
         *     });
         */
        init: function (cipherParams) {
            this.mixIn(cipherParams);
        },

        /**
         * Converts this cipher params object to a string.
         *
         * @param {Format} formatter (Optional) The formatting strategy to use.
         *
         * @return {string} The stringified cipher params.
         *
         * @throws Error If neither the formatter nor the default formatter is set.
         *
         * @example
         *
         *     var string = cipherParams + '';
         *     var string = cipherParams.toString();
         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
         */
        toString: function (formatter) {
            return (formatter || this.formatter).stringify(this);
        }
    });

    /**
     * Format namespace.
     */
    var C_format = C.format = {};

    /**
     * OpenSSL formatting strategy.
     */
    var OpenSSLFormatter = C_format.OpenSSL = {
        /**
         * Converts a cipher params object to an OpenSSL-compatible string.
         *
         * @param {CipherParams} cipherParams The cipher params object.
         *
         * @return {string} The OpenSSL-compatible string.
         *
         * @static
         *
         * @example
         *
         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
         */
        stringify: function (cipherParams) {
            // Shortcuts
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;

            // Format
            if (salt) {
                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
            } else {
                var wordArray = ciphertext;
            }

            return wordArray.toString(Base64);
        },

        /**
         * Converts an OpenSSL-compatible string to a cipher params object.
         *
         * @param {string} openSSLStr The OpenSSL-compatible string.
         *
         * @return {CipherParams} The cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
         */
        parse: function (openSSLStr) {
            // Parse base64
            var ciphertext = Base64.parse(openSSLStr);

            // Shortcut
            var ciphertextWords = ciphertext.words;

            // Test for salt
            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                // Extract salt
                var salt = WordArray.create(ciphertextWords.slice(2, 4));

                // Remove salt from ciphertext
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
            }

            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
        }
    };

    /**
     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
     */
    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
        /**
         * Configuration options.
         *
         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
         */
        cfg: Base.extend({
            format: OpenSSLFormatter
        }),

        /**
         * Encrypts a message.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Encrypt
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);

            // Shortcut
            var cipherCfg = encryptor.cfg;

            // Create and return serializable cipher params
            return CipherParams.create({
                ciphertext: ciphertext,
                key: key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
            });
        },

        /**
         * Decrypts serialized ciphertext.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Decrypt
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

            return plaintext;
        },

        /**
         * Converts serialized ciphertext to CipherParams,
         * else assumed CipherParams already and returns ciphertext unchanged.
         *
         * @param {CipherParams|string} ciphertext The ciphertext.
         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
         *
         * @return {CipherParams} The unserialized ciphertext.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
         */
        _parse: function (ciphertext, format) {
            if (typeof ciphertext == 'string') {
                return format.parse(ciphertext, this);
            } else {
                return ciphertext;
            }
        }
    });

    /**
     * Key derivation function namespace.
     */
    var C_kdf = C.kdf = {};

    /**
     * OpenSSL key derivation function.
     */
    var OpenSSLKdf = C_kdf.OpenSSL = {
        /**
         * Derives a key and IV from a password.
         *
         * @param {string} password The password to derive from.
         * @param {number} keySize The size in words of the key to generate.
         * @param {number} ivSize The size in words of the IV to generate.
         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
         *
         * @return {CipherParams} A cipher params object with the key, IV, and salt.
         *
         * @static
         *
         * @example
         *
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
         */
        execute: function (password, keySize, ivSize, salt) {
            // Generate random salt
            if (!salt) {
                salt = WordArray.random(64/8);
            }

            // Derive key and IV
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

            // Separate key and IV
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;

            // Return params
            return CipherParams.create({ key: key, iv: iv, salt: salt });
        }
    };

    /**
     * A serializable cipher wrapper that derives the key from a password,
     * and returns ciphertext as a serializable cipher params object.
     */
    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
        /**
         * Configuration options.
         *
         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
         */
        cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
        }),

        /**
         * Encrypts a message using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Encrypt
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

            // Mix in derived params
            ciphertext.mixIn(derivedParams);

            return ciphertext;
        },

        /**
         * Decrypts serialized ciphertext using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Decrypt
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

            return plaintext;
        }
    });
}());

},{"./core":27}],27:[function(require,module,exports){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

exports.CryptoJS = CryptoJS;

},{}],28:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());

},{"./core":27}],29:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var MD5 = C_algo.MD5;

    /**
     * This key derivation function is meant to conform with EVP_BytesToKey.
     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
     */
    var EvpKDF = C_algo.EvpKDF = Base.extend({
        /**
         * Configuration options.
         *
         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
         * @property {number} iterations The number of iterations to perform. Default: 1
         */
        cfg: Base.extend({
            keySize: 128/32,
            hasher: MD5,
            iterations: 1
        }),

        /**
         * Initializes a newly created key derivation function.
         *
         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
         *
         * @example
         *
         *     var kdf = CryptoJS.algo.EvpKDF.create();
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
         */
        init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
        },

        /**
         * Derives a key from a password.
         *
         * @param {WordArray|string} password The password.
         * @param {WordArray|string} salt A salt.
         *
         * @return {WordArray} The derived key.
         *
         * @example
         *
         *     var key = kdf.compute(password, salt);
         */
        compute: function (password, salt) {
            // Shortcut
            var cfg = this.cfg;

            // Init hasher
            var hasher = cfg.hasher.create();

            // Initial values
            var derivedKey = WordArray.create();

            // Shortcuts
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;

            // Generate key
            while (derivedKeyWords.length < keySize) {
                if (block) {
                    hasher.update(block);
                }
                var block = hasher.update(password).finalize(salt);
                hasher.reset();

                // Iterations
                for (var i = 1; i < iterations; i++) {
                    block = hasher.finalize(block);
                    hasher.reset();
                }

                derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;

            return derivedKey;
        }
    });

    /**
     * Derives a key from a password.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.EvpKDF(password, salt);
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
     */
    C.EvpKDF = function (password, salt, cfg) {
        return EvpKDF.create(cfg).compute(password, salt);
    };
}());

},{"./core":27}],30:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

// create custom json serialization format
var JsonFormatter = {
	stringify: function (cipherParams) {
		// create json object with ciphertext
		var jsonObj = {
			ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
		};
		
		// optionally add iv and salt
		if (cipherParams.iv) {
			jsonObj.iv = cipherParams.iv.toString();
		}
		
		if (cipherParams.salt) {
			jsonObj.s = cipherParams.salt.toString();
		}

		// stringify json object
		return JSON.stringify(jsonObj)
	},

	parse: function (jsonStr) {
		// parse json string
		var jsonObj = JSON.parse(jsonStr);
		
		// extract ciphertext from json object, and create cipher params object
		var cipherParams = CryptoJS.lib.CipherParams.create({
			ciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)
		});
		
		// optionally extract iv and salt
		if (jsonObj.iv) {
			cipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv);
		}
            
		if (jsonObj.s) {
			cipherParams.salt = CryptoJS.enc.Hex.parse(jsonObj.s);
		}
		
		return cipherParams;
	}
};

exports.JsonFormatter = JsonFormatter;
},{"./core":27}],31:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Constants table
    var T = [];

    // Compute constants
    (function () {
        for (var i = 0; i < 64; i++) {
            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
        }
    }());

    /**
     * MD5 hash algorithm.
     */
    var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Swap endian
            for (var i = 0; i < 16; i++) {
                // Shortcuts
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }

            // Shortcuts
            var H = this._hash.words;

            var M_offset_0  = M[offset + 0];
            var M_offset_1  = M[offset + 1];
            var M_offset_2  = M[offset + 2];
            var M_offset_3  = M[offset + 3];
            var M_offset_4  = M[offset + 4];
            var M_offset_5  = M[offset + 5];
            var M_offset_6  = M[offset + 6];
            var M_offset_7  = M[offset + 7];
            var M_offset_8  = M[offset + 8];
            var M_offset_9  = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];

            // Working varialbes
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];

            // Computation
            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
            d = II(d, a, b, c, M_offset_7,  10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5,  21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
            d = II(d, a, b, c, M_offset_3,  10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1,  21, T[55]);
            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6,  15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2,  15, T[62]);
            b = II(b, c, d, a, M_offset_9,  21, T[63]);

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
            var nBitsTotalL = nBitsTotal;
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
            );
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
            );

            data.sigBytes = (dataWords.length + 1) * 4;

            // Hash final blocks
            this._process();

            // Shortcuts
            var hash = this._hash;
            var H = hash.words;

            // Swap endian
            for (var i = 0; i < 4; i++) {
                // Shortcut
                var H_i = H[i];

                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    function FF(a, b, c, d, x, s, t) {
        var n = a + ((b & c) | (~b & d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function GG(a, b, c, d, x, s, t) {
        var n = a + ((b & d) | (c & ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function HH(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function II(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.MD5('message');
     *     var hash = CryptoJS.MD5(wordArray);
     */
    C.MD5 = Hasher._createHelper(MD5);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacMD5(message, key);
     */
    C.HmacMD5 = Hasher._createHmacHelper(MD5);
}(Math));

},{"./core":27}],32:[function(require,module,exports){
'use strict';
var Constants = {};
Constants.DefaultTakeItemsCount = 50;
Constants.ExpandExpressionName = 'Expand';
Constants.ReturnAsFieldName = 'ReturnAs';
Constants.FieldsExpressionName = 'Fields';
Constants.SingleFieldExpressionName = 'SingleField';
Constants.SortExpressionName = 'Sort';
Constants.FilterExpressionName = 'Filter';
Constants.SkipExpressionName = 'Skip';
Constants.TakeExpressionName = 'Take';
Constants.ParentRelationFieldName = 'ParentRelationField';
Constants.IdFieldNameClient = 'Id';
Constants.TargetTypeNameFieldName = 'TargetTypeName';

module.exports = Constants;
},{}],33:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');

/**
 * A class that is used to get all required information in order to process a set of relations.
 * @param parent - An ExecutionNode instance used to supply the tree like data structure.
 * @param relationNode - The relation node used to created the ExecutionNode instance (ExecutionNode instance should contain one or many relations
 * if they can be combined for batch execution).
 * @constructor
 */
var ExecutionNode = function (parent, relationNode) {
    var parentPath = '';
    if (parent) {
        parentPath = parent.path;
    }
    this.parent = parentPath;
    this.relations = [relationNode.path];
    this.name = relationNode.path;
    this.targetTypeName = relationNode.targetTypeName;
    this.canAddOtherRelations = !relationNode.filterExpression && !relationNode.sortExpression && !relationNode.take && !relationNode.skip;
    this.children = [];
    var path = '';
    if (parentPath) {
        path += parentPath + '.';
    }
    path += relationNode.targetTypeName;
    this.path = path;
};

/**
 * Inserts a RelationNode to an ExecutionNode.
 * @param relation - A Relation instance.
 */
ExecutionNode.prototype.insertRelationNode = function (relation) {
    this.relations.push(relation.path);
};

/**
 * Inserts a child node (which relations) depends from parent node result.
 * @param child - ExecutionNode instance representing child node.
 */
ExecutionNode.prototype.insertChildrenNode = function (child) {
    this.children.push(child.name);
};

/**
 * Helper method that checks if some relations could be combined (for example have same TargetType).
 * @param relation
 * @returns {boolean}
 */
ExecutionNode.prototype.canCombineWithRelation = function (relation) {
    if (!this.canAddOtherRelations) {
        return false;
    }

    return this.targetTypeName === relation.targetTypeName && !relation.filterExpression && !relation.sortExpression && !relation.take && !relation.skip;
};

/** ExecutionTree
 * Class that allows the creation of an execution tree from a relationTree. Used to process all queries (master and child) in a correct order.
 * @param relationTree - An instance of relation tree.
 * @constructor
 */
var ExecutionTree = function (relationTree) {
    this._relationTree = relationTree;
    this._map = {};
};

/**
 * Adds execution node to the ExecutionTree.
 * @param executionNode
 */
ExecutionTree.prototype.addExecutionNode = function (executionNode) {
    this._map[executionNode.name] = executionNode;
};

/**
 * Finds the ExecutionNode which contains the requested relation.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getExecutionNodeOfRelation = function (relation) {
    for (var execNode in this._map) {
        if (this._map.hasOwnProperty(execNode)) {
            if (this._map[execNode].relations.indexOf(relation) > -1) {
                return this._map[execNode];
            }
        }
    }
    return null;
};

/**
 * Finds a RelationNode within the RelationTree.
 * @param relation - String that represents the relation within the RelationTree (for example: Activities.Likes.Role).
 * @returns {*}
 */
ExecutionTree.prototype.getRelationNode = function (relation) {
    if (relation) {
        return this._relationTree[relation] || null;
    } else {
        return null;
    }
};

ExecutionTree.prototype.getRootRelationNode = function () {
    return this._relationTree[this._relationTree.$root] || null;
};
/**
 * Builds the ExecutionTree from a RelationTree.
 */
ExecutionTree.prototype.build = function () {
    //build beginning from the root
    var relationRoot = this.getRelationNode(this._relationTree.$root);
    //Setup the root of the execution tree.
    var rootExecutionNode = new ExecutionNode(null, relationRoot);//no parent node
    this.addExecutionNode(rootExecutionNode);
    this.buildInternal(relationRoot);
};

/**
 * Traverse the relation tree and build the execution tree.
 * @param relationRoot - The root node of the RelationTree.
 */
ExecutionTree.prototype.buildInternal = function (relationRoot) {
    relationRoot.children.forEach(function (child) {
        var childRelationNode = this.getRelationNode(child);
        this.insertRelationNodeInExecutionTree(childRelationNode);
        this.buildInternal(childRelationNode);
    }, this);
};

/**
 * Inserts a relation node within the execution tree (based on its dependencies).
 * @param relation - The relation that will be inserted.
 */
ExecutionTree.prototype.insertRelationNodeInExecutionTree = function (relation) {
    var rootExecutionNode = this.getExecutionNodeOfRelation(relation.parent);
    var childToCombine = this.tryGetChildNodeToCombine(rootExecutionNode, relation);
    if (childToCombine) {//if there is a child that we combine the relation
        childToCombine.insertRelationNode(relation);
    } else {
        var newExecutionNode = new ExecutionNode(rootExecutionNode, relation);//create a separate execution node that will host the relation
        rootExecutionNode.insertChildrenNode(newExecutionNode);
        this.addExecutionNode(newExecutionNode);
    }
};

/**
 * Tries to find an ExecutionNode which could be combined with a relation.
 * @param rootExecutionNode - The root node of the ExecutionTree.
 * @param relation - Relation that will be added to the ExecutionTree.
 * @returns {*}
 */
ExecutionTree.prototype.tryGetChildNodeToCombine = function (rootExecutionNode, relation) {
    if (rootExecutionNode.canCombineWithRelation(relation)) {
        return rootExecutionNode;
    }
    var children = rootExecutionNode.children;
    for (var i = 0; i < children.length; i++) {
        var child = this._map[children[i]];
        var childToCombine = this.tryGetChildNodeToCombine(child, relation);
        if (childToCombine) {
            return childToCombine;
        }
    }
    return null;
};

/**
 * Gets the filter expression from all relations inside an ExecutionNode.
 * @param executionNode - The ExecutionNode instance.
 * @returns {{}}
 */
ExecutionTree.prototype.getFilterFromExecutionNode = function (executionNode, includeArrays) {
    var filter = {};
    var subRelationsFilter = [];
    for (var i = 0; i < executionNode.relations.length; i++) {
        var innerFilter = this.getFilterFromSingleRelation(this._relationTree[executionNode.relations[i]], includeArrays);
        if (innerFilter) {
            subRelationsFilter.push(innerFilter);
        }
    }

    if (subRelationsFilter.length > 1) {
        filter.$or = subRelationsFilter;
    } else if (subRelationsFilter.length > 0) {
        filter = subRelationsFilter[0];
    } else {
        filter = null;
    }
    return filter;
};

/**
 * Gets filter expression from a single relation. Traverse the relation tree in order to get the "Id"s from the result of parent relation
 * along with user defined filters.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getFilterFromSingleRelation = function (relation, includeArrays) {
    var userDefinedFilter = relation.filterExpression;
    var parentRelationFilter = {};
    var parentRelationIds = this.getRelationFieldValues(relation, includeArrays);
    var parentRelationFieldName = (relation.isInvertedRelation ? relation.relationField : Constants.IdFieldNameClient);

    if (parentRelationIds.length > 0) {
        parentRelationFilter[parentRelationFieldName] = {'$in': parentRelationIds};
    } else {
        return null;
    }

    if (userDefinedFilter !== undefined) {
        var filters = [];
        filters.push(parentRelationFilter);
        filters.push(userDefinedFilter);
        return {'$and': filters};
    } else {
        return parentRelationFilter;
    }
};

/**
 * Get relation field values of parent relation in order to construct a proper filter (to create a relation).
 * @param relation - A relation instance which will get the filter.
 * @param includeArrays - Whether to include array valus of the parent items when calculating the items that will be expanded on the current level.
 * @returns {Array} - An array of relation field values.
 */
ExecutionTree.prototype.getRelationFieldValues = function (relation, includeArrays) {
    var parentRelationIds = [];
    var parentRelation = this._relationTree[relation.parent];
    // parentRelationResult actually is an Activity or Array of Activities
    var parentRelationResult = Array.isArray(parentRelation.result) ? parentRelation.result : [parentRelation.result];
    if (relation.isInvertedRelation) {
        for (var p = 0; p < parentRelationResult.length; p++) {
            parentRelationIds.push(parentRelationResult[p][relation.parentRelationField]);
        }
    } else {
        // all comments are related to expand of type content type Activities expand: {"Likes": true}
        if (parentRelation && parentRelation.result) {
            relation.parentRelationIds = relation.parentRelationIds || {};
            for (var i = 0; i < parentRelationResult.length; i++) {
                // itemFromParentRelation is single Activity
                var itemFromParentRelation = parentRelationResult[i];

                // parentRelationFieldValue is Activity.Likes
                var parentRelationFieldValue = itemFromParentRelation[relation.relationField];
                if (Array.isArray(parentRelationFieldValue)) {
                    relation.hasArrayValues = true;
                    if (includeArrays) {
                        for (var j = 0; j < parentRelationFieldValue.length; j++) {
                            // itemToExpandId is current value in Activity.Likes array or just a single "Id"
                            var itemToExpandId = parentRelationFieldValue[j];
                            if(itemToExpandId !== undefined && itemToExpandId !== null) {
                                parentRelationIds.push(itemToExpandId);
                                // we set any value just to create a map of Ids
                                relation.parentRelationIds[itemToExpandId] = 1;
                            }
                        }
                    }
                } else {
                    if(parentRelationFieldValue !== undefined && parentRelationFieldValue !== null) {
                        parentRelationIds.push(parentRelationFieldValue);
                        relation.parentRelationIds[parentRelationFieldValue] = 1;
                    }
                }
            }
        }
    }

    return parentRelationIds;
};

module.exports = ExecutionTree;

},{"./Constants":32}],34:[function(require,module,exports){
'use strict';
function ExpandError(message) {
    this.name = 'ExpandError';
    this.message = message;
    this.stack = (new Error()).stack;
}
ExpandError.prototype = new Error;
module.exports = ExpandError;
},{}],35:[function(require,module,exports){
'use strict';
var async = require('async');
var RelationTreeBuilder = require('./RelationTreeBuilder');
var ExecutionTree = require('./ExecutionTree');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

function Processor(options) {
    this._executionNodeFunction = options.executionNodeFunction;
    this._metadataProviderFunction = options.metadataProviderFunction;
}

Processor.prototype._getExecutionTreeRoot = function (executionTree) {
    var executionTreeRoot = null;
    for (var exNode in executionTree) {
        if (executionTree.hasOwnProperty(exNode)) {
            if (executionTree[exNode].parent === '') {
                executionTreeRoot = executionTree[exNode];
                break;
            }
        }
    }
    return executionTreeRoot;
};

Processor.prototype._createExecuteNodeExecutor = function (relationsTree, executionTree, executionNode, expandContext) {
    var self = this;
    var relationsTreeMap = relationsTree.map;
    return function (done) {
        var relationNode = executionTree.getRelationNode(executionNode.relations[0]);//get the relation node for the only relation of the execution node.
        var parentRelationNode = executionTree.getRelationNode(relationNode.parent);
        var includeArrays = !(parentRelationNode.parent && parentRelationNode.hasArrayValues); //only expand array fields if the parent relation is not an array. This means that if we have expanded a Likes (multiple to Users), we won't expand any array relations that are nested in it such as the UserComments (multiple relation to Comments).
        var filter = executionTree.getFilterFromExecutionNode(executionNode, includeArrays);

        var errorMessage = relationsTree.validateSingleRelation(relationNode);
        if (errorMessage) {
            return done(new ExpandError(errorMessage));
        }

        // if we have such options executionNode should have only one relation.
        var node = {};
        node.select = relationNode.fieldsExpression;
        node.sort = relationNode.sortExpression;
        node.skip = relationNode.skip;
        node.take = relationNode.take;
        node.filter = filter;
        node.targetTypeName = relationNode.targetTypeName;

        self._executionNodeFunction.call(null, node, expandContext, function onProcessExecutionNode(err, result) {
            if (err) {
                return done(err);
            }

            for (var i = 0; i < executionNode.relations.length; i++) {
                var childRelation = relationsTreeMap[executionNode.relations[i]];
                childRelation.result = self._extractResultForRelation(relationsTreeMap[executionNode.relations[i]], result);
            }
            executionNode.result = childRelation.result;
            var arr = [];
            for (var j = 0; j < executionNode.children.length; j++) {
                var executionTreeMap = executionTree._map;
                arr.push(self._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionNode.children[j]], expandContext));
            }
            async.parallel(arr, done);
        });
    };
};

Processor.prototype._getSingleResult = function (relationsTree, relation, singleObject) {
    if (!singleObject) {
        return null;
    }

    var childRelation;
    var childItem;

    // if relation has singleFieldName option we just replace the parent id with a single value
    if (relation.singleFieldName) {
        if (relation.children && relation.children.length > 0) {
            childRelation = relationsTree[relation.children[0]];
            childItem = this._getObjectByIdFromArray(childRelation.result, singleObject[relation.singleFieldName]);
            return this._getSingleResult(relationsTree, childRelation, childItem);
        }
        return singleObject[relation.singleFieldName];
    }

    var result = {};
    var passedProperties = {};

    if (relation.children && relation.children.length > 0) {
        for (var j = 0; j < relation.children.length; j++) {
            childRelation = relationsTree[relation.children[j]];
            var childRelationField = childRelation.relationField;
            var userDefinedRelName = childRelation.userDefinedName;
            if (!childRelation.isInvertedRelation) {
                passedProperties[childRelationField] = 1;
            }

            var innerRelationResult = childRelation.result;

            if (childRelation.isInvertedRelation) {
                for (var k = 0; k < innerRelationResult.length; k++) {
                    this._addSingleResultToParentArray(relationsTree, childRelation, innerRelationResult[k], result, userDefinedRelName);
                }
            } else {
                result[userDefinedRelName] = childRelation.isArray() ? [] : null;

                if (singleObject[childRelationField]) {
                    if (Array.isArray(singleObject[childRelationField])) {
                        if (childRelation.sortExpression) {
                            // if there is a sorting we replace items using order of the query result
                            for (var p = 0; p < innerRelationResult.length; p++) {
                                if (singleObject[childRelationField].indexOf(innerRelationResult[p].Id) > -1) {
                                    childItem = innerRelationResult[p];
                                    this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                                }
                            }
                        } else {
                            // we just replace items getting them by id which we have
                            for (var i = 0; i < singleObject[childRelationField].length; i++) {
                                childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField][i]);
                                this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                            }
                        }
                    } else {
                        childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField]);
                        result[userDefinedRelName] = this._getSingleResult(relationsTree, childRelation, childItem);
                    }
                }
            }
        }
    }

    // add all other fields to the result (except the relation fields which we have already replaced).
    for (var prop in singleObject) {
        var propertyShouldBeAddedToResult = singleObject.hasOwnProperty(prop) && !passedProperties[prop] &&
            this._fieldExistInFieldsExpression(prop, relation.originalFieldsExpression);
        if (propertyShouldBeAddedToResult) {
            result[prop] = singleObject[prop];
        }
    }

    return result;
};

Processor.prototype._addSingleResultToParentArray = function (relationsTree, childRelation, childItem, result, userDefinedRelName) {
    var singleResult = this._getSingleResult(relationsTree, childRelation, childItem);
    result[userDefinedRelName] = result[userDefinedRelName] || [];
    if (singleResult) {
        result[userDefinedRelName].push(singleResult);
    }
};

/**
 * Checks if a field will be returned via given fields expression.
 * @param field - The name of the field.
 * @param fieldsExpression - The Fields expression which is checked.
 * @returns {*}
 */
Processor.prototype._fieldExistInFieldsExpression = function (field, fieldsExpression) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return true;
    }

    if (field === Constants.IdFieldNameClient) {
        if (fieldsExpression[field] === undefined) {
            return true;
        }
        return fieldsExpression[field];
    }

    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return true;
    }

    if (isExclusive) {
        return !fieldsExpression.hasOwnProperty(field);
    } else {
        return fieldsExpression.hasOwnProperty(field);
    }
};

/**
 * Extracts the result for a single relation (in cases when ExecutionNode contains more than one relations).
 * @param relation - The relation object.
 * @param queryResult - Result of the combined query.
 * @returns {Array}
 */
Processor.prototype._extractResultForRelation = function (relation, queryResult) {
    var result = [];
    for (var i = 0; i < queryResult.length; i++) {
        if (relation.parentRelationIds) {
            if (relation.parentRelationIds.hasOwnProperty(queryResult[i].Id)) {
                result.push(queryResult[i]);
            }
        }
        if (relation.isInvertedRelation) {
            result.push(queryResult[i]);
        }
    }
    return result;
};

/**
 * Gets an object with a given Id from Array.
 * @param array
 * @param id
 * @returns {*}
 */
Processor.prototype._getObjectByIdFromArray = function (array, id) {
    if (array) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].Id === id) {
                return array[i];
            }
        }
    }
    return null;
};

/**
 * @public
 * @param expandExpression
 * @param mainTypeName
 * @param isArray
 * @param fieldsExpression
 * @param maxTakeValue
 * @param prepareContext
 * @param done
 */
Processor.prototype.prepare = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, prepareContext, done) {
    var rtb = new RelationTreeBuilder(expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, this._metadataProviderFunction, prepareContext);
    rtb.build(function (err, map) {
        var mainQueryFieldsExpression;
        if (map) {
            mainQueryFieldsExpression = map[map.$root].fieldsExpression;
            var prepareResult = {
                relationsTree: rtb,
                mainQueryFieldsExpression: mainQueryFieldsExpression
            }
        }
        done(err, prepareResult);
    });
};

/**
 * @public
 * @param relationsTree
 * @param mainQueryResult
 * @param expandContext
 * @param done
 */
Processor.prototype.expand = function (relationsTree, mainQueryResult, expandContext, done) {
    var relationsTreeMap = relationsTree.map;
    var self = this;
    var executionTree = new ExecutionTree(relationsTreeMap);
    executionTree.build();
    relationsTreeMap[relationsTreeMap.$root].result = mainQueryResult;
    var executionTreeMap = executionTree._map;

    var executionTreeRoot = this._getExecutionTreeRoot(executionTreeMap);

    var maxQueriesCount = 20;
    if (Object.keys(executionTreeMap).length > maxQueriesCount) {
        done(new ExpandError('Expand expression results in more than ' + maxQueriesCount + ' inner queries!'));
    }

    if (executionTreeRoot) {
        var execFuncs = [];
        for (var i = 0; i < executionTreeRoot.children.length; i++) {
            execFuncs.push(this._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionTreeRoot.children[i]], expandContext));
        }
        // execFuncs are functions created for every single execution note
        // we execute them in async, since the result of the parent relation is used to get correct filter.
        async.series(execFuncs, function onProcessExecutionTree(err) {
            if (err) {
                done(err);
            } else {
                var output;
                var rootRelation = relationsTreeMap[relationsTreeMap.$root];
                if (Array.isArray(mainQueryResult)) {
                    output = [];
                    for (var i = 0; i < mainQueryResult.length; i++) {
                        var singleResult = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult[i]);
                        if (singleResult) {
                            output.push(singleResult);
                        }
                    }
                } else {
                    output = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult);
                }
                done(null, output);
            }
        });
    }
};

Processor.Constants = Constants;

module.exports = Processor;

},{"./Constants":32,"./ExecutionTree":33,"./ExpandError":34,"./RelationTreeBuilder":37,"async":38}],36:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');
var _ = require('underscore');
var ExpandError = require('./ExpandError');

function RelationNode(options) {
    this.parent = options.parent;
    this.relationField = options.relationField;
    this.path = options.path || options.parent + '.' + options.relationField;
    this.fieldsExpression = options.fieldsExpression || {};
    this.targetTypeName = options.targetTypeName;
    this.children = [];
    this.isInvertedRelation = options.isInvertedRelation;
    this.isArrayRoot = options.isArrayRoot; //used for validation of cases where various expand features are disabled for a GetAll scenario.
    this.hasArrayValues = false;//set when we have executed the query. Used in validation scenarios where we do not have metadata about whether the relation is an array or not.

    var expandExpression = options.expandExpression || {};

    this.parentRelationField = expandExpression[Constants.ParentRelationFieldName] || Constants.IdFieldNameClient;
    var relationField = this.isInvertedRelation ? this.path : this.relationField; //inverted relations appear with the full path - ContentType.Field - in the result when expanding.
    this.userDefinedName = expandExpression[Constants.ReturnAsFieldName] || relationField;
    _.extend(this.fieldsExpression, expandExpression[Constants.FieldsExpressionName]);
    this.originalFieldsExpression = {};
    _.extend(this.originalFieldsExpression, this.fieldsExpression);
    this.singleFieldName = expandExpression[Constants.SingleFieldExpressionName];
    this.filterExpression = expandExpression[Constants.FilterExpressionName];
    this.sortExpression = expandExpression[Constants.SortExpressionName];
    this.skip = expandExpression[Constants.SkipExpressionName];
    this.take = this._getTakeLimit(expandExpression[Constants.TakeExpressionName], options.maxTakeValue);
}


/**
 * Gets the take limit depending on the application and the take value that the user has provided.
 * @param clientTakeValue
 * @param maxTakeValue
 * @returns {number}
 */
RelationNode.prototype._getTakeLimit = function (clientTakeValue, maxTakeValue) {
    maxTakeValue = maxTakeValue || Constants.DefaultTakeItemsCount;
    if (clientTakeValue) {
        if (clientTakeValue > maxTakeValue) {
            throw new ExpandError('The maximum allowed take value when expanding relations is ' + maxTakeValue + '!');
        }
        return clientTakeValue;
    } else {
        return maxTakeValue;
    }
};

/**
 * Anyone using the bs-expand-processor module can set whether the relation is a multiple relation in the prepare phase.
 * This will allow for certain restrictions to be enforced directly on the prepare phase instead of the execution phase.
 */
RelationNode.prototype.setIsArrayFromMetadata = function () {
    this.isArrayFromMetadata = true;
};

RelationNode.prototype.isArray = function () {
    // We can find out if a relation is an array in the following cases:
    // From metadata in the API Server.
    // All inverted relations are array.
    // Once values have been received we can find out. This is used for scenarios where we do not have metadata about the relation (offline storage in SDK).
    return this.isArrayFromMetadata || this.isInvertedRelation || this.hasArrayValues;
};

module.exports = RelationNode;

},{"./Constants":32,"./ExpandError":34,"underscore":1}],37:[function(require,module,exports){
'use strict';
var RelationNode = require('./RelationNode');
var _ = require('underscore');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

//var relationFieldPropertyName = Constants.RelationExpressionName;

var possibleExpandOptions = [
    Constants.ExpandExpressionName,
    Constants.ReturnAsFieldName,
    Constants.FieldsExpressionName,
    Constants.SingleFieldExpressionName,
    Constants.SortExpressionName,
    Constants.FilterExpressionName,
    Constants.SkipExpressionName,
    Constants.TakeExpressionName,
    Constants.ParentRelationFieldName,
    Constants.TargetTypeNameFieldName
];


/**
 * A class used to parse Expand expression and build a corresponding relation tree.
 * In a process of creating the relation tree are performed several checks in order to force some limitations -
 * 50 items both for master and child queries and entire amount of all queries limited to 20.
 * Checks if the relation field given by the customer is valid (for example: user gives "Like" while the relation field is "Likes").
 * Checks for possible expand options.
 * @constructor
 */
var RelationTreeBuilder = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, metadataProviderFunction, context) {
    this.maxTakeValue = maxTakeValue;
    this._metadataProviderFunction = metadataProviderFunction;
    this.context = context;
    this.expandExpression = this.processExpandExpression(expandExpression);
    // mark the main query in order to avoid some duplication issues.
    this.map = {};
    this.map[mainTypeName] = new RelationNode({
        targetTypeName: mainTypeName,
        isArrayRoot: isArray,
        fieldsExpression: fieldsExpression,
        validated: true,
        path: mainTypeName,
        maxTakeValue: maxTakeValue
    });
    this.map[mainTypeName].originalFieldsExpression = {};
    _.extend(this.map[mainTypeName].originalFieldsExpression, fieldsExpression);
    this.map.$root = mainTypeName;
};

/**
 * Creates fully qualified expand expression from shorthand usages:
 * {"Likes": true} -> {"Likes": {"ReturnAs": "Likes"}}
 * {"Likes": "LikesExpanded"} -> {"Likes": {"ReturnAs": "LikesExpanded"}}
 * @param expandExpression
 * @returns {*}
 */
RelationTreeBuilder.prototype.processExpandExpression = function (expandExpression) {
    for (var property in expandExpression) {
        if (expandExpression.hasOwnProperty(property)) {
            if (typeof expandExpression[property] === 'boolean') {
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = property;
            }
            if (typeof expandExpression[property] === 'string') {
                var relationField = expandExpression[property];
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = relationField;
            }
        }
    }
    return expandExpression;
};

/**
 * Builds the relation tree.
 * @param done
 */
RelationTreeBuilder.prototype.build = function (done) {
    try {
        this.buildMapInternal(this.expandExpression, this.map.$root);
    } catch (e) {
        return done(e);
    }
    var self = this;
    require('async').series([
        this.configureRelationTree.bind(this),
        this.validateRelationTree.bind(this)
    ], function (err) {
        done(err, self.map);
    });
};

/**
 *
 * @param relationName - A path to the external relation collection (Comments.ActivityId)
 * @param expandExpression - The expand expression that contains all information about the relation
 * @param rootName - Name of the parent relation.
 * @returns {RelationNode}
 */
RelationTreeBuilder.prototype.createInvertedRelation = function (relationName, expandExpression, rootName) {
    var options = {};
    var relationNameParts = relationName.split('.');
    options.parent = rootName;
    options.relationField = relationNameParts[1];
    options.isInvertedRelation = true;
    options.targetTypeName = relationNameParts[0];
    options.expandExpression = expandExpression;
    options.path = relationName;
    options.maxTakeValue = this.maxTakeValue;
    options.validated = false;

    return new RelationNode(options);
};

/**
 * An internal method which parses the expand expression and produces a basic relation tree (only names and parent relations).
 * @param expandExpression - The expand expression which will be processed.
 * @param rootName - The name of the root relation (master query) usually the name of the requested content type (Activities).
 */
RelationTreeBuilder.prototype.buildMapInternal = function (expandExpression, rootName) {
    for (var relationName in expandExpression) {
        if (expandExpression.hasOwnProperty(relationName)) {
            var currentExpression = expandExpression[relationName];

            for (var option in currentExpression) {
                if (currentExpression.hasOwnProperty(option) && possibleExpandOptions.indexOf(option) === -1) {
                    throw new ExpandError('\"' + option + '\"' + ' is not a valid option for Expand expression');
                }
            }

            if (relationName.indexOf('.') > -1) {
                var invertedRelation = this.createInvertedRelation(relationName, currentExpression, rootName);
                this.map[invertedRelation.path] = invertedRelation;
                this.map[invertedRelation.parent].children.push(invertedRelation.path);
                // adds a field expression in the original fields expression in order to get the result for that field
                RelationTreeBuilder.addFieldToFieldsExpression(this.map[invertedRelation.parent].originalFieldsExpression, invertedRelation.userDefinedName);

                if (expandExpression[relationName][Constants.ExpandExpressionName]) {
                    var processedExpandExpression = this.processExpandExpression(expandExpression[relationName][Constants.ExpandExpressionName]);
                    this.buildMapInternal(processedExpandExpression, invertedRelation.path);
                }
            } else {
                var options = {};
                options.relationField = relationName;
                options.parent = rootName;
                options.expandExpression = currentExpression;
                options.maxTakeValue = this.maxTakeValue;
                options.targetTypeName = currentExpression[Constants.TargetTypeNameFieldName];
                var relationNode = new RelationNode(options);
                var parentNode = this.map[options.parent];
                parentNode.children.push(relationNode.path);
                this.map[relationNode.path] = relationNode;

                if (currentExpression.hasOwnProperty(Constants.ExpandExpressionName)) {
                    if (typeof(currentExpression[Constants.ExpandExpressionName]) === 'object') {
                        this.buildMapInternal(this.processExpandExpression(currentExpression.Expand), relationNode.path);
                    } else {
                        throw new ExpandError(relationNode.path + '.Expand must be a valid expand expression!');
                    }
                }
            }
        }
    }
};

/**
 * Adds additional metadata which is necessary to execute a query.
 * Name of the content type of the child relation get via relation field.
 * @param done
 */
RelationTreeBuilder.prototype.configureRelationTree = function (done) {
    if (this._metadataProviderFunction) {
        var relationNames = [];
        var self = this;

        for (var rel in this.map) {
            if (this.map.hasOwnProperty(rel)) {
                if (this.map[rel].parent !== null) {
                    relationNames.push(this.map[rel].relationField);
                }
            }
        }

        this._metadataProviderFunction(relationNames, this.map, this.context, function (err, result) {
            done(err);
        });
    } else {
        return done();
    }
};

/**
 * Performs several checks like:
 * Validity of the relation field.
 * To not use filter or sorting expression within a "GetByFilter" scenario.
 * Does not allow to nest (expand multiple relation field) after a multiple relation.
 * Does not allow to use both "Fields" and "SingleField" options.
 * @param done
 * @returns {*}
 */
RelationTreeBuilder.prototype.validateRelationTree = function (done) {
    var errorMessage = '';
    var EOL = '\r\n';
    for (var relationPath in this.map) {
        if (relationPath !== '$root' && this.map.hasOwnProperty(relationPath)) {
            var relation = this.map[relationPath];
            errorMessage += this.validateSingleRelation(relation);
            this.configureFieldsExpressionsForRelation(relation);
        }
    }
    if (errorMessage !== '') {
        var finalErrorMessage = errorMessage.substr(0, errorMessage.lastIndexOf(EOL));
        var error = new ExpandError(finalErrorMessage);
        return done(error);
    } else {
        done();
    }
};

/**
 * Add relation fields to parent relation fields expression if needed (otherwise relation cannot be established).
 * @param relation - A relation which will be configured.
 */
RelationTreeBuilder.prototype.configureFieldsExpressionsForRelation = function (relation) {
    if (relation.parent) {
        var parentRelationFieldsExpression = this.map[relation.parent].fieldsExpression;
        if (relation.isInvertedRelation) {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.parentRelationField);
        } else {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.relationField);
        }
    }
    if (relation.isInvertedRelation) {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, relation.relationField);
    } else {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, Constants.IdFieldNameClient);
    }
    RelationTreeBuilder.adjustParentRelationFieldsExpression(this.map[relation.parent], relation);
};

/**
 * Validates a single relation for all build-in limitations.
 * @param relation - A relation which will be validated.
 * @returns {string} - Returns an error message with all errors or empty string if there is no errors.
 */
RelationTreeBuilder.prototype.validateSingleRelation = function (relation) {
    var errorMessage = '';
    var EOL = '\r\n';
    var isGetByFilterQuery = this.map[this.map.$root].isArrayRoot;

    if (relation.path === relation.parent) {
        errorMessage += relation.path + ' has same parent which will cause an infinite loop.' + EOL;
        return errorMessage;
    }

    if (relation.isArray()) {
        var multipleQueriesCount = this.getParentMultipleRelationsCount(relation);
        if (multipleQueriesCount > 0) {
            errorMessage += 'Expand expression has multiple relation \"' + relation.path + '\" inside a multiple relation.';
            errorMessage += EOL;
        }

        if (this.map[relation.parent] === this.map[this.map.$root] &&
            isGetByFilterQuery &&
            (relation.filterExpression || relation.sortExpression)) {
            errorMessage += 'Filter and Sort expressions are not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }

        if (isGetByFilterQuery && relation.isInvertedRelation) {
            errorMessage += 'Expanding an external content type is not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }
    }
    if (!relation.targetTypeName) {
        errorMessage += 'Expanding relation \"' + relation.relationField + '\" has no target type name specified. You should use \"TargetTypeName\" to specify it.';
        errorMessage += EOL;
    }
    if (relation.fieldsExpression && Object.keys(relation.fieldsExpression).length && relation.singleFieldName) {
        errorMessage += relation.path + ' ';
        errorMessage += 'expand expression contains both \"Fields\" and \"SingleField\" expressions.';
        errorMessage += EOL;
    }
    if (relation.singleFieldName) {
        if (relation.children) {
            if (relation.children.length > 1) {
                errorMessage += relation.path + ' has multiple expand expressions with a single field option.' + EOL;
            }
            if (relation.children.length === 1 && this.map[relation.children[0]].relationField !== relation.singleFieldName) {
                errorMessage += 'Expand expression ' + relation.path;
                errorMessage += ' single field \"' + relation.singleFieldName + '\"';
                errorMessage += ' does not match child relation field \"' + this.map[relation.children[0]].relationField + '\".';
                errorMessage += EOL;
            }
        }
    }

    return errorMessage;
};

/**
 * Gets the count of parent multiple relations.
 * @param relation - Starting relation.
 * @returns {number} - count of all parent multiple relations
 */
RelationTreeBuilder.prototype.getParentMultipleRelationsCount = function (relation) {
    var result = 0;
    var relationForLoop = relation;
    while (relationForLoop.parent) {
        var parentRelation = this.map[relationForLoop.parent];
        if (parentRelation.isArray() && parentRelation.parent) {
            result += 1;
        }
        relationForLoop = parentRelation;
    }
    return result;
};


/**
 * Adjusts fields expression of the parent relation based on paging setting of a relation (skip, take).
 * In that case we put a "$slice" option within the parent relation fields expression.
 * @param parentRelation
 * @param relation
 */
RelationTreeBuilder.adjustParentRelationFieldsExpression = function (parentRelation, relation) {
    if (!relation.isInvertedRelation && relation.take && typeof relation.take === 'number') {
        // when relation has filter or sorting skip and take should not be transferred to the parent relation as $slice.
        var shouldTransferPagingToParentRelation = relation.isArray() && !relation.filterExpression && !relation.sortExpression && parentRelation;
        if (shouldTransferPagingToParentRelation) {
            if (parentRelation.fieldsExpression === undefined) {
                parentRelation.fieldsExpression = {};
            }

            if (relation.skip && typeof relation.skip === 'number') {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': [relation.skip, relation.take]
                };
            } else {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': relation.take
                };
            }
            relation.take = null;
            relation.skip = null;
            relation.movedSkipTakeAsSlice = true;
        }
    }
};

/**
 * Adds field to parent relation fields expression. For example if the relation field is excluded from the master request.
 * @param fieldsExpression - Fields expression of the parent relation.
 * @param relationField - Name of the field which should be returned.
 */
RelationTreeBuilder.addFieldToFieldsExpression = function (fieldsExpression, relationField) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return;
    }
    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return;
    }

    if (isExclusive) {
        delete fieldsExpression[relationField];
    } else {
        fieldsExpression[relationField] = 1;
    }
};

/**
 * Gets if the fields expression is exclusive ("FieldName" : 0)
 * @param fieldsExpression - Fields expression to check.
 * @returns {*}
 */
RelationTreeBuilder.getIsFieldsExpressionExclusive = function (fieldsExpression) {
    var isExclusive;
    for (var fieldName in fieldsExpression) {
        if (fieldName !== Constants.IdFieldNameClient && fieldsExpression.hasOwnProperty(fieldName)) {
            if (isExclusive === undefined) {
                if (fieldsExpression[fieldName] === 0) {
                    isExclusive = true;
                    break;
                } else {
                    if (typeof fieldsExpression[fieldName] === 'object') {
                        continue;
                    } else {
                        // fieldsExpression[fieldName] === 1
                        isExclusive = false;
                        break;
                    }
                }
            }
        }
    }
    return isExclusive;
};

module.exports = RelationTreeBuilder;

},{"./Constants":32,"./ExpandError":34,"./RelationNode":36,"async":38,"underscore":1}],38:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":5}],39:[function(require,module,exports){
var EverliveError = require('./EverliveError').EverliveError;
var constants = require('./constants');
var _ = require('underscore');

module.exports = (function () {

    function AutoQueue(maxConcurrentTasks) {
        maxConcurrentTasks = parseInt(maxConcurrentTasks || constants.MaxConcurrentDownloadTasks);

        if (isNaN(maxConcurrentTasks) || maxConcurrentTasks <= 0) {
            throw new EverliveError('The maxConcurrentTasks must be a number larger than 0');
        }

        this.maxConcurrentTasks = maxConcurrentTasks;
        this.runningTasksCount = 0;
        this.tasks = [];
    }

    AutoQueue.prototype = {
        /**
         * @param {Function} task
         * @param {Function} taskSuccess
         * @param {Function} taskError
         */
        enqueue: function (task, taskSuccess, taskError) {
            if (!_.isFunction(taskSuccess) || !_.isFunction(taskError)) {
                throw new EverliveError('taskSuccess and taskError functions must be provided');
            }

            var args = [].splice.call(arguments, 3);

            this.tasks.push({
                task: task,
                args: args,
                success: taskSuccess,
                error: taskError
            });

            this._runNext();
        },

        _runNext: function () {
            var self = this;

            if (self.runningTasksCount === self.maxConcurrentTasks || !self.tasks.length) {
                return;
            }

            self.runningTasksCount++;

            var nextTask = this.tasks.shift();
            var task = nextTask.task;
            var args = nextTask.args;
            var taskSuccess = nextTask.success;
            var taskError = nextTask.error;

            args.unshift(function executedCallback(err) {
                self.runningTasksCount--;

                if (err) {
                    taskError(err);
                } else {
                    taskSuccess.apply(null, [].splice.call(arguments, 1));
                }

                self._runNext();
            });

            task.apply(null, args);
        }
    };

    return AutoQueue;
}());
},{"./EverliveError":42,"./constants":54,"underscore":1}],40:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;

var apply = function apply(obj) {
    obj._emitter = new EventEmitter();

    obj._emitterProxy = function (event, args) {
        obj._emitter[event].apply(obj._emitter, args);
    };

    obj.addListener = function () {
        obj._emitterProxy('addListener', arguments);
    };

    obj.on = obj.addListener;

    obj.removeListener = function () {
        obj._emitterProxy('removeListener', arguments);
    };

    obj.off = obj.removeListener;

    obj.once = function () {
        obj._emitterProxy('once', arguments);
    };

    obj.removeAllListeners = function () {
        obj._emitterProxy('removeAllListeners', arguments);
    };
};

module.exports = {
    apply: apply
};
},{"events":2}],41:[function(require,module,exports){
var Setup = require('./Setup');
var Data = require('./types/Data');
var usersModule = require('./types/Users');
var filesModule = require('./types/Files');
var constants = require('./constants');
var utils = require('./utils');
var buildAuthHeader = utils.buildAuthHeader;
var Push = require('./Push');
var Authentication = require('./auth/Authentication');
var offlineModule = require('./offline/offline');
var caching = require('./caching/caching');
var Request = require('./Request');
var common = require('./common');
var rsvp = common.rsvp;
var _ = common._;
var EverliveError = require('./EverliveError').EverliveError;
var EverliveErrors = require('./EverliveError').EverliveErrors;
var helpers = require('./helpers/helpers');
var EventEmitterProxy = require('./EventEmitterProxy');

// Registering mixins:
var mixins = require('./mixins/mixins');

module.exports = (function () {

    // The constructor of Everlive instances.
    // The entry point for the SDK.

    /**
     * @class Everlive
     * @classdesc The constructor of the {{site.bs}} (Everlive) JavaScript SDK. This is the entry point for the SDK.
     * @param {object|string} options - An object containing configuration options for the Setup object. Alternatively, you can pass a string representing your API key.
     * @param {string} options.apiKey - Your API key.
     * @param {string} [options.url=//api.everlive.com/v1/] - The {{site.TelerikBackendServices}} URL.
     * @param {string} [options.token] - An authentication token. The instance will be associated with the provided previously obtained token.
     * @param {string} [options.tokenType=bearer] - The type of the token that is used for authentication.
     * @param {string} [options.scheme=http] - The URI scheme used to make requests. Supported values: http, https
     * @param {boolean} [options.parseOnlyCompleteDateTimeObjects=false] - If set to true, the SDK will parse only complete date strings (according to the ISO 8601 standard).
     * @param {boolean} [options.emulatorMode=false] - Set this option to true to set the SDK in emulator mode.
     * @param {object|boolean} [options.offline] - Set this option to true to use the default offline settings.
	 * @param {boolean} [options.offline.enabled=false] - When using an object to initialize Offline Support with non-default settings, set this option to enable or disable Offline Support.
     * @param {boolean} [options.offline.isOnline=true] - Whether the storage is in online mode initially.
     * @param {ConflictResolutionStrategy|function} [options.offline.conflicts.strategy=ConflictResolutionStrategy.ClientWins] - A constant specifying the conflict resolution strategy or a function used to resolve the conflicts.
     * @param {StorageProvider|object} [options.offline.storage.provider=StorageProvider.LocalStorage] - An object specifying settings for the offline storage provider.
     * @param {string} [options.offline.storage.storagePath=el_store] - A relative path specifying where the files will be saved if file system is used for persistence for item metadata.
     * @param {number} [options.offline.storage.requestedQuota=10485760] - How much memory (in bytes) to be requested when using the file system for persistence. This option is only valid for Chrome as the other platforms use all the available space.
     * @param {string} [options.offline.encryption.key] - A key that will be used to encrypt the data stored offline.
     * @param {string} [options.offline.files.storagePath=el_file_store] - A relative path specifying where the files will be saved if file system is used for persistence of files in offline mode.
     * @param {string} [options.offline.files.metaPath=el_file_mapping] - A relative path specifying where the metadata file will be saved if file system is used for persistence of files in offline mode.
     * @param {object|boolean} [options.offline.files] - Set this option to true to enable support for files in offline mode.
     * @param {number} [options.offline.files.maxConcurrentDownloads] - The maximum amount of files that can be downloaded simultaneously.
     * @param {boolean} [options.authentication.persist=false] - Indicates whether the current user's authentication will be persisted.
     * @param {Function} [options.authentication.onAuthenticationRequired] - Invoked when the user's credentials have expired. Allowing you to perform custom logic.
     * @param {object} [options.helpers] - An object holding options for all Everlive helper components.
     * @param {object} [options.helpers.html] - HTML Helper configuration objects.
     * @param {boolean} [options.helpers.html.processOnLoad=false] - Whether to process all HTML elements when the window loads.
     * @param {boolean} [options.helpers.html.processOnResize=false] - Whether to process all HTML elements when the window resizes.
     * @param {string} [options.helpers.html.loadingImageUrl] - The image to be displayed while the original image is being processed.
     * @param {string} [options.helpers.html.errorImageUrl] - The image to be displayed when the original image processing fails.
     * @param {object} [options.helpers.html.attributes] - HTML Helper attributes configuration object.
     * @param {object} [options.helpers.html.attributes.loadingImage=data-loading-image] - A custom name for the attribute to be used to set a loading image.
     * @param {object} [options.helpers.html.attributes.errorImage=data-error-image] - A custom name for the attribute to be used to set an error image.
     * @param {object} [options.helpers.html.attributes.dpi=data-dpi] - A custom name for the attribute to be used to specify DPI settings.
     * @param {object} [options.helpers.html.attributes.imageSource=data-src] - A custom name for the attribute to be used to set the image source.
     * @param {object} [options.helpers.html.attributes.fileSource=data-href] - A custom name for the attribute to be used to set the anchor source.
     * @param {object} [options.helpers.html.attributes.enableOffline=data-offline] - A custom name for the attribute to be used to control offline processing.
     * @param {object} [options.helpers.html.attributes.enableResponsive=data-responsive] - A custom name for the attribute to be used to control Responsive Images processing.
     */
    function Everlive(options) {
        var self = this;
        this.setup = new Setup(options);
        _.each(initializations, function (init) {
            init.func.call(self, options);
        });

        if (Everlive.$ === null) {
            Everlive.$ = self;
        }

        EventEmitterProxy.apply(this);
    }

    /**
     * Adds an event listener to the SDK.
     * @method addListener
     * @param {String} eventName The name of the event to which to subscribe.
     * @param {Function} eventListener An event listener which will be called once the event is raised.
     * @memberOf Everlive.prototype
     */

    /**
     * Adds an event listener to the SDK.
     * @method on
     * @param {String} eventName The name of the event to which to subscribe.
     * @param {Function} eventListener An event listener which will be called once the event is raised.
     * @memberOf Everlive.prototype
     */

    /**
     * Removes an SDK event listener.
     * @method removeListener
     * @param {String} eventName The name of the event for which to stop listening.
     * @param {Function} eventListener The event listener to remove.
     * @memberOf Everlive.prototype
     */

    /**
     * Removes an SDK event listener.
     * @method off
     * @param {Function} eventListener
     * @memberOf Everlive.prototype
     */

    /**
     * Adds an event listener to the SDK which will be called only the first time the event is emitted.
     * @method once
     * @param {String} eventName The name of the event to which to subscribe.
     * @param {Function} eventListener An event listener which will be called once the event is raised.
     * @memberOf Everlive.prototype
     */

    /**
     * Removes all SDK event listeners.
     * @memberOf Everlive.prototype
     * @method removeAllListeners
     */

    /** Reference to the current {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
     * @memberOf Everlive
     * @type {Everlive}
     * @static
     */
    Everlive.$ = null;
    Everlive.idField = constants.idField;


    // An array keeping initialization functions called by the Everlive constructor.
    // These functions will be used to extend the functionality of an Everlive instance.
    var initializations = [];

    /** An array of functions that are invoked during instantiation of the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
     * @memberOf Everlive
     * @type {Function[]}
     * @static
     * @private
     */
    Everlive.initializations = initializations;

    Everlive.init = function (options) {
        Everlive.$ = null;
        return new Everlive(options);
    };

    /**
     * Creates a new {@link Data} class.
     * @memberOf Everlive.prototype
     * @instance
     * @param {String} collectionName The name of the collection to be used.
     * @returns {Data}
     */
    Everlive.prototype.data = function (collectionName) {
        return new Data(this.setup, collectionName, this.offlineStorage, this);
    };

    /**
     * Returns the URL to the {{site.bs}} application endpoint that the SDK uses.
     * @memberOf Everlive.prototype
     * @method buildUrl
     * @returns {string} The generated URL.
     */
    Everlive.prototype.buildUrl = function () {
        return utils.buildUrl(this.setup);
    };

    /**
     * Generates the Authorization headers that are used by the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK to make requests to the {{site.bs}} servers.
     * @memberOf Everlive
     * @returns {Object} AuthorizationHeaders The generated Authorization headers object.
     */
    Everlive.prototype.buildAuthHeader = function () {
        return buildAuthHeader(this.setup);
    };

    Everlive.disableRequestCache = utils.disableRequestCache;

    Everlive.AuthStatus = constants.AuthStatus;

    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @deprecated
     * @see {@link Authentication.getAuthenticationStatus}
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @deprecated
     * @see {@link Authentication.getAuthenticationStatus}
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Everlive.prototype.authInfo = function (success, error) {
        var self = this;
        return utils.buildPromise(function (success, error) {
            var setup = self.setup;
            if (setup.masterKey) {
                return success({status: Everlive.AuthStatus.masterKey});
            }

            if (!setup.token) {
                return success({status: Everlive.AuthStatus.unauthenticated});
            }

            if (self.authentication && self.authentication.isAuthenticationInProgress()) {
                return success({status: Everlive.AuthStatus.authenticating});
            }

            self.Users
                .skipAuth(true)
                .currentUser()
                .then(function (res) {
                    return success({status: Everlive.AuthStatus.authenticated, user: res.result});
                }, function (err) {
                    if (self.authentication && self.authentication.isAuthenticationInProgress()) {
                        return success({status: Everlive.AuthStatus.authenticating});
                    } else if (err.code === EverliveErrors.invalidRequest.code || err.code === EverliveErrors.expiredToken.code) { // invalid request, i.e. the access token is invalid or missing
                        return success({status: Everlive.AuthStatus.invalidAuthentication});
                    } else {
                        return error(err);
                    }
                });
        }, success, error);
    };

    /**
     * Make a request to the current {{site.bs}} JavaScript SDK instance.
     * @method request
     * @memberOf Everlive.prototype
     * @param {object} options Object used to configure the request.
     * @param {object} [options.endpoint] The endpoint of the {{site.bs}} JavaScript API relative to the API key section. (For example, options.endpoint = MyType will make a request to the MyType type.)
     * @param {HttpMethod} [options.method] HTTP request method.
     * @param {object} [options.data] Data to be sent with the request.
     * @param {Function} [options.success] Success callback that will be called when the request finishes successfully.
     * @param {Function} [options.error] Error callback to be called in case of an error.
     * @param {object} [options.headers] Additional headers to be included in the request.
     * @param {Query|object} [options.filter] This is either a {@link Query} or a [filter]({% slug rest-api-querying-filtering %}) expression.
     * @param {boolean} [options.authHeaders=true] When set to false, no Authorization headers will be sent with the request.
     * @returns {function} The request configuration object containing the `send` function that sends the request.
     */
    Everlive.prototype.request = function (options) {
        return new Request(this.setup, options);
    };

    function protectOfflineEnabled() {
        if (!this._isOfflineStorageEnabled()) {
            throw new EverliveError('You have instantiated the SDK without support for offline storage');
        }
    }

    Everlive.prototype._isOfflineStorageEnabled = function () {
        var offlineStorageOptions = this.setup.offlineStorage || this.setup.offline;
        return offlineStorageOptions && offlineStorageOptions.enabled !== false;
    };

    /**
     * Sets the SDK to work in offline mode.
     * @method offline
     * @memberOf Everlive.prototype
     * @param {boolean} [isOffline = true] Boolean parameter for setting the SDK to online or offline mode.
     */
    Everlive.prototype.offline = function () {
        protectOfflineEnabled.call(this);

        var isOffline;
        if (arguments.length === 0) {
            isOffline = true;
        } else {
            isOffline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(isOffline);
    };

    /**
     * Sets the SDK to work in online mode.
     * @method online
     * @memberOf Everlive.prototype
     * @param {boolean} [isOnline = true] Boolean parameter for setting the SDK to online or offline mode.
     */
    Everlive.prototype.online = function () {
        protectOfflineEnabled.call(this);

        var isOnline;
        if (arguments.length === 0) {
            isOnline = true;
        } else {
            isOnline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(!isOnline);
    };

    /**
     * Check if the SDK is in offline mode.
     * @method isOffline
     * @memberOf Everlive.prototype
     * @returns {boolean} Returns true if the SDK is in offline mode.
     */
    Everlive.prototype.isOffline = function () {
        protectOfflineEnabled.call(this);
        return !this.isOnline();
    };

    /**
     * Check if the SDK is in online mode.
     * @method isOnline
     * @memberOf Everlive.prototype
     * @returns {boolean} Returns true if the SDK is in online mode.
     */
    Everlive.prototype.isOnline = function () {
        return this.offlineStorage.isOnline();
    };

    /**
     * Starts the synchronization procedure. Emits the 'syncStart' event when started and the 'syncEnd' event when the procedure finishes. 'syncEnd' contains information about the completed sync operation that you can use to find out how many items were synchronized.
     * @method sync
     * @memberOf Everlive.prototype
     */
    Everlive.prototype.sync = function () {
        protectOfflineEnabled.call(this);
        return this.offlineStorage.sync.apply(this.offlineStorage, arguments);
    };

    var initDefault = function initDefault() {
        var users = this.data('Users');
        usersModule.addUsersFunctions(users, this);

        /**
         * @memberOf Everlive
         * @instance
         * @deprecated
         * @see {@link Everlive.users}
         * @description An instance of the [Users]{@link Users} class for working with users.
         * @member {Users} Users
         */
        this.Users = users;

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Users]{@link Users} class for working with users.
         * @member {Users} users
         */
        this.users = users;

        var files = this.data('Files');
        filesModule.addFilesFunctions(files);

        /**
         * @memberOf Everlive
         * @instance
         * @deprecated Use everlive.files instead
         * @see {@link Everlive.files}
         * @description An instance of the [Files]{@link Files} class for working with files.
         * @member {Files} Files
         */
        this.Files = files;

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Files]{@link Files} class for working with files.
         * @member {Files} files
         */
        this.files = files;

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Push]{@link Push} class for working with push notifications.
         * @member {Push} push
         */
        this.push = new Push(this);
    };

    var initAuthentication = function initAuthentication() {
        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Authentication]{@link Authentication} class for working with the authentication of the SDK.
         * @member {Authentication} authentication
         */
        this.authentication = new Authentication(this, this.setup.authentication);
    };

    var initializeHelpers = function initializeHelpers(options) {
        var self = this;
        self.helpers = {};

        _.each(helpers, function (helper) {
            var helperOptions = options.helpers ? options.helpers[helper.name] : null;
            self.helpers[helper.name] = new helper.ctor(self, helperOptions);
        });
    };

    initializations.push({name: 'caching', func: caching.initCaching});
    initializations.push({name: 'offlineStorage', func: offlineModule.initOfflineStorage});
    initializations.push({name: 'cacheStore', func: caching._initStore});
    initializations.push({name: 'default', func: initDefault});
    initializations.push({name: 'authentication', func: initAuthentication});
    initializations.push({name: 'helpers', func: initializeHelpers});

    return Everlive;
}());

},{"./EventEmitterProxy":40,"./EverliveError":42,"./Push":46,"./Request":47,"./Setup":48,"./auth/Authentication":49,"./caching/caching":52,"./common":53,"./constants":54,"./helpers/helpers":57,"./mixins/mixins":63,"./offline/offline":71,"./types/Data":91,"./types/Files":92,"./types/Users":93,"./utils":94}],42:[function(require,module,exports){
var EverliveErrors = {
    itemNotFound: {
        code: 801,
        message: 'Item not found.'
    },
    syncConflict: {
        code: 10001,
        message: 'A conflict occurred while syncing data.'
    },
    syncError: {
        code: 10002,
        message: 'Synchronization failed for item.'
    },
    syncInProgress: {
        code: 10003,
        message: 'Cannot perform operation while synchronization is in progress.'
    },
    syncCancelledByUser: {
        code: 10004,
        message: 'Synchronization cancelled by user.'
    },
    operationNotSupportedOffline: {
        code: 20000 // the error message is created dynamically based on the query filter for offline storage
    },
    generalDatabaseError: {
        code: 107,
        message: 'General database error.'
    },
    invalidToken: {
        code: 301,
        message: 'Invalid access token.'
    },
    expiredToken: {
        code: 302,
        message: 'Expired access token.'
    },
    invalidExpandExpression: {
        code: 618,
        message: 'Invalid expand expression.'
    },
    invalidRequest: {
        code: 601,
        message: 'Invalid request.'
    },
    missingContentType: {
        code: 701,
        message: 'ContentType not specified.'
    },
    missingOrInvalidFileContent: {
        code: 702,
        message: 'Missing or invalid file content.'
    },
    customFileSyncNotSupported: {
        code: 703,
        message: 'Custom ConflictResolution for files is not allowed.'
    },
    cannotDownloadOffline: {
        code: 704,
        message: 'Cannot download a file while offline.'
    },
    cannotForceCacheWhenDisabled: {
        code: 705,
        message: 'Cannot use forceCache while the caching is disabled.'
    }
};

var EverliveError = (function () {
    function EverliveError(message, code) {
        var tmpError = Error.apply(this);

        if (typeof message === 'object') {
            var err = message;
            message = err.message;
            code = err.code;
        }

        tmpError.message = message;
        tmpError.code = code || 0;
        tmpError.name = this.name = 'EverliveError';

        this.message = tmpError.message;
        this.code = code;

        Object.defineProperty(this, 'stack', {
            get: function () {
                return tmpError.stack
            }
        });

        return this;
    }

    EverliveError.prototype = Object.create(Error.prototype);
    EverliveError.prototype.toJSON = function () {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            stack: this.stack
        };
    };

    return EverliveError;
}());

var DeviceRegistrationError = (function () {
    var DeviceRegistrationError = function (errorType, message, additionalInformation) {
        EverliveError.call(this, message);
        this.errorType = errorType;
        this.message = message;
        if (additionalInformation !== undefined) {
            this.additionalInformation = additionalInformation;
        }
    };

    DeviceRegistrationError.prototype = Object.create(EverliveError.prototype);

    DeviceRegistrationError.fromEverliveError = function (everliveError) {
        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.EverliveError, everliveError.message, everliveError);
        return deviceRegistrationError;
    };

    DeviceRegistrationError.fromPluginError = function (errorObj) {
        var message = 'A plugin error occurred';
        if (errorObj) {
            if (typeof errorObj.error === 'string') {
                message = errorObj.error;
            } else if (typeof errorObj.message === 'string') {
                message = errorObj.message;
            }
        }

        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.PluginError, message, errorObj);
        return deviceRegistrationError;
    };

    var DeviceRegistrationErrorTypes = {
        EverliveError: 1,
        PluginError: 2
    };

    return DeviceRegistrationError;
}());

module.exports = {
    EverliveError: EverliveError,
    EverliveErrors: EverliveErrors,
    DeviceRegistrationError: DeviceRegistrationError
};
},{}],43:[function(require,module,exports){
var Processor = require('./common').Processor;
var DataQuery = require('./query/DataQuery');
var Query = require('./query/Query');
var EverliveError = require('./EverliveError').EverliveError;
var constants = require('./constants');

module.exports = (function () {
    return new Processor({
        executionNodeFunction: function (node, expandContext, done) {
            var targetTypeName = node.targetTypeName.toLowerCase() === constants.FilesTypeNameLegacy ? constants.FilesTypeName : node.targetTypeName;

            var query = new DataQuery({
                operation: DataQuery.operations.read,
                collectionName: targetTypeName,
                filter: new Query(node.filter, node.select, node.sort, node.skip, node.take)
            });

            expandContext.offlineModule.processQuery(query).then(function (data) {
                done(null, data.result);
            }, done);
        }
    });
}());

},{"./EverliveError":42,"./common":53,"./constants":54,"./query/DataQuery":80,"./query/Query":81}],44:[function(require,module,exports){
module.exports = (function () {
    function Expression(operator, operands) {
        this.operator = operator;
        this.operands = operands || [];
    }

    Expression.prototype = {
        addOperand: function (operand) {
            this.operands.push(operand);
        }
    };

    return Expression;
}());
},{}],45:[function(require,module,exports){
module.exports = (function () {
    //TODO add a function for calculating the distances in geospatial queries

    /**
     * @classdesc A class representing a value for the {{site.TelerikBackendServices}} GeoPoint field.
     * @class GeoPoint
     * @param longitude Longitude of the GeoPoint in decimal degrees (range: -180 to 180). Example: `123.3239467`
     * @param latitude Latitude of the GeoPoint in decimal degrees (range: -90 to 90). Example: `42.6954322`
     */
    function GeoPoint(longitude, latitude) {
        this.longitude = longitude || 0;
        this.latitude = latitude || 0;
    }

    return GeoPoint;
}());
},{}],46:[function(require,module,exports){
var utils = require('./utils');
var buildPromise = utils.buildPromise;
var DeviceRegistrationResult = utils.DeviceRegistrationResult;
var everliveErrorModule = require('./EverliveError');
var DeviceRegistrationError = everliveErrorModule.DeviceRegistrationError;
var EverliveError = everliveErrorModule.EverliveError;
var CurrentDevice = require('./push/CurrentDevice');
var Platform = require('./constants').Platform;

module.exports = (function () {
    /**
     * @class Push
     * @classdesc A class for managing push notifications in your application. Supported are push notifications for hybrid apps on Android and iOS.
     * @protected
     * @param el {Everlive} Everlive Object
     */
    function Push(el) {
        this._el = el;
        this.notifications = el.data('Push/Notifications');
        this.devices = el.data('Push/Devices');
    }

    Push.prototype = {

        /**
         * Ensures that the Telerik Push Notifications plug-in has been loaded and is ready to use. An {EverliveError} is returned if the plug-in is not available.
         * @method ensurePushIsAvailable
         * @memberOf Push.prototype
         */
        ensurePushIsAvailable: function () {
            CurrentDevice.ensurePushIsAvailable();            
        },
        /**
         * Returns the current device for sending push notifications
         * @deprecated since version 1.2.7
         * @see [Push.register]{@link push.register}
         * @memberOf Push.prototype
         * @method currentDevice
         * @name currentDevice
         * @param [emulatorMode] {Boolean} If set to true, emulator mode is enabled meaning you cannot send push notifications.
         * @returns {CurrentDevice} Returns an instance of CurrentDevice.
         */
        currentDevice: function (emulatorMode) {
            this.ensurePushIsAvailable();

            if (arguments.length === 0) {
                emulatorMode = this._el.setup._emulatorMode;
            }            

            if (!this._currentDevice) {
                this._currentDevice = new CurrentDevice(this);
            }

            var inAppBuilderSimulator = typeof window !== undefined && window.navigator && window.navigator.simulator;

            this._currentDevice.emulatorMode = emulatorMode || inAppBuilderSimulator;

            return this._currentDevice;
        },

        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings An object containing settings for the registration. It can include custom parameters to be stored by {{site.bs}}.
         * @param {Object} settings.iOS=null iOS-specific settings.
         * @param {Boolean} settings.iOS.alert=true If set to true, the push notification will display as a standard iOS alert.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.clearBadge=false Specifies whether to reset the badge count to 0.
         * @param {Boolean} settings.iOS.sound=true If set to true, the device will play a notification sound.
         * @param {Object} settings.android=null Android-specific settings.
         * @param {String} settings.android.senderID=null Your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings.
         * @param {String} settings.wp8.channelName=null The name of the push channel that the device is registering to.
         * @param {Function} settings.notificationCallbackIOS Specifies a custom callback to be used when a push notification is received on iOS.
         * @param {Function} settings.notificationCallbackAndroid Specifies a custom callback to be used when a push notification is received on Android.
         * @param {Function} settings.notificationCallbackWP8 Specifies a custom callback to be used when a push notification is received on Windows Phone 8.
         * @param {Object} settings.customParameters=null Specifies optional custom registration parameters that will be saved in Telerik Backend Services.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * Telerik Backend Services if it hasn't already been registered.
         * If it was registered the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings Settings for the registration. Can include custom parameters to be saved in backend services.
         * @param {Object} settings.iOS=null iOS specific settings
         * @param {Boolean} settings.iOS.alert=true Specifies whether the device will display an alert message.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.clearBadge=false Specifies whether to reset the badge count to 0.
         * @param {Boolean} settings.iOS.sound=true Specifies whether the device will play a sound.
         * @param {Object} settings.android=null Android specific settings
         * @param {String} settings.android.senderID=null This is your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings
         * @param {String} settings.wp8.channelName=null The name of the push channel that the device is registering to.
         * @param {Function} settings.notificationCallbackIOS Specifies a custom callback to be used when a push notification is received on iOS.
         * @param {Function} settings.notificationCallbackAndroid Specifies a custom callback to be used when a push notification is received on Android.
         * @param {Function} settings.notificationCallbackWP8 Specifies a custom callback to be used when a push notification is received on Windows Phone 8.
         * @param {Object} settings.customParameters=null Specifies optional custom registration parameters that will be saved in Telerik Backend Services.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (settings, success, error) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            var self = this;
            settings = settings || {};

            if (settings.android) {
                settings.android.senderID = settings.android.projectNumber || settings.android.senderID;
            }

            var successCallback = function (token, callback) {
                var result = new DeviceRegistrationResult(token);
                callback(result);
            };

            var errorCallback = function (err, callback) {
                var registrationError = DeviceRegistrationError.fromEverliveError(err);
                callback(registrationError);
            };

            var clearBadgeIfNeeded = function (token, successCb, errorCb) {
                var platformType = currentDevice._getPlatformType();
                var clearBadge = platformType === Platform.iOS;

                if (clearBadge && settings.iOS) {
                    clearBadge = settings.iOS.clearBadge !== false;
                }

                if (clearBadge) {
                    self.clearBadgeNumber().then(function () {
                        successCallback(token, successCb);
                    }, function (err) {
                        errorCallback(err, errorCb);
                    });
                } else {
                    successCallback(token, successCb);
                }
            };

            return buildPromise(function (successCb, errorCb) {
                currentDevice.enableNotifications(settings, function (response) {
                    var token = response.token;
                    var customParameters = settings.customParameters;
                    currentDevice.getRegistration()
                        .then(function () {
                            currentDevice.updateRegistration(customParameters, function () {
                                clearBadgeIfNeeded(token, successCb, errorCb);
                            }, function (err) {
                                errorCallback(err, errorCb);
                            });
                        }, function (err) {
                            if (err.code === 801) { //Not registered
                                currentDevice.register(customParameters, function () {
                                    clearBadgeIfNeeded(token, successCb, errorCb);
                                }, errorCb);
                            } else {
                                errorCallback(err, errorCb);
                            }
                        });
                }, function (err) {
                    var deviceRegistrationError = DeviceRegistrationError.fromPluginError(err);
                    errorCb(deviceRegistrationError);
                });
            }, success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * This method invalidates any push tokens that were obtained for the device from the current application.
         * The device will also be unregistered from Telerik Backend Services.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        unregister: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.disableNotifications.apply(currentDevice, arguments);
        },

        /**
         * Updates the registration of the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.updateRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sets the badge number on the {{site.TelerikBackendServices}} server.
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the badge number on the server
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        setBadgeNumber: function (badge, onSuccess, onError) {
            this.ensurePushIsAvailable();

            badge = parseInt(badge);
            if (isNaN(badge)) {
                return buildPromise(function (success, error) {
                    error(new EverliveError('The badge must have a numeric value'));
                }, onSuccess, onError);
            }

            var deviceRegistration = {};
            var currentDevice = this.currentDevice();
            var deviceId = currentDevice._getDeviceId();
            deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceId);
            deviceRegistration.BadgeCounter = badge;
            return buildPromise(function (successCb, errorCb) {
                currentDevice._pushHandler.devices.updateSingle(deviceRegistration).then(
                    function () {
                        if (window.plugins && window.plugins.pushNotification) {
                            return window.plugins.pushNotification.setApplicationIconBadgeNumber(successCb, errorCb, badge);
                        } else {
                            return successCb();
                        }
                    }, errorCb)
            }, onSuccess, onError);
        },

        /**
         * Resets the badge number on the {{site.TelerikBackendServices}} server to 0.
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Clears the badge number on the server by setting it to 0
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        clearBadgeNumber: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.setBadgeNumber(0, onSuccess, onError);
        },

        /**
         * Returns the push notifications registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        getRegistration: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.getRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sends a push notification.
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @returns {Promise} The promise for request.
         */
        /**
         * Sends a push message
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        send: function (notification, onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.notifications.create.apply(this.notifications, arguments);
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function (options, onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.areNotificationsEnabled(options, onSuccess, onError);
        }
    };

    return Push;
}());
},{"./EverliveError":42,"./constants":54,"./push/CurrentDevice":78,"./utils":94}],47:[function(require,module,exports){
var utils = require('./utils');
var rsvp = require('./common').rsvp;
var buildAuthHeader = utils.buildAuthHeader;
var parseUtilities = utils.parseUtilities;
var guardUnset = utils.guardUnset;
var common = require('./common');
var reqwest = common.reqwest;
var _ = common._;
var Headers = require('./constants').Headers;
var isNodejs = require('./everlive.platform').isNodejs;
var Query = require('./query/Query');

module.exports = (function () {
    var _self;

    // The Request type is an abstraction over Ajax libraries
    // A Request object needs information about the Everlive connection and initialization options

    function Request(setup, options) {
        guardUnset(setup, 'setup');
        guardUnset(options, 'options');
        this.setup = setup;
        this.method = null;
        this.endpoint = null;
        this.data = null;
        this.headers = {};
        // TODO success and error callbacks should be uniformed for all ajax libs
        this.success = null;
        this.error = null;
        this.parse = Request.parsers.simple;

        _.extend(this, options);
        _self = this;
        this._init(options);
    }

    Request.prototype = {
        // Calls the underlying Ajax library
        send: function () {
            Request.sendRequest(this);
        },
        // Returns an authorization header used by the request.
        // If there is a logged in user for the Everlive instance then her/his authentication will be used.
        buildAuthHeader: buildAuthHeader,
        // Builds the URL of the target Everlive service
        buildUrl: function buildUrl(setup) {
            return utils.buildUrl(setup);
        },
        // Processes the given query to return appropriate headers to be used by the request
        buildQueryHeaders: function buildQueryHeaders(query) {
            if (query) {
                if (query instanceof Query) {
                    return Request.prototype._buildQueryHeaders(query);
                }
                else {
                    return Request.prototype._buildFilterHeader(query);
                }
            }
            else {
                return {};
            }
        },
        // Initialize the Request object by using the passed options
        _init: function (options) {
            _.extend(this.headers, this.buildAuthHeader(this.setup, options), this.buildQueryHeaders(options.filter), options.headers);
        },
        // Translates an Everlive.Query to request headers
        _buildQueryHeaders: function (query) {
            query = query.build();
            var headers = {};
            if (query.$where !== null) {
                headers[Headers.filter] = JSON.stringify(query.$where);
            }
            if (query.$select !== null) {
                headers[Headers.select] = JSON.stringify(query.$select);
            }
            if (query.$sort !== null) {
                headers[Headers.sort] = JSON.stringify(query.$sort);
            }
            if (query.$skip !== null) {
                headers[Headers.skip] = query.$skip;
            }
            if (query.$take !== null) {
                headers[Headers.take] = query.$take;
            }
            if (query.$expand !== null) {
                headers[Headers.expand] = JSON.stringify(query.$expand);
            }
            return headers;
        },
        // Creates a header from a simple filter
        _buildFilterHeader: function (filter) {
            var headers = {};
            headers[Headers.filter] = JSON.stringify(filter);
            return headers;
        }
    };

    var parseOnlyCompleteDateTimeString = _self && _self.setup && _self.setup.parseOnlyCompleteDateTimeObjects;

    var reviver = parseUtilities.getReviver(parseOnlyCompleteDateTimeString);

    Request.parsers = {
        simple: {
            result: parseUtilities.parseResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        single: {
            result: parseUtilities.parseSingleResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        update: {
            result: parseUtilities.parseUpdateResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        }
    };

    // TODO built for request
    if (typeof Request.sendRequest === 'undefined') {
        Request.sendRequest = function (request) {
            var url = request.buildUrl(request.setup) + request.endpoint;
            url = utils.disableRequestCache(url, request.method);
            request.method = request.method || 'GET';
            var data = request.method === 'GET' ? request.data : JSON.stringify(request.data);

            var requestParams = {
                url: url,
                method: request.method,
                data: data,
                headers: request.headers,
                contentType: 'application/json'
            };

            if (isNodejs) {
                requestParams.success = function (data, response) {
                    request.success.call(request, request.parse.result(data), response);
                };

                requestParams.error = function (jqXHR) {
                    request.error.call(request, request.parse.error(jqXHR.responseText || jqXHR.statusText));
                };
            } else {
                requestParams.type = 'json';
                requestParams.crossOrigin = true;
                requestParams.success = function (data, textStatus, jqXHR) {
                    var result = request.parse.result(data);
                    request.success.call(request, result);
                };

                requestParams.error = function (jqXHR, textStatus, errorThrown) {
                    var error = request.parse.error(jqXHR.responseText || jqXHR.statusText);
                    request.error.call(request, error);
                };
            }

            reqwest(requestParams);
        };
    }

    return Request;
}());
},{"./common":53,"./constants":54,"./everlive.platform":56,"./query/Query":81,"./utils":94}],48:[function(require,module,exports){
var _ = require('./common')._;
var constants = require('./constants');
var AuthenticationSetup = require('./auth/AuthenticationSetup');

module.exports = (function () {
    var everliveUrl = constants.everliveUrl;

    // An object that keeps information about an Everlive connection
    function Setup(options) {
        this.url = everliveUrl;
        this.apiKey = null;
        this.masterKey = null;
        this.token = null;
        this.tokenType = null;
        this.principalId = null;
        this.scheme = 'http'; // http or https
        this.parseOnlyCompleteDateTimeObjects = false;
        if (typeof options === 'string') {
            this.apiKey = options;
        } else {
            this._emulatorMode = options.emulatorMode;
            _.extend(this, options);
        }

        this.authentication = new AuthenticationSetup(this, options.authentication);
    }

    Setup.prototype.setAuthorizationProperties = function (token, tokenType, principalId) {
        this.token = token;
        this.tokenType = tokenType;
        this.principalId = principalId;
    };

    Setup.prototype.getAuthorizationProperties = function () {
        return {
            token: this.token,
            tokenType: this.tokenType,
            principalId: this.principalId
        };
    };

    return Setup;

}());
},{"./auth/AuthenticationSetup":50,"./common":53,"./constants":54}],49:[function(require,module,exports){
'use strict';
var utils = require('../utils');
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var Everlive = require('../Everlive');
var constants = require('../constants');
var usersCollectionName = 'Users';
var buildPromise = utils.buildPromise;
var LocalStore = require('../storages/LocalStore');
var EverliveErrors = require('../EverliveError').EverliveErrors;

module.exports = (function () {
    /**
     * @class Authentication
     * @classdesc A class for managing authentication of a user in your application.
     * @protected
     * @param el {Everlive} Everlive Object
     * @param setup {AuthSetup} the authentication setup object
     */
    var Authentication = function (el, setup) {
        this.authSetup = setup || {};
        this._el = el;
        this._authenticationCallbacks = null;
        if (this.authSetup.persist) {
            this._localStore = new LocalStore(el);
            var localStoreKey = this._getLocalStoreKey();
            var authOptions = this._localStore.getItem(localStoreKey);
            var authInfo;
            if (authOptions) {
                authInfo = JSON.parse(this._localStore.getItem(localStoreKey));
            }
            if (authInfo) {
                this._el.setup.setAuthorizationProperties(authInfo.token, authInfo.tokenType, authInfo.principalId);
            }
        }
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.login = function (username, password, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLogin,
                collectionName: usersCollectionName,
                data: {
                    username: username,
                    password: password,
                    grant_type: 'password'
                },
                skipAuth: true,
                onSuccess: successFunc,
                onError: error
            });

            return self._el.Users.processDataQuery(query);
        }, success, error);
    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.logout = function (success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._logoutSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var errorFunc = function (err) {
                if (err.code === 301) { //invalid token
                    self.clearAuthorization();
                }

                error.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLogout,
                collectionName: usersCollectionName,
                skipAuth: true,
                onSuccess: successFunc,
                onError: errorFunc
            });

            return self._el.Users.processDataQuery(query);
        }, success, error);
    };

    Authentication.prototype._getLocalStoreKey = function () {
        return constants.AuthStoreKey + this._el.setup.apiKey + '$authentication';
    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithFacebook = function (accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithADFS = function (accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithLiveID = function (accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithGoogle = function (accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithTwitter = function (token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Authentication.prototype
     * @method setAuthorization
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */
    Authentication.prototype.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        this._el.setup.setAuthorizationProperties(token, tokenType, principalId);

        if (this.authSetup.persist) {
            var localStoreKey = this._getLocalStoreKey();
            var authorizationProperties = this._el.setup.getAuthorizationProperties();
            this._localStore.setItem(localStoreKey, JSON.stringify(authorizationProperties));
        }

        if (this._authenticationCallbacks) {
            this._authenticationCallbacks.success();
            this._authenticationCallbacks = null;
        }
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the authorization token that was used, will not be invalidated.
     * @method clearAuthorization
     * @memberOf Authentication.prototype
     */
    Authentication.prototype.clearAuthorization = function clearAuthorization() {
        this.setAuthorization(null, null, null);
        this.clearPersistedAuthentication();
    };

    /**
     * Clears the current persisted authentication from the local store for the current {{site.bs}} JavaScript SDK instance. Will not logout or modify the current authentication of the Javascript SDK.
     * @method clearPersistedAuthentication
     * @memberOf Authentication.prototype
     */
    Authentication.prototype.clearPersistedAuthentication = function () {
        if (this._localStore) {
            var localStoreKey = this._getLocalStoreKey();
            this._localStore.removeItem(localStoreKey);
            this._el.setup.setAuthorizationProperties(null, null, null);
        }
    };

    /**
     * @memberOf Authentication.prototype
     * Returns whether authentication requirement is enabled for the current instance of the {{site.bs}} JavaScript SDK.
     * @returns {boolean} whether an onAuthenticationRequired function is provided
     */
    Authentication.prototype.isAuthenticationInProgress = function () {
        return typeof this.authSetup.onAuthenticationRequired === 'function';
    };

    /** Ensures that authentication is completed before continuing.
     * @memberOf Authentication.prototype
     * @private
     * @returns {Promise} A promise that will be resolved when the authentication is complete. See {{@link Everlive.prototype.completeAuthentication}}.
     * @throws throws an error if no onAuthenticationRequired handler is provided to the setup.
     */
    Authentication.prototype._ensureAuthentication = function () {
        if (!this.isAuthenticationInProgress()) {
            throw new Error('onAuthenticationRequired option of Everlive.Setup.Authentication is required.');
        }
        if (this.isAuthenticating()) {
            return this._authenticationCallbacks.promise;
        }

        this.clearAuthorization();
        this.authSetup.onAuthenticationRequired.call(this);
        this._authenticationCallbacks = utils.getCallbacks();
        return this._authenticationCallbacks.promise;
    };

    /**
     * A method that should be called with the authentication result.
     * @memberOf Authentication.prototype
     * @param authentication authentication object containing information about the
     * @param authentication.access_token
     * @param authentication.token_type
     * @param authentication.principal_id
     */
    Authentication.prototype.completeAuthentication = function (authentication) {
        this._el.setAuthorization(authentication.access_token, authentication.token_type, authentication.principal_id);
    };
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @param {Everlive.Callbacks.authenticationStatusSuccess} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.getAuthenticationStatus = function (success, error) {
        var self = this;
        return utils.buildPromise(function (success, error) {
            var setup = self._el.setup;
            if (setup.masterKey) {
                return success({status: constants.AuthStatus.masterKey});
            }

            if (!setup.token) {
                return success({status: constants.AuthStatus.unauthenticated});
            }

            if (self.isAuthenticationInProgress()) {
                return success({status: constants.AuthStatus.authenticating});
            }

            self._el.Users
                .skipAuth(true)
                .currentUser()
                .then(function (res) {
                    return success({status: constants.AuthStatus.authenticated, user: res.result});
                }, function (err) {
                    if (self.isAuthenticationInProgress()) {
                        return success({status: constants.AuthStatus.authenticating});
                    } else if (err.code === EverliveErrors.invalidRequest.code || err.code === EverliveErrors.invalidToken.code) { // invalid request, i.e. the access token is invalid or missing
                        return success({status: constants.AuthStatus.invalidAuthentication});
                    } else if (err.code === EverliveErrors.expiredToken.code) {
                        return success({status: constants.AuthStatus.expiredAuthentication});
                    } else {
                        return error(err);
                    }
                });
        }, success, error);
    };

    /** Returns whether the {{site.TelerikBackendServices}} is currently waiting for authentication to be completed. See {{@link Everlive.prototype.completeAuthentication}}.
     * @memberOf Everlive.prototype
     * @returns {boolean}
     */
    Authentication.prototype.isAuthenticating = function () {
        return !!this._authenticationCallbacks;
    };

    Authentication.prototype._loginSuccess = function (data) {
        var result = data.result;
        this.setAuthorization(result.access_token, result.token_type, result.principal_id);
    };

    Authentication.prototype._logoutSuccess = function () {
        this.clearAuthorization();
    };

    Authentication.prototype._loginWithProvider = function (identity, success, error) {
        var user = {
            Identity: identity
        };
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLoginWithProvider,
                collectionName: usersCollectionName,
                data: user,
                authHeaders: false,
                skipAuth: true,
                parse: Request.parsers.single,
                onSuccess: successFunc,
                onError: error
            });

            self._el.Users.processDataQuery(query);
        }, success, error);
    };

    return Authentication;
}());

},{"../Everlive":41,"../EverliveError":42,"../Request":47,"../constants":54,"../query/DataQuery":80,"../storages/LocalStore":88,"../utils":94}],50:[function(require,module,exports){
'use strict';
module.exports = (function () {
    var AuthenticationSetup = function (everlive, options) {
        options = options || {};
        this.onAuthenticationRequired = options.onAuthenticationRequired;
        this.persist = options.persist;
    };

    return AuthenticationSetup;
}());
},{}],51:[function(require,module,exports){
'use strict';

var constants = require('../constants');
var common = require('../common');
var utils = require('../utils');
var buildPromise = utils.buildPromise;
var jsonStringify = common.jsonStringify;
var rsvp = common.rsvp;
var _ = require('underscore');

var persisters = require('../offline/offlinePersisters');
var EverliveError = require('../EverliveError').EverliveError;
var Query = require('../query/Query');
var DataQuery = require('../query/DataQuery');
var buildOfflineStorageOptions = require('../offline/offline').buildOfflineStorageOptions;

var CacheModule = function (options, everlive) {
    this.options = options;
    this.typeSettings = this.options.typeSettings;
    this.maxAgeInMs = this.options.maxAge * 60 * 1000;
    this._everlive = everlive;
};

var cacheableOperations = [
    DataQuery.operations.read,
    DataQuery.operations.readById,
    DataQuery.operations.count
];

CacheModule.prototype = {
    _hash: function (obj) {
        return jsonStringify(obj);
    },

    // using the offline storage options to initialize the same type of storage
    _initStore: function (sdkOptions) {
        if (!this.persister) {
            var offlineStorageOptions = buildOfflineStorageOptions(sdkOptions);
            var storageKey = this.options.storage.storagePath;

            this.persister = persisters.getPersister(storageKey, offlineStorageOptions);
        }
    },

    _getCacheData: function () {
        var self = this;

        if (!this.cacheData) {
            return this._persisterGetAllDataWrap()
                .then(function (cacheData) {
                    self.cacheData = cacheData;
                    return self.cacheData;
                });
        }

        return utils.successfulPromise(this.cacheData);
    },

    _persisterGetAllDataWrap: function () {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            return self.persister.getAllData(resolve, reject);
        });
    },

    _persisterSaveDataWrap: function (contentType, data) {
        var self = this;
        return new rsvp.Promise(function (resolve, reject) {
            return self.persister.saveData(contentType, JSON.stringify(data), resolve, reject);
        });
    },

    _getCacheDataForContentType: function (contentType) {
        return this._getCacheData()
            .then(function (cacheData) {
                if (typeof cacheData[contentType] === 'string') {
                    cacheData[contentType] = JSON.parse(cacheData[contentType]);
                } else {
                    cacheData[contentType] = cacheData[contentType] || {};
                }

                return _.clone(cacheData[contentType]);
            })
    },

    _persistCacheData: function (contentType, cacheData) {
        var self = this;

        return this._getCacheDataForContentType(contentType)
            .then(function () {
                var dataToCache = _.extend({}, self.cacheData[contentType], cacheData);
                self.cacheData[contentType] = _.compactObject(dataToCache);
                return self._persisterSaveDataWrap(contentType, self.cacheData[contentType]);
            });
    },

    isQueryUnsupportedOffline: function (dataQuery) {
        var hasPowerfieldsExpression = !!dataQuery.getHeader(constants.Headers.powerFields);
        var queryParams = dataQuery.getQueryParameters();
        var dataQueryFilter = queryParams.filter;
        var unsupportedDbOperators = utils.getUnsupportedOperators(dataQueryFilter);
        var hasUnsupportedOperators = unsupportedDbOperators.length !== 0;
        return hasPowerfieldsExpression || hasUnsupportedOperators;
    },

    _shouldSkipCache: function (dataQuery) {
        var operationShouldSkipCache = cacheableOperations.indexOf(dataQuery.operation) === -1;
        var collectionName = dataQuery.collectionName;
        var typeSettings = this.typeSettings;
        var cacheDisabledForContentType = typeSettings && typeSettings && typeSettings[collectionName] && typeSettings[collectionName].enabled === false;
        var ignoreCacheForQuery = dataQuery.ignoreCache;

        var isUnsupportedOffline = this.isQueryUnsupportedOffline(dataQuery);

        return operationShouldSkipCache || cacheDisabledForContentType || ignoreCacheForQuery || isUnsupportedOffline;
    },

    _cacheDataQuery: function (dataQuery) {
        if (this._shouldSkipCache(dataQuery)) {
            if (dataQuery.ignoreCache && !this.isQueryUnsupportedOffline(dataQuery)) {
                var hash = this._getHashForQuery(dataQuery);
                this._cacheQuery(dataQuery, hash);
            } else {
                this._everlive.data(dataQuery.collectionName)._sendRequest(dataQuery);
            }
        } else {
            dataQuery.useCache = false;
            this._processCacheItem(dataQuery);
        }
    },

    _processCacheItem: function (dataQuery) {
        var self = this;

        var contentType = dataQuery.collectionName;
        var hash = this._getHashForQuery(dataQuery);
        return this._getCacheDataForContentType(contentType)
            .then(function (cacheData) {
                if (cacheData[hash]) {
                    return self._isHashExpired(contentType, hash, dataQuery.maxAge)
                        .then(function (isExpired) {
                            if (isExpired && !dataQuery.forceCache) {
                                return self._purgeForHash(contentType, hash)
                                    .then(function () {
                                        return self._cacheQuery(dataQuery, hash);
                                    });
                            } else {
                                return self._everlive.offlineStorage.processQuery(dataQuery)
                                    .then(function (result) {
                                        dataQuery.onSuccess(result);
                                    })
                                    .catch(dataQuery.onError);
                            }
                        });
                } else {
                    return self._cacheQuery(dataQuery, hash);
                }
            });
    },

    _addObjectToCache: function (obj, contentType, maxAge) {
        var itemHash = obj.Id;
        return this._cacheResultFromDataQuery(contentType, itemHash, maxAge);
    },

    _cacheQuery: function (dataQuery, hash) {
        var self = this;
        var contentType = dataQuery.collectionName;

        var originalSuccess = dataQuery.onSuccess;
        dataQuery.onSuccess = function (response) {
            var args = arguments;

            return self._getCacheData()
                .then(function () {
                    var cacheForItems = [];
                    var result = response.result;

                    if (dataQuery.operation !== DataQuery.operations.count) {
                        if (Array.isArray(result)) {
                            _.each(result, function (singleResult) {
                                var cacheItemPromise = self._addObjectToCache(singleResult, dataQuery.collectionName);
                                cacheForItems.push(cacheItemPromise);
                            });
                        } else if (_.isObject(result)) {
                            var cacheItemPromise = self._addObjectToCache(result, dataQuery.collectionName);
                            cacheForItems.push(cacheItemPromise);
                        }
                    }

                    return rsvp.all(cacheForItems)
                        .then(function () {
                            if (dataQuery.operation !== DataQuery.operations.count) {
                                return self._cacheResultFromDataQuery(contentType, hash);
                            }
                        })
                        .then(function () {
                            return originalSuccess.apply(this, args);
                        });
                });
        };

        this._everlive.data(dataQuery.collectionName)._sendRequest(dataQuery);
    },

    _cacheResultFromDataQuery: function (contentType, hash) {
        var cacheData = {};
        cacheData[hash] = {
            cachedAt: Date.now()
        };

        return this._persistCacheData(contentType, cacheData);
    },

    _getExpirationForHash: function (contentType, hash) {
        return this._getCacheDataForContentType(contentType)
            .then(function (cacheData) {
                return cacheData[hash].cachedAt;
            });
    },

    _isHashExpired: function (contentType, hash, maxAge) {
        var self = this;

        return this._getExpirationForHash(contentType, hash)
            .then(function (cachedAt) {
                var maxAgeForContentType = self.typeSettings && self.typeSettings[contentType] ? self.typeSettings[contentType].maxAge * 60 * 1000 : null;
                var cacheAge = maxAge || maxAgeForContentType || self.maxAgeInMs;
                return (cachedAt + cacheAge) < Date.now();
            });
    },

    _purgeForHash: function (contentType, hash) {
        var cacheData = {};
        cacheData[hash] = null;

        return this._persistCacheData(contentType, cacheData);
    },

    _getHashForQuery: function (dataQuery) {
        if (dataQuery.operation === DataQuery.operations.readById) {
            return dataQuery.additionalOptions.id;
        }

        var queryParams = dataQuery.getQueryParameters();
        return this._hash(queryParams);
    },

    clear: function (contentType, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            return self.persister.purge(contentType, function () {
                delete self.cacheData[contentType];
                if (self._everlive.offlineStorage.setup.enabled) {
                    success();
                } else {
                    self._everlive.offlineStorage._queryProcessor._persister.purge(contentType, success, error);
                }
            }, error);
        }, success, error);
    },

    clearAll: function (success, error) {
        var self = this;
        self.cacheData = null;

        return buildPromise(function (success, error) {
            return self.persister.purgeAll(function () {
                if (self._everlive.offlineStorage.setup.enabled) {
                    success();
                } else {
                    self._everlive.offlineStorage._queryProcessor._persister.purgeAll(success, error);
                }
            }, error)
        }, success, error);
    }
};

module.exports = CacheModule;
},{"../EverliveError":42,"../common":53,"../constants":54,"../offline/offline":71,"../offline/offlinePersisters":72,"../query/DataQuery":80,"../query/Query":81,"../utils":94,"underscore":1}],52:[function(require,module,exports){
'use strict';

var CacheModule = require('./CacheModule');
var _ = require('../common')._;

var getDefaultOptions = function () {
    return {
        maxAge: 60,
        enabled: false,
        storage: {
            storagePath: 'el_cache'
        }
    }
};

module.exports = {
    initCaching: function (options) {
        var cachingOptions;
        var defaultOptions = getDefaultOptions();
        if (options.caching === true) {
            cachingOptions = _.deepExtend({}, defaultOptions);
            cachingOptions.enabled = true;
        } else {
            cachingOptions = _.deepExtend(defaultOptions, options.caching);
        }

        if (options.caching !== false) {
            this.setup.caching = cachingOptions;
        }

        this.cache = new CacheModule(cachingOptions, this);
    },
    _initStore: function (options) {
        this.cache._initStore(options);
    }
};
},{"../common":53,"./CacheModule":51}],53:[function(require,module,exports){
(function (global){
module.exports = (function () {
    var common = {};
    var dependencyStore = {};

    var platform = require('./everlive.platform');
    var isNativeScript = platform.isNativeScript;
    var isNodejs = platform.isNodejs;

    if (!isNodejs && !isNativeScript) {
        dependencyStore.reqwest = require('reqwest');
    } else if (isNativeScript) {
        common.root = global;
        dependencyStore.reqwest = require('./reqwest.nativescript');
    } else if (isNodejs) {
        common.root = global;
        dependencyStore.reqwest = require('./reqwest.nodejs');
    }

    if (!common.root) {
        //browser/requirejs/cordova
        common.root = window;
    }

    var exportDependency = function exportDependency(globalName, localName) {
        if (!localName) {
            localName = globalName;
        }

        //for the everlive bundle without dependencies included, browserify replaces them with empty objects
        //we need to make sure that these dependencies are marked as undefined
        if (dependencyStore[localName] &&
            typeof dependencyStore[localName] === 'object' && !Object.keys(dependencyStore[localName]).length) {

            dependencyStore[localName] = undefined;
        }

        Object.defineProperty(common, localName, {
            get: function () {
                return dependencyStore[localName] || this.root[globalName];
            }
        });
    };

    dependencyStore._ = require('underscore');
    exportDependency('_');

    dependencyStore.jstz = require('jstimezonedetect').jstz;
    exportDependency('jstz');

    dependencyStore.mongoQuery = require('mongo-query');
    exportDependency('mongoQuery');

    dependencyStore.Mingo = require('mingo');
    exportDependency('Mingo');

    dependencyStore.Processor = require('../scripts/bs-expand-processor');
    exportDependency('Processor');

    //dependencyStore.Base64 = require('Base64');
    //exportDependency('Base64');

    dependencyStore.rsvp = require('rsvp');
    exportDependency('RSVP', 'rsvp');

    exportDependency('reqwest');

    dependencyStore.jsonStringify = require('json-stable-stringify');
    exportDependency('json-stable-stringify', 'jsonStringify');

    return common;
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../scripts/bs-expand-processor":35,"./everlive.platform":56,"./reqwest.nativescript":85,"./reqwest.nodejs":86,"json-stable-stringify":8,"jstimezonedetect":1,"mingo":1,"mongo-query":13,"reqwest":1,"rsvp":1,"underscore":1}],54:[function(require,module,exports){
/**
 * Constants used by the SDK
 * @typedef {Object} Everlive.Constants
 */

var constants = {
    idField: 'Id',
    guidEmpty: '00000000-0000-0000-0000-000000000000',
    everliveUrl: '//api.everlive.com/v1/',
    /**
     * A class used to represent the conflict resolution strategies.
     * @property {string} ClientWins
     * @property {string} ServerWins
     * @property {string} Custom
     * @typedef {string} Everlive.Constants.ConflictResolutionStrategy
     */
    ConflictResolutionStrategy: {
        ClientWins: 'clientWins',
        ServerWins: 'serverWins',
        Custom: 'custom'
    },
    ConflictResolution: {
        KeepServer: 'keepServer',
        KeepClient: 'keepClient',
        Custom: 'custom',
        Skip: 'skip'
    },
    /**
     * A class used to represent the available storage providers.
     * @property {string} LocalStorage
     * @property {string} FileSystem
     * @property {string} Custom
     * @typedef {string} Everlive.Constants.StorageProvider
     */
    StorageProvider: {
        LocalStorage: 'localStorage',
        FileSystem: 'fileSystem',
        Custom: 'custom'
    },

    DefaultStoragePath: 'el_store',

    // the default location for storing files offline
    DefaultFilesStoragePath: 'el_file_store',

    // the default location for storing offline to online location map
    DefaultFilesMetadataPath: 'el_file_mapping',

    EncryptionProvider: {
        Default: 'default',
        Custom: 'custom'
    },

    // The headers used by the Everlive services
    Headers: {
        filter: 'X-Everlive-Filter',
        select: 'X-Everlive-Fields',
        sort: 'X-Everlive-Sort',
        skip: 'X-Everlive-Skip',
        take: 'X-Everlive-Take',
        expand: 'X-Everlive-Expand',
        singleField: 'X-Everlive-Single-Field',
        includeCount: 'X-Everlive-Include-Count',
        powerFields: 'X-Everlive-Power-Fields',
        debug: 'X-Everlive-Debug',
        overrideSystemFields: 'X-Everlive-Override-System-Fields',
        sdk: 'X-Everlive-Sdk',
        sync: 'X-Everlive-Sync'
    },
    //Constants for different platforms in Everlive
    Platform: {
        WindowsPhone: 1,
        Windows: 2,
        Android: 3,
        iOS: 4,
        OSX: 5,
        Blackberry: 6,
        Nokia: 7,
        Unknown: 100
    },
    OperatorType: {
        query: 1,

        where: 100,
        filter: 101,

        and: 110,
        or: 111,
        not: 112,

        equal: 120,
        not_equal: 121,
        lt: 122,
        lte: 123,
        gt: 124,
        gte: 125,
        isin: 126,
        notin: 127,
        all: 128,
        size: 129,
        regex: 130,
        contains: 131,
        startsWith: 132,
        endsWith: 133,

        nearShpere: 140,
        withinBox: 141,
        withinPolygon: 142,
        withinShpere: 143,

        select: 200,
        exclude: 201,

        order: 300,
        order_desc: 301,

        skip: 400,
        take: 401,
        expand: 402
    },

    /**
     * A class used to represent the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @property {string} unauthenticated Indicates that no user is authenticated.
     * @property {string} masterKey Indicates that a master key authentication is used.
     * @property {string} invalidAuthentication Indicates an authentication has been attempted, but it was invalid.
     * @property {string} authenticated Indicates that a user is authenticated.
     * @property {string} authenticating Indicates that a user is currently authenticating. Some requests might be pending and waiting for the user to authenticate.
     * @property {string} expiredAuthentication Indicates that a user's authentication has expired and that the user must log back in.
     * @typedef {string} Everlive.AuthStatus
     */
    AuthStatus: {
        unauthenticated: 'unauthenticated',
        masterKey: 'masterKey',
        invalidAuthentication: 'invalidAuthentication',
        authenticated: 'authenticated',
        expiredAuthentication: 'expiredAuthentication',
        authenticating: 'authenticating'
    },
    offlineItemStates: {
        created: 'create',
        modified: 'update',
        deleted: 'delete'
    },

    /**
     * HTTP Methods
     * @enum {string}
     */
    HttpMethod: {
        GET: 'GET',
        POST: 'POST',
        PUT: 'PUT',
        DELETE: 'DELETE'
    },
    maxDistanceConsts: {
        radians: '$maxDistance',
        km: '$maxDistanceInKilometers',
        miles: '$maxDistanceInMiles'
    },
    radiusConsts: {
        radians: 'radius',
        km: 'radiusInKilometers',
        miles: 'radiusInMiles'
    }
};

// using an invalid field name in the context of Everlive
// to ensure no naming collisions can occur
constants.offlineItemsStateMarker = '__everlive_offline_state';

constants.SyncErrors = {
    generalError: 'generalError',
    itemSyncError: 'itemSyncError'
};

constants.syncBatchSize = 10;

constants.AuthStoreKey = '__everlive_auth_key';

constants.CachingStoreKey = '__everlive_cache';

// the minimum interval between sync requests
constants.defaultSyncInterval = 1000 * 60 * 10; // 10 minutes
constants.fileUploadKey = 'fileUpload';
constants.fileUploadDelimiter = '_';

constants.FilesTypeNameLegacy = 'system.files';
constants.FilesTypeName = 'Files';

constants.MaxConcurrentDownloadTasks = 3;

module.exports = constants;

},{}],55:[function(require,module,exports){
var CryptoJS = require('node-cryptojs-aes').CryptoJS;
var AES = CryptoJS.AES;

module.exports = (function () {

    function CryptographicProvider(options) {
        this.options = options;
    }

    CryptographicProvider.prototype = {
        _getKey: function () {
            return this.options.encryption.key;
        },

        _canEncryptDecrypt: function (content) {
            return this._getKey() && content !== null && content !== undefined;
        },

        encrypt: function (content) {
            if (!this._canEncryptDecrypt(content)) {
                return content;
            }

            return AES.encrypt(content, this._getKey()).toString();
        },

        decrypt: function (content) {
            if (!this._canEncryptDecrypt(content)) {
                return content;
            }

            return AES.decrypt(content, this._getKey()).toString(CryptoJS.enc.Utf8);
        }
    };

    return CryptographicProvider;
}());
},{"node-cryptojs-aes":24}],56:[function(require,module,exports){
(function (global){
var isNativeScript = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
|| (typeof UIButton !== 'undefined' && UIButton)));

var platform;
var isCordova = false;
var isWindowsPhone = false;
var isAndroid = false;

if (isNativeScript) {
    global.window = {
        localStorage: {
            removeItem: function () {
            } //shim for mongo-query under nativescript
        }
    };

} else if (typeof window !== 'undefined') {
    isCordova = /^file:\/{3}[^\/]|x-wmapp/i.test(window.location.href) && /ios|iphone|ipod|ipad|android|iemobile/i.test(navigator.userAgent);
    isWindowsPhone = isCordova && /iemobile/i.test(navigator.userAgent);
    isAndroid = isCordova && cordova.platformId === 'android';
}

var isNodejs = typeof exports === 'object' && typeof window === 'undefined';
var isRequirejs = typeof define === 'function' && define.amd;
var isDesktop = !isNativeScript && !isCordova && !isNodejs;

if (isNativeScript) {
    platform = 'ns';
} else if (isNodejs) {
    platform = 'nodejs';
} else if (isDesktop) {
    platform = 'desktop';
} else if (isCordova) {
    platform = 'cordova';
}

module.exports = {
    isCordova: isCordova,
    isNativeScript: isNativeScript,
    isDesktop: isDesktop,
    isWindowsPhone: isWindowsPhone,
    isAndroid: isAndroid,
    isNodejs: isNodejs,
    isRequirejs: isRequirejs,
    platform: platform
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],57:[function(require,module,exports){
'use strict';

/**
 * @class Helpers
 * @classdesc Everlive helper classes
 */

var platform = require('../everlive.platform');

var helpers = [];

var htmlHelper = require('./html/htmlHelper');

if (platform.isCordova || platform.isDesktop) {
    helpers.push({
        name: 'html',
        ctor: htmlHelper
    });
}

module.exports = helpers;
},{"../everlive.platform":56,"./html/htmlHelper":58}],58:[function(require,module,exports){
'use strict';

var platform = require('../../everlive.platform');
var common = require('../../common');
var _ = common._;
var utils = require('../../utils');
var rsvp = common.rsvp;
var HtmlHelperResponsiveModule = require('./htmlHelperResponsiveModule');
var HtmlHelperOfflineModule = require('./htmlHelperOfflineModule');
var constants = require('../../constants');
var EverliveError = require('../../EverliveError').EverliveError;
var EventEmitterProxy = require('../../EventEmitterProxy');

module.exports = (function () {
    var defaults = {
        processOnLoad: false,
        processOnResize: false,
        loadingImageUrl: '',
        errorImageUrl: '',
        attributes: {
            loadingImage: 'data-loading-image',
            errorImage: 'data-error-image',
            dpi: 'data-dpi',
            imageSource: 'data-src',
            fileSource: 'data-href',
            enableOffline: 'data-offline',
            enableResponsive: 'data-responsive'
        }
    };

    /**
     * @typedef Helpers.html
     * @description Everlive helper for html related operations, such as processing html elements with specific tags.
     */

    function HtmlHelper(everlive, config) {
        EventEmitterProxy.apply(this);

        this._everlive = everlive;
        this._settings = {
            urlTemplate: '[protocol][hostname][apikey]/[operations][url]',
            server: 'bs1.cdn.telerik.com/image/v1/'
        };

        config = config || {};

        this.options = _.extend({}, defaults, config);
        this.options.attributes = _.extend({}, defaults.attributes, config.attributes);

        this._responsive = new HtmlHelperResponsiveModule(this);
        this._offline = new HtmlHelperOfflineModule(this);

        this._init();
    }

    HtmlHelper.prototype = {
        _init: function _init() {
            var self = this;
            if (self.options.processOnLoad) {
                window.addEventListener('load', this.processAll.bind(this), false);
            }

            if (this.options.processOnResize) {
                window.addEventListener('resize', _.debounce(this.processAll.bind(this), 300), false);
            }
        },

        _triggerOnProcessed: function _triggerOnProcessed(args) {
            this._emitter.emit('processed', args);
        },

        _defaultProcessSettings: function _defaultProcessSettings(settings) {
            return _.defaults({}, settings, {
                responsive: true,
                offline: true
            });
        },

        _setLoadingUrl: function _setLoadingUrl(element) {
            var loadingImageUri = element.getAttribute(this.options.attributes.loadingImage) || this.options.loadingImageUrl;
            if (!loadingImageUri || utils.isElement.anchor(element)) {
                return utils.successfulPromise();
            }

            return this._setUrl(element, loadingImageUri, true);
        },

        _getBackgroundSrc: function _getBackgroundSrc(el) {
            var elStyle = window.getComputedStyle(el, null);
            var backgrImage = elStyle.getPropertyValue('background-image');

            var img = backgrImage !== 'none' ? backgrImage : false;
            if (img) {
                img = img.replace(/url\(('?"?)(.*?)\1\)/gi, '$2');
            }

            return img;
        },

        _setErrorUrl: function (element) {
            var errorImageUrl = element.getAttribute(this.options.attributes.errorImage) || this.options.errorImageUrl;
            if (!errorImageUrl || utils.isElement.anchor(element)) {
                return utils.successfulPromise();
            }

            return this._setUrl(element, errorImageUrl, true);
        },

        _setUrl: function _setUrl(element, url, apply) {
            var self = this;
            return new rsvp.Promise(function (resolve, reject) {
                var elAttr = self._getAttr(element);
                if (utils.isElement.image(element) && elAttr === self.options.attributes.imageSource) {
                    if (apply) {
                        element.src = url;
                        element.style.visibility = 'visible';
                    } else {
                        var img = new Image();

                        img.onerror = function () {
                            img = null;
                            reject(new EverliveError('Can\'t be loaded: ' + url));
                        };

                        img.onload = function () {
                            img = null;
                            self._setUrl(element, url, true)
                                .then(resolve)
                                .catch(reject);
                        };

                        img.src = url;
                    }
                } else {
                    apply = true;
                    if (elAttr) {
                        var attr;
                        if (elAttr === self.options.attributes.imageSource) {
                            attr = 'src';
                        } else if (elAttr === self.options.attributes.fileSource) {
                            attr = 'href';
                        } else {
                            attr = _.last(elAttr.split('-'));
                        }

                        element.setAttribute(attr, url);
                    } else {
                        element.style.backgroundImage = 'url(' + url + ')';
                    }
                }

                if (apply) {
                    resolve();
                }
            });
        },

        _getAttr: function _getAttr(element) {
            if (element.getAttribute(this.options.attributes.imageSource)) {
                return this.options.attributes.imageSource;
            }

            if (element.getAttribute(this.options.attributes.fileSource)) {
                return this.options.attributes.fileSource;
            }
        },

        _getUrl: function _getUrl(element) {
            var url = element.getAttribute(this.options.attributes.imageSource)
                || element.getAttribute(this.options.attributes.fileSource)
                || this._getBackgroundSrc(element);

            return url;
        },

        _wrapElements: function _wrapElements(elements) {
            var self = this;

            var results = _.map(elements, function (element) {
                var tag = element.tagName.toLowerCase();

                var evaluateDataAttr = function evaluateDataAttr(attr) {
                    // data-a - true
                    // data-a="" - true
                    // data-a="true" - true
                    // data-a="anything" - true
                    // data-a="false" - false
                    // missing - false
                    var val;
                    var dataVal = (element.attributes[attr] || {value: null}).value;
                    if (dataVal === '') {
                        val = true;
                    } else if (!dataVal) {
                        val = false;
                    } else {
                        try {
                            val = JSON.parse(dataVal);
                        } catch (e) {
                            val = true;
                        }
                    }

                    return val;
                };

                var canResponsive = evaluateDataAttr(self.options.attributes.enableResponsive);
                var canOffline = evaluateDataAttr(self.options.attributes.enableOffline);

                return {
                    item: element,
                    tag: tag,
                    operations: {
                        responsive: canResponsive,
                        offline: canOffline
                    }
                };
            });

            return results;
        },

        /**
         * @method process
         * @memberOf Helpers.html
         * @param {HtmlElement|HtmlElement[]} elements
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */

        /**
         * @method process
         * @memberOf Helpers.html
         * @param {HtmlElement|HtmlElement[]} elements
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @returns {Promise} A promise to the process state.
         */
        process: function process(elements, settings, success, error) {
            var self = this;

            return utils.buildPromise(function (resolve) {
                settings = self._defaultProcessSettings(settings);
                if (_.isArray(elements) || elements instanceof NodeList || elements.length) {
                    elements = _.flatten(elements);
                } else {
                    elements = [elements];
                }

                var wrappedElements = self._wrapElements(elements);
                var promises = [];
                _.each(wrappedElements, function (element) {
                    var result = {
                        element: element.item,
                        responsive: false,
                        offline: false
                    };

                    var dataUrl = self._getUrl(result.element);

                    if (!dataUrl) {
                        return promises.push(utils.successfulPromise(result));
                    }

                    var canResponsive = settings.responsive ? element.operations.responsive : false;
                    var canOffline = settings.offline ? element.operations.offline : false;

                    if (!canResponsive && !canOffline) {
                        return promises.push(self._setUrl(result.element, dataUrl, true)
                            .then(function () {
                                return result;
                            }));
                    }

                    var promise = self._setLoadingUrl(result.element);
                    var handleOperation = function handleOperation(operation, url) {
                        if (url) {
                            result[operation] = true;
                            return url;
                        }
                    };

                    if (canResponsive) {
                        promise = promise.then(function () {
                            return self._responsive.responsiveImage(element, dataUrl)
                                .then(handleOperation.bind(this, 'responsive'));
                        });
                    }

                    if (canOffline) {
                        promise = promise.then(function (responsiveSrc) {
                            return self._offline.processOffline(responsiveSrc || dataUrl)
                                .then(handleOperation.bind(this, 'offline'));
                        });
                    }

                    promise = promise.then(function (finalUrl) {
                        return self._setUrl(result.element, finalUrl)
                            .then(function () {
                                return result;
                            });
                    }).catch(function (err) {
                        return self._setErrorUrl(result.element)
                            .then(function () {
                                throw {
                                    element: result.element,
                                    error: err
                                }
                            });
                    });

                    promises.push(promise);
                });

                rsvp.allSettled(promises)
                    .then(function (results) {
                        var processed = [];
                        var failed = [];

                        _.each(results, function (result) {
                            if (result.state === 'fulfilled') {
                                processed.push(result.value);
                            } else {
                                failed.push(result.reason);
                            }
                        });

                        var result = {
                            processed: processed,
                            failed: failed
                        };

                        self._triggerOnProcessed(result);
                        resolve(result);
                    });
            }, success, error);
        },

        /**
         * @method processAll
         * @memberOf Helpers.html
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */

        /**
         * @method processAll
         * @memberOf Helpers.html
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @returns {Promise} A promise to the process state.
         */
        processAll: function processAll(settings, success, error) {
            settings = this._defaultProcessSettings(settings);
            var responsiveSelector = '[' + this.options.attributes.enableResponsive + ']';
            var offlineSelector = '[' + this.options.attributes.enableOffline + ']';

            var responsiveElements = [];
            if (settings.responsive) {
                responsiveElements = document.querySelectorAll(responsiveSelector);
            }

            var offlineElements = [];
            if (settings.offline) {
                offlineElements = document.querySelectorAll(offlineSelector);
            }

            var slice = [].slice;
            var elements = _.unique(slice.call(responsiveElements).concat(slice.call(offlineElements)));


            return this.process(elements, settings, success, error);
        }
    };

    return HtmlHelper;
}());

},{"../../EventEmitterProxy":40,"../../EverliveError":42,"../../common":53,"../../constants":54,"../../everlive.platform":56,"../../utils":94,"./htmlHelperOfflineModule":59,"./htmlHelperResponsiveModule":60}],59:[function(require,module,exports){
'use strict';

var utils = require('../../utils');
var EverliveErrorModule = require('../../EverliveError');
var EverliveErrors = EverliveErrorModule.EverliveErrors;
var EverliveError = EverliveErrorModule.EverliveError;
var constants = require('../../constants');
var path = require('path');
var common = require('../../common');
var _ = common._;

module.exports = (function () {
    function HtmlHelperOfflineModule(htmlHelper) {
        this.htmlHelper = htmlHelper;
    }

    HtmlHelperOfflineModule.prototype = {
        processOffline: function (url) {
            var self = this;

            if (!self.htmlHelper._everlive.offlineStorage.files) {
                return utils.rejectedPromise(new EverliveError('Offline storage must be enabled in order to use the offline features of the images component.'));
            }

            return self.htmlHelper._everlive.offlineStorage.files.downloadOffline(url)
                .then(function (localUrl) {
                    return localUrl;
                })
                .catch(function (err) {
                    if (err.code !== EverliveErrors.cannotDownloadOffline.code) {
                        throw err;
                    }

                    return self.htmlHelper._everlive.offlineStorage._offlineFilesProcessor
                        .getOfflineFilesData()
                        .then(function (offlineFilesData) {
                            var basename = path.basename(url);
                            var oldFile = _.find(offlineFilesData, function (entry) {
                                if (entry.onlineLocation && entry.offlineLocation) {
                                    var onlineLocation = entry.onlineLocation;
                                    var basenameIndex = onlineLocation.lastIndexOf(basename);
                                    return basenameIndex !== -1;
                                }
                            });

                            if (oldFile) {
                                return oldFile.offlineLocation;
                            }

                            throw new EverliveError('Cannot find offline image ' + url, EverliveErrors.missingOrInvalidFileContent.code);
                        });
                });
        }
    };

    return HtmlHelperOfflineModule;
}());
},{"../../EverliveError":42,"../../common":53,"../../constants":54,"../../utils":94,"path":4}],60:[function(require,module,exports){
'use strict';

var common = require('../../common');
var _ = common._;
var rsvp = common.rsvp;
var EverliveError = require('../../EverliveError').EverliveError;
var constants = require('../../constants');
var utils = require('../../utils');

module.exports = (function () {
    function HtmlHelperResponsiveModule(htmlHelper) {
        this.htmlHelper = htmlHelper;
    }

    HtmlHelperResponsiveModule.prototype = {
        getBackgroundWidth: function getBackgroundWidth(el) {
            return Math.ceil(el.offsetWidth);
        },

        parseParamsString: function parseParamsString(str) {
            if (!str || typeof str === 'undefined' || str.length <= 1) {
                return false;
            }

            var isUserResize = false;
            var params = [];
            var tmp = str.split('/');
            var ii = tmp.length;

            for (var i = 0; i < ii; i++) {
                var item = tmp[i].split('='),
                    tmpObj = {};
                if (typeof item[1] === 'undefined') {
                    item[1] = false;
                } else {
                    item[1] = unescape(item[1].replace(/\+/g, ' '));
                }

                tmpObj[item[0]] = item[1];
                params.push(tmpObj);
                if (item[0] === 'resize') {
                    isUserResize = true;
                }
            }
            return {
                params: params,
                isUserResize: isUserResize
            };
        },

        getImgParams: function getImgParams(src) {
            var operations;
            var imgUrl = src.replace(/.*?resize=[^//]*\//gi, '');
            var protocolRe = new RegExp('https?://', 'gi');
            var serverRe = new RegExp(this.htmlHelper._settings.server, 'gi');
            var apiKeyRe = new RegExp(this.htmlHelper._everlive.apiKey + '/', 'gi');

            operations = src.replace(imgUrl, '').replace(protocolRe, '').replace(serverRe, '').replace(apiKeyRe, '').toLowerCase();
            if (operations !== '') {
                operations = operations.indexOf('/') ? operations.substring(0, operations.length - 1) : operations;
            } else {
                operations = false;
            }

            operations = this.parseParamsString(operations);
            // If it's a user resize operation, use the passed url in the data-src property
            if (operations.isUserResize) {
                imgUrl = src;
            }

            return {
                imgUrl: imgUrl,
                operations: operations.params,
                isUserResize: operations.isUserResize
            };
        },

        hasClass: function hasClass(el, cl) {
            var regex = new RegExp('(?:\\s|^)' + cl + '(?:\\s|$)');
            return !!el.className.match(regex);
        },

        getImageWidth: function getImageWidth(el) {
            var parentEl = el.parentNode;
            var parentWidth = parentEl.offsetWidth;
            var itemStyle = window.getComputedStyle(parentEl, null);
            var pl = parseFloat(itemStyle.getPropertyValue('padding-left'));
            var pr = parseFloat(itemStyle.getPropertyValue('padding-right'));
            var bl = parseFloat(itemStyle.getPropertyValue('border-left-width'));
            var br = parseFloat(itemStyle.getPropertyValue('border-right-width'));

            return Math.abs(parentWidth - Math.ceil(pl + pr + bl + br));
        },

        getDevicePixelRatio: function getDevicePixelRatio() {
            return window.devicePixelRatio ? window.devicePixelRatio : 1;
        },

        getPixelRatio:function getPixelRatio(el) {
            var pixelDensity = el.getAttribute(this.htmlHelper.options.attributes.dpi) || '';
            return pixelDensity !== '' ? _.isNumber(pixelDensity) ? parseFloat(pixelDensity) : false : this.getDevicePixelRatio();
        },

        getImgParamsString: function getImgParamsString(image, params) {
            var paramsStr = '';
            var i = 0;
            var ii = params.length;
            for (; i < ii; i++) {
                var item = params[i];
                var key = _.keys(item)[0];
                var value;

                if (!utils.isElement.image(image) && key === 'resize') {
                    continue;
                }

                var pixelDensity = this.getPixelRatio(image.item);
                pixelDensity = (pixelDensity) ? ',pd:' + pixelDensity : '';
                for (var k in item) {
                    value = (key === 'resize') ? item[k] + pixelDensity : item[k];
                }

                paramsStr += key + '=' + value + '/';
            }

            return paramsStr;
        },

        responsiveImage: function responsiveImage(item, dataSrc) {
            var self = this;
            var image = _.extend({}, item);
            var element = image.item;
            var tag = image.tag;

            var isImage = utils.isElement.image(tag);
            var imgWidth;

            image = _.extend({}, image, self.getImgParams(dataSrc));

            if (!image.isUserResize) {
                imgWidth = (!isImage) ? self.getBackgroundWidth(element) : self.getImageWidth(element);
            }

            imgWidth = imgWidth ? imgWidth : false;
            var src = image.isUserResize ? image.imgUrl : self.getImgSrc(image, imgWidth);

            return new rsvp.Promise(function (resolve) {
                if (!imgWidth && !image.isUserResize) { // we don't have the width of the user image either.
                    // if this element is not visible, we don't have to process it.

                    return resolve();
                }

                return resolve(src);
            });
        },

        getImgSrc: function getImgSrc(image, imgWidth) {
            var protocol = this.htmlHelper._everlive.setup.scheme + '://';
            var apiKey = this.htmlHelper._everlive.setup.apiKey;
            var server = this.htmlHelper._settings.server;
            var url = this.htmlHelper._settings.urlTemplate;
            var pixelDensity = this.getPixelRatio(image.item);

            pixelDensity = pixelDensity ? ',pd:' + pixelDensity : '';

            url = url.replace('[protocol]', protocol);
            url = url.replace('[apikey]', apiKey ? apiKey : '');
            url = url.replace('[hostname]', server);

            var params = image.operations || false;
            if (params) {
                var operations = '';
                params = this.getImgParamsString(image, params);
                if (utils.isElement.image(image.tag)) {
                    operations = imgWidth ? 'resize=w:' + imgWidth + pixelDensity + '/' + params : params;
                } else {
                    operations = 'resize=w:' + imgWidth + pixelDensity + '/' + params;
                }
                url = url.replace('[operations]', operations);
            } else {
                url = url.replace('[operations]', 'resize=w:' + imgWidth + pixelDensity + '/');
            }

            url = url.replace('[url]', image.imgUrl);
            return url;
        }
    };

    return HtmlHelperResponsiveModule;
}());
},{"../../EverliveError":42,"../../common":53,"../../constants":54,"../../utils":94}],61:[function(require,module,exports){
/*!
 The MIT License (MIT)
 Copyright (c) 2013 Telerik AD
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.y distributed under the MIT license.
 */
/*!
 Everlive SDK
 Version 1.5.1
 */
(function () {
    var Everlive = require('./Everlive');
    var platform = require('./everlive.platform');
    var common = require('./common');

    if (!platform.isNativeScript && !platform.isNodejs) {
        var kendo = require('./kendo/kendo.everlive');
        Everlive.createDataSource = kendo.createDataSource;
        Everlive.createHierarchicalDataSource = kendo.createHierarchicalDataSource;
    }

    //Global event handlers for push notification events. Required by the cordova PushNotifications plugin that we use.
    Everlive.PushCallbacks = {};
    Everlive.Offline = {};

    Everlive.Query = require('./query/Query');
    Everlive.QueryBuilder = require('./query/QueryBuilder');
    Everlive.GeoPoint = require('./GeoPoint');
    Everlive.Constants = require('./constants');
    Everlive.Request = require('./Request');
    Everlive.Data = require('./types/Data');
    Everlive._utils = require('./utils');
    Everlive._traverseAndRevive = Everlive._utils.parseUtilities.traverseAndRevive;
    Everlive._common = require('./common');

    var persistersModule = require('./offline/offlinePersisters');
    Everlive.persister = {
        LocalStorage: persistersModule.LocalStoragePersister,
        FileSystem: persistersModule.FileSystemPersister
    };

    //everliveModule is provided by a closure generated during build
    if (platform.isNodejs || platform.isNativeScript) {
        if (typeof everliveModule !== 'undefined') {
            everliveModule.exports = Everlive;
        }

        if (typeof module !== 'undefined') {
            module.exports = Everlive;
        }
    } else {
        //in requirejs Everlive is defined in the same closure
        //browser
        common.root.Everlive = Everlive;
    }
}());
},{"./Everlive":41,"./GeoPoint":45,"./Request":47,"./common":53,"./constants":54,"./everlive.platform":56,"./kendo/kendo.everlive":62,"./offline/offlinePersisters":72,"./query/Query":81,"./query/QueryBuilder":82,"./types/Data":91,"./utils":94}],62:[function(require,module,exports){
var QueryBuilder = require('../query/QueryBuilder');
var Query = require('../query/Query');
var Request = require('../Request');
var constants = require('../constants');
var _ = require('../common')._;
var Everlive = require('../Everlive');
var EverliveError = require('../EverliveError').EverliveError;

(function () {
    'use strict';

    if (typeof window !== 'undefined' && typeof window.jQuery === 'undefined' || typeof window.kendo === 'undefined' || _.isEmpty(window.kendo.data)) {
        return;
    }

    var $ = window.jQuery;
    var kendo = window.kendo;

    var extend = $.extend;

    var everliveTransport = kendo.data.RemoteTransport.extend({
        init: function (options) {
            this.everlive$ = options.dataProvider || Everlive.$;
            if (!this.everlive$) {
                throw new Error('An instance of the Backend services sdk must be provided.');
            }

            if (!options.typeName) {
                throw new Error('A type name must be provided.');
            }

            this.headers = options.headers;

            this.dataCollection = this.everlive$.data(options.typeName);
            kendo.data.RemoteTransport.fn.init.call(this, options);
        },

        read: function (options) {
            var methodOption = this.options['read'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var query = translateKendoQuery(options.data);
            var everliveQuery = new Query(query.$where, null, query.$sort, query.$skip, query.$take);
            var id = options.data.Id;

            if (id) {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).getById(id).then(options.success, options.error).catch(options.error);
            } else {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).get(everliveQuery).then(options.success, options.error).catch(options.error);
            }
        },

        update: function (options) {
            var methodOption = this.options['update'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch update is not supported.');
            } else {
                var itemForUpdate = options.data;
                return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).updateSingle(itemForUpdate)
                    .then(options.success.bind(this, itemForUpdate), options.error).catch(options.error);
            }
        },

        create: function (options) {
            var methodOption = this.options['create'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            var createData = isMultiple ? options.data.models : options.data;

            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).create(createData)
                .then(options.success.bind(this, createData), options.error).catch(options.error);
        },

        destroy: function (options) {
            var methodOption = this.options['destroy'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch destroy is not supported.');
            }
            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).destroy(options.data)
                .then(options.success, options.error).catch(options.error);
        }
    });

    $.extend(true, kendo.data, {
        transports: {
            everlive: everliveTransport
        },
        schemas: {
            everlive: {
                type: 'json',
                total: function (data) {
                    return data.hasOwnProperty('count') ? data.count : data.Count;
                },
                data: function (data) {
                    return data.result || Everlive._traverseAndRevive(data.Result) || data;
                },
                model: {
                    id: constants.idField
                }
            }
        }
    });

    function translateKendoQuery(data) {
        var result = {};
        if (data) {
            if (data.skip) {
                result.$skip = data.skip;
                delete data.skip;
            }
            if (data.take) {
                result.$take = data.take;
                delete data.take;
            }
            if (data.sort) {
                var sortExpressions = data.sort;
                var sort = {};
                if (!$.isArray(sortExpressions)) {
                    sortExpressions = [sortExpressions];
                }
                $.each(sortExpressions, function (idx, value) {
                    sort[value.field] = value.dir === 'asc' ? 1 : -1;
                });
                result.$sort = sort;
                delete data.sort;
            }
            if (data.filter) {
                var filter = filterBuilder.build(data.filter);
                result.$where = filter;
                delete data.filter;
            }
        }
        return result;
    }

    var regexOperations = ['startswith', 'startsWith', 'endswith', 'endsWith', 'contains'];

    var filterBuilder = {
        build: function (filter) {
            return filterBuilder._build(filter);
        },
        _build: function (filter) {
            if (filterBuilder._isRaw(filter)) {
                return filterBuilder._raw(filter);
            }
            else if (filterBuilder._isSimple(filter)) {
                return filterBuilder._simple(filter);
            }
            else if (filterBuilder._isRegex(filter)) {
                return filterBuilder._regex(filter);
            }
            else if (filterBuilder._isAnd(filter)) {
                return filterBuilder._and(filter);
            }
            else if (filterBuilder._isOr(filter)) {
                return filterBuilder._or(filter);
            }
        },
        _isRaw: function (filter) {
            return filter.operator === '_raw';
        },
        _raw: function (filter) {
            var fieldTerm = {};
            fieldTerm[filter.field] = filter.value;
            return fieldTerm;
        },
        _isSimple: function (filter) {
            return typeof filter.logic === 'undefined' && !filterBuilder._isRegex(filter);
        },
        _simple: function (filter) {
            var term = {}, fieldTerm = {};
            var operator = filterBuilder._translateoperator(filter.operator);
            if (operator) {
                term[operator] = filter.value;
            }
            else {
                term = filter.value;
            }
            fieldTerm[filter.field] = term;
            return fieldTerm;
        },
        _isRegex: function (filter) {
            return $.inArray(filter.operator, regexOperations) !== -1;
        },
        _regex: function (filter) {
            var fieldTerm = {};
            var regex = filterBuilder._getRegex(filter);
            fieldTerm[filter.field] = filterBuilder._getRegexValue(regex);
            return fieldTerm;
        },
        _getRegex: function (filter) {
            var pattern = filter.value;
            var filterOperator = filter.operator;
            switch (filterOperator) {
                case 'contains':
                    return new RegExp(".*" + pattern + ".*", "i");
                case 'startsWith': // removing the camel case operators will be a breaking change
                case 'startswith': // the Kendo UI operators are in lower case
                    return new RegExp("^" + pattern, "i");
                case 'endsWith':
                case 'endswith':
                    return new RegExp(pattern + "$", "i");
            }
            throw new Error("Unknown operator type.");
        },
        _getRegexValue: function (regex) {
            return QueryBuilder.prototype._getRegexValue.call(this, regex);
        },
        _isAnd: function (filter) {
            return filter.logic === 'and';
        },
        _and: function (filter) {
            var i, l, term, result = {};
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result = filterBuilder._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            return QueryBuilder.prototype._andAppend.call(this, andObj, newObj);
        },
        _isOr: function (filter) {
            return filter.logic === 'or';
        },
        _or: function (filter) {
            var i, l, term, result = [];
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case 'eq':
                    return null;
                case 'neq':
                    return "$ne";
                case 'gt':
                    return "$gt";
                case 'lt':
                    return "$lt";
                case 'gte':
                    return "$gte";
                case 'lte':
                    return "$lte";
            }
            throw new Error("Unknown operator type.");
        }
    };

    /**
     * Creates a new Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) that manages a certain Backend Services content type.
     * Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) is used in conjunction with other Kendo UI widgets (such as [ListView](http://docs.telerik.com/kendo-ui/web/listview/overview) and [Grid](http://docs.telerik.com/kendo-ui/web/grid/overview)) to provide an easy way to render data from Backend Services.
     * *including Kendo UI scripts is required*.
     * @param options data source options. See the Kendo UI documentation for [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more information.
     * @param options.transport.typeName The content type name in Backend Services that will be managed.
     * @returns {DataSource} A new instance of Kendo UI DataSource. See the Kendo UI documentation for [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more information.
     * @example ```js
     * var booksDataSource = Everlive.createDataSource({
     *   transport: {
     *     typeName: 'Books'
     *   }
     * });
     * ```
     */
    var createDataSource = function (options) {
        options = options || {};
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        if (!everlive$) {
            throw new Error("You need to instantiate an Everlive instance in order to create a Kendo UI DataSource.");
        }

        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI DataSource.");
        }

        return everlive$.getKendoDataSource(typeName, options);
    };

    /**
     * Creates a new Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) that manages a certain Backend Services content type and can expand a chain of relations.
     * Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) is used in conjunction with other Kendo UI widgets (such as [TreeView](http://docs.telerik.com/kendo-ui/web/treeview/overview)) to render data from Backend Services in a structured way.
     * The chain of relations is defined by specifying the field names that contain the relation on each level. For example a generic hierarchy chain is a content type 'Continents' with relation to 'Countries', which in turn contains a relation to 'Towns'.
     * *including Kendo UI scripts is required*.
     * @param options data source Options for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
     * @param options.typeName Name of the main content type for the data source.
     * @param {ExpandDefinition[]} options.expand An array of expand definitions. It defines the levels of hierarchy by specifying the relation fields. An expand definition can either be the field name as a **string**, or an **object** that allows additional options.
     * @param {string} ExpandDefinition - The field name of the relation that will be expanded. Only supported in online mode.
     * @param {string} ExpandDefinition.relation - *Required*. The field name of the relation that will be expanded.
     * @param {string} ExpandDefinition.typeName - *Required in offline mode*. The type name of the relation that will be expanded.
     * @param {object} ExpandDefinition.filter - An object specifying the filter expression.
     * @param {object} ExpandDefinition.sort - An object specifying the sort expression.
     * @param {object} ExpandDefinition.skip - A number specifying the skip value.
     * @param {object} ExpandDefinition.take - A number specifying the take value.
     * @param {object} ExpandDefinition.fields - An object specifying the fields expression.
     * @returns {HierarchicalDataSource} A new instance of Kendo UI HierarchicalDataSource. See the Kendo UI documentation for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
     * @example ```js
     * var el = new Everlive('your-api-key-here');
     * var continents = Everlive.createHierarchicalDataSource({
     *   "typeName": "Continents",
     *   "expand": ["Countries", "Towns"]
     * });
     *
     * ...
     * ("#treeview").kendoTreeView({
     *   dataSource: continents,
     *   dataTextField: ["ContinentName", "CountryName", "TownName"]
     * });
     * ```
     */
    var createHierarchicalDataSource = function (options) {
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        if (!everlive$) {
            throw new Error("You need to instantiate an Everlive instance in order to create a Kendo UI DataSource.");
        }
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI DataSource.");
        }
        return everlive$.getHierarchicalDataSource(typeName, options);

    };

    /**
     * Get a Kendo UI DataSource that is attached to the current instance of the SDK with default options.
     * @method getKendoDataSource
     * @memberOf Everlive.prototype
     * @param {String} typeName The corresponding type name for the DataSource.
     * @param {Object} [datasourceOptions] Additional DataSource options.
     * @returns {DataSource}
     */
    Everlive.prototype.getKendoDataSource = function (typeName, datasourceOptions) {
        datasourceOptions = _.extend({}, datasourceOptions);
        if (datasourceOptions.hasOwnProperty('serverGrouping') && datasourceOptions.serverGrouping === true) {
            throw new EverliveError('Server Grouping is not supported.');
        }

        var defaultEverliveOptions = {
            type: 'everlive',
            transport: {
                typeName: typeName,
                dataProvider: this
            }
        };

        var options = _.defaults(defaultEverliveOptions, datasourceOptions);
        return new kendo.data.DataSource(options);
    };


    var getUrlGeneratorForNode = function (baseUrl, expandArray) {
        var expandField = getRelationFieldForExpandNode(expandArray[expandArray.length - 1]);
        var pathArray = expandArray.slice(0, expandArray.length - 1);
        var pathUrl = '/_expand';
        for (var i = 0; i < pathArray.length; i++) {
            pathUrl += '/' + getRelationFieldForExpandNode(pathArray[i]);
        }
        return (function (pathUrl, expandField) {
            return function (options) {
                var url = baseUrl + '';
                if (options.Id && expandField) {//if we are expanding
                    url += pathUrl + '/' + options.Id + '/' + expandField;
                }
                return url;
            }
        }(pathUrl, expandField));
    };

    var getHeadersForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            return {};
        } else {
            return {
                'X-Everlive-Filter': JSON.stringify(expandNode.filter),
                'X-Everlive-Sort': JSON.stringify(expandNode.sort),
                'X-Everlive-Single-Field': expandNode.singleField,
                'X-Everlive-Skip': expandNode.skip,
                'X-Everlive-Take': expandNode.take,
                'X-Everlive-Fields': JSON.stringify(expandNode.fields)
            }
        }
    };

    var getRelationFieldForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            return expandNode;
        } else {
            if (expandNode.relation) {
                return expandNode.relation;
            } else {
                throw new Error("You need to specify a 'relation' for an expand node when using the object notation");
            }
        }
    };

    /**
     * Get a Kendo UI HierarchicalDataSource that is attached to the current instance of the SDK with default options.
     * @method getHierarchicalDataSource
     * @memberOf Everlive.prototype
     * @param {String} typeName The corresponding type name for the DataSource.
     * @param {Object} dataSourceOptions Additional DataSource options that describe the hierarchical structure.
     * @returns {HierarchicalDataSource}
     */
    Everlive.prototype.getHierarchicalDataSource = function (typeName, dataSourceOptions) {
        dataSourceOptions = dataSourceOptions || {};
        if (dataSourceOptions.hasOwnProperty('serverGrouping') && dataSourceOptions.serverGrouping === true) {
            throw new EverliveError('Server Grouping is not supported.');
        }
        var expand = dataSourceOptions.expand || dataSourceOptions;
        delete dataSourceOptions.expand;
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI HierarchicalDataSource.");
        }
        if (!$.isArray(expand)) {
            throw new Error("You need to set 'expand' array option in order to create a Kendo UI HierarchicalDataSource");
        }
        var baseUrl = this.buildUrl() + typeName;

        var expandSchema;
        var isOfflineStorageEnabled = this._isOfflineStorageEnabled();
        for (var i = expand.length - 1; i >= 0; i--) { //recursively build the hierarchical data source
            var expandNode = expand[i];
            if (isOfflineStorageEnabled) {
                if (!$.isPlainObject(expandNode)) {
                    throw new Error("When offline is enabled, each member of the expand array option must be an object. (Expand node index: " + i + ")");
                }
                if (!expandNode.relation) {
                    throw new Error("When offline is enabled, each member of the expand array option must have a `relation` option set.  (Expand node index: " + i + ")");
                }
                if (!expandNode.typeName) {
                    throw new Error("When offline is enabled, each member of the expand array option must have a `typeName` option set.  (Expand node index: " + i + ")");
                }

                var headers;
                var expandExpression = {};
                expandExpression[expandNode.relation] = {
                    TargetTypeName: expandNode.typeName,
                    Filter: expandNode.filter,
                    Sort: expandNode.sort,
                    Take: expandNode.take,
                    Skip: expandNode.skip,
                    Fields: expandNode.fields,
                    SingleField: expandNode.singleField
                };
                headers = {
                    'X-Everlive-Expand': JSON.stringify(expandExpression),
                    'X-Everlive-Single-Field': expandNode.relation
                };
                var parentType;
                if (i === 0) {
                    parentType = typeName;
                } else {
                    parentType = expand[i - 1].typeName;
                }
                expandSchema = {
                    model: {
                        hasChildren: expandNode.relation,
                        children: {
                            type: "everlive",
                            transport: {
                                typeName: parentType,
                                read: {
                                    headers: headers
                                }
                            },
                            schema: expandSchema
                        }
                    }
                };
            } else {
                expandSchema = {
                    model: {
                        hasChildren: getRelationFieldForExpandNode(expandNode),
                        children: {
                            type: "everlive",
                            transport: {
                                read: {
                                    url: getUrlGeneratorForNode(baseUrl, expand.slice(0, i + 1)),
                                    headers: getHeadersForExpandNode(expandNode)
                                }
                            },
                            schema: expandSchema
                        }
                    }
                }
            }
        }
        var options = {};
        options.type = 'everlive';
        options.transport = {
            typeName: typeName,
            dataProvider: this
        };
        options.schema = expandSchema;
        if ($.isPlainObject(dataSourceOptions)) {
            extend(true, options, dataSourceOptions);
        }
        return new kendo.data.HierarchicalDataSource(options);
    };


    module.exports = {
        createDataSource: createDataSource,
        createHierarchicalDataSource: createHierarchicalDataSource
    };
}());
},{"../Everlive":41,"../EverliveError":42,"../Request":47,"../common":53,"../constants":54,"../query/Query":81,"../query/QueryBuilder":82}],63:[function(require,module,exports){
var _ = require('../common')._;

var deepExtend = require('./underscoreDeepExtends');
var compactObject = require('./underscoreCompactObject');
var isObjectEmpty = require('./underscoreIsObjectEmpty');

_.mixin({'deepExtend': deepExtend});
_.mixin({'compactObject': compactObject});
_.mixin({'isEmptyObject': isObjectEmpty});
},{"../common":53,"./underscoreCompactObject":64,"./underscoreDeepExtends":65,"./underscoreIsObjectEmpty":66}],64:[function(require,module,exports){
var _ = require('underscore');

//http://stackoverflow.com/questions/14058193/remove-empty-properties-falsy-values-from-object-with-underscore-js
module.exports = function compactObject(o) {
    var newObject = {};
    _.each(o, function(v, k) {
        if(v !== null && v !== undefined) {
            newObject[k] = v
        }
    });

    return newObject;
};

},{"underscore":1}],65:[function(require,module,exports){
/*  Copyright (C) 2012-2014  Kurt Milam - http://xioup.com | Source: https://gist.github.com/1868955
 *   
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **/

// Based conceptually on the _.extend() function in underscore.js ( see http://documentcloud.github.com/underscore/#extend for more details )

var _ = require('../common')._;

module.exports = function deepExtend(obj) {
    var parentRE = /#{\s*?_\s*?}/,
        slice = Array.prototype.slice;

    _.each(slice.call(arguments, 1), function (source) {
        for (var prop in source) {
            if (_.isUndefined(obj[prop]) || _.isFunction(obj[prop]) || _.isNull(source[prop]) || _.isDate(source[prop])) {
                obj[prop] = source[prop];
            }
            else if (_.isString(source[prop]) && parentRE.test(source[prop])) {
                if (_.isString(obj[prop])) {
                    obj[prop] = source[prop].replace(parentRE, obj[prop]);
                }
            }
            else if (_.isArray(obj[prop]) || _.isArray(source[prop])) {
                if (!_.isArray(obj[prop]) || !_.isArray(source[prop])) {
                    throw new Error('Trying to combine an array with a non-array (' + prop + ')');
                } else {
                    obj[prop] = _.reject(_.deepExtend(_.clone(obj[prop]), source[prop]), function (item) {
                        return _.isNull(item);
                    });
                }
            }
            else if (_.isObject(obj[prop]) || _.isObject(source[prop])) {
                if (!_.isObject(obj[prop]) || !_.isObject(source[prop])) {
                    throw new Error('Trying to combine an object with a non-object (' + prop + ')');
                } else {
                    obj[prop] = _.deepExtend(_.clone(obj[prop]), source[prop]);
                }
            } else {
                obj[prop] = source[prop];
            }
        }
    });
    return obj;
};

/**
 * Dependency: underscore.js ( http://documentcloud.github.com/underscore/ )
 *
 * Mix it in with underscore.js:
 * _.mixin({deepExtend: deepExtend});
 *
 * Call it like this:
 * var myObj = _.deepExtend(grandparent, child, grandchild, greatgrandchild)
 *
 * Notes:
 * Keep it DRY.
 * This function is especially useful if you're working with JSON config documents. It allows you to create a default
 * config document with the most common settings, then override those settings for specific cases. It accepts any
 * number of objects as arguments, giving you fine-grained control over your config document hierarchy.
 *
 * Special Features and Considerations:
 * - parentRE allows you to concatenate strings. example:
 *   var obj = _.deepExtend({url: "www.example.com"}, {url: "http://#{_}/path/to/file.html"});
 *   console.log(obj.url);
 *   output: "http://www.example.com/path/to/file.html"
 *
 * - parentRE also acts as a placeholder, which can be useful when you need to change one value in an array, while
 *   leaving the others untouched. example:
 *   var arr = _.deepExtend([100,    {id: 1234}, true,  "foo",  [250, 500]],
 *                          ["#{_}", "#{_}",     false, "#{_}", "#{_}"]);
 *   console.log(arr);
 *   output: [100, {id: 1234}, false, "foo", [250, 500]]
 *
 * - The previous example can also be written like this:
 *   var arr = _.deepExtend([100,    {id:1234},   true,  "foo",  [250, 500]],
 *                          ["#{_}", {},          false, "#{_}", []]);
 *   console.log(arr);
 *   output: [100, {id: 1234}, false, "foo", [250, 500]]
 *
 * - And also like this:
 *   var arr = _.deepExtend([100,    {id:1234},   true,  "foo",  [250, 500]],
 *                          ["#{_}", {},          false]);
 *   console.log(arr);
 *   output: [100, {id: 1234}, false, "foo", [250, 500]]
 *
 * - Array order is important. example:
 *   var arr = _.deepExtend([1, 2, 3, 4], [1, 4, 3, 2]);
 *   console.log(arr);
 *   output: [1, 4, 3, 2]
 *
 * - You can remove an array element set in a parent object by setting the same index value to null in a child object.
 *   example:
 *   var obj = _.deepExtend({arr: [1, 2, 3, 4]}, {arr: ["#{_}", null]});
 *   console.log(obj.arr);
 *   output: [1, 3, 4]
 *
 **/
},{"../common":53}],66:[function(require,module,exports){
// http://stackoverflow.com/questions/4994201/is-object-empty
'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

function isEmpty(obj) {

    // null and undefined are "empty"
    if (obj == null) return true;

    // Assume if it has a length property with a non-zero value
    // that that property is correct.
    if (obj.length > 0)    return false;
    if (obj.length === 0)  return true;

    // Otherwise, does it have any properties of its own?
    // Note that this doesn't handle
    // toString and valueOf enumeration bugs in IE < 9
    for (var key in obj) {
        if (hasOwnProperty.call(obj, key)) return false;
    }

    return true;
}

module.exports = isEmpty;
},{}],67:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var buildPromise = utils.buildPromise;
var Request = require('../Request');
var common = require('../common');
var rsvp = common.rsvp;
var _ = common._;
var reqwest = common.reqwest;
var uuid = common.uuid;
var path = require('path');
var CryptoJS = require('node-cryptojs-aes').CryptoJS;
var errors = require('../EverliveError');
var EverliveErrors = errors.EverliveErrors;
var EverliveError = errors.EverliveError;
var AutoQueue = require('../AutoQueue');

var OfflineFilesModule = function (offlineFilesProcessor, everlive, downloadsConcurrency) {
    this._offlineFilesProcessor = offlineFilesProcessor;
    this._everlive = everlive;
    this._downloadsQueue = new AutoQueue(downloadsConcurrency);
};

/**
 * @class OfflineFilesModule
 * @classdesc A class that provides the means to operate with files in offline mode.
 * @protected
 */
OfflineFilesModule.prototype = {
    _getFilenameMetadata: function (location, offlineFileInfo) {
        return new rsvp.Promise(function (resolve, reject) {
            reqwest({
                url: location,
                method: 'HEAD',
                async: true,
                crossDomain: true
            }).then(function (xmlResponse) {
                var contentDispositionHeader = xmlResponse.getResponseHeader('Content-Disposition');
                if (contentDispositionHeader) {
                    var matches = /filename="?([^"\\]*(?:\\.[^"\\]*)*)"?/i.exec(contentDispositionHeader);
                    if (_.isArray(matches)) {
                        offlineFileInfo.filename = matches[1];
                    }
                } else {
                    offlineFileInfo.filename = path.basename(xmlResponse.responseURL);
                }

                resolve(xmlResponse.responseURL);
            }).catch(reject);
        });
    },

    /**
     * Updates a file's content.
     * @memberof OfflineFilesModule.prototype
     * @method downloadOffline
     * @param {string} location A file location or the id of a file stored in Backend Services.
     * @param {boolean} overwrite Boolean option that indicates whether the file should be overwritten if it already exists offline.
     * @returns {Promise} The promise for the request
     */
    /**
     * Updates a file's content.
     * @memberof OfflineFilesModule.prototype
     * @method downloadOffline
     * @param {string} location A file location or the id of a file stored in Backend Services.
     * @param {boolean} overwrite Boolean option that indicates whether the file should be overwritten if it already exists offline.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    downloadOffline: function (location, overwrite, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            self._downloadsQueue.enqueue(function (cb) {
                var offlineFileInfo;
                return self._getOfflineFileInfo(location)
                    .then(function (_offlineFileInfo) {
                        offlineFileInfo = _offlineFileInfo;
                        if (overwrite) {
                            return false;
                        }

                        return self.existsOffline(location);
                    })
                    .then(function (exists) {
                        if (!exists) {
                            if (self._everlive.isOnline()) {
                                return utils.successfulPromise()
                                    .then(function () {
                                        if (!offlineFileInfo.filename) {
                                            return self._getFilenameMetadata(location, offlineFileInfo);
                                        }
                                    })
                                    .then(function (locationAfterRedirect) {
                                        var location = locationAfterRedirect || offlineFileInfo.location;
                                        return self._saveFile(location, offlineFileInfo.filename, null, offlineFileInfo.location);
                                    });
                            }

                            error(new EverliveError(EverliveErrors.cannotDownloadOffline));
                        } else {
                            return self._getOfflineFileInfo(location)
                                .then(function (fileInfo) {
                                    return self._getOfflineLocation(fileInfo);
                                });
                        }
                    })
                    .then(function (result) {
                        cb(null, result);
                    })
                    .catch(cb);
            }, success, error);
        }, success, error);
    },

    _saveFile: function (location, filename, id, cacheKey) {
        var self = this;
        var actualLocation;

        return self._downloadFile(location, filename)
            .then(function (_actualLocation) {
                actualLocation = _actualLocation;
                return self._offlineFilesProcessor.getOfflineFilesData();
            })
            .then(function (offlineFilesData) {
                offlineFilesData.push({
                    offlineLocation: actualLocation,
                    onlineLocation: cacheKey || location,
                    id: id
                });

                return self._offlineFilesProcessor.saveOfflineFilesData();
            })
            .then(function () {
                return actualLocation;
            });
    },

    /**
     * Physically deletes the offline copies of all files.
     * @memberof OfflineFilesModule.prototype
     * @method purgeAll
     * @returns {Promise} The promise for the request.
     */
    /**
     * Physically deletes the offline copies of all files.
     * @memberof OfflineFilesModule.prototype
     * @method purgeAll
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    purgeAll: function (success, error) {
        var self = this;

        return utils.buildPromise(function (success, error) {
            self._offlineFilesProcessor.fileStore.removeFilesDirectory()
                .then(function () {
                    return self._offlineFilesProcessor.filesMetaStore.removeFilesDirectory();
                })
                .then(function () {
                    self._offlineFilesProcessor._offlineFilesData = null;
                })
                .then(success)
                .catch(error);
        }, success, error);
    },

    _getOfflineLocation: function (fileInfo) {
        var self = this;
        var url = fileInfo.location;
        var filename = fileInfo.filename;
        var id = fileInfo.Id;

        return self._offlineFilesProcessor.getOfflineLocation(url, id)
            .then(function (offlineUrl) {
                if (offlineUrl) {
                    return offlineUrl;
                }

                // if no url is provided this means that the file exists only offline
                // the Uri field has not been populated by the server
                if (id && !url) {
                    return self._getFileUrlForId(id, filename);
                }

                return null;
            });
    },

    _downloadFile: function (url, name) {
        var self = this;

        // TODO: [offline] this will not work in NativeScript at the moment
        return new rsvp.Promise(function (resolve, reject) {
            var fileTransfer = new FileTransfer();
            var sanitizedUrl = self._sanitizeUrl(url);
            var fileId = path.basename(sanitizedUrl);
            var extension = path.extname(name);
            var filename = fileId;
            if (path.extname(sanitizedUrl) !== extension) {
                filename += extension;
            }

            var fileParentDirectory = '';
            if (!utils.isGuid(url)) {
                var fileIdIndex = url.lastIndexOf(fileId);
                var baseUrl = url.substr(0, fileIdIndex);
                fileParentDirectory = CryptoJS.MD5(baseUrl).toString();
            }

            return self._offlineFilesProcessor.fileStore.getDataDirectory()
                .then(function (dataDir) {
                    return utils.joinPath(dataDir.nativeURL, self._offlineFilesProcessor.fileStore.filesDirectoryPath,
                        fileParentDirectory, filename);
                })
                .then(function (location) {
                    fileTransfer.download(url, location, function () {
                        resolve(location);
                    }, reject, true, {
                        headers: self._everlive.buildAuthHeader()
                    });
                })
                .catch(reject);
        });
    },

    _sanitizeUrl: function (url) {
        if (!url) {
            return url;
        }

        var sanitizedUrl = encodeURI(url);
        var questionMarkIndex = sanitizedUrl.lastIndexOf('?');
        if (questionMarkIndex !== -1) {
            sanitizedUrl = sanitizedUrl.substr(0, questionMarkIndex); //linux does not allow question marks in its filenames
        }

        return sanitizedUrl;
    },

    _getFileUrlForId: function (fileId, filename) {
        var self = this;

        return this._offlineFilesProcessor.fileStore.getDataDirectory()
            .then(function (dataDirectory) {
                var fileExtension = path.extname(filename);
                return utils.joinPath(dataDirectory.nativeURL, self._offlineFilesProcessor.fileStore.filesDirectoryPath, fileId + fileExtension);
            });
    },

    /**
     * Checks if a file exists offline.
     * @memberof OfflineFilesModule.prototype
     * @method exists
     * @param {String} location The location or file id to check.
     * @returns {Promise} The promise for the request
     */
    /**
     * Checks if a file exists offline.
     * @memberof OfflineFilesModule.prototype
     * @method exists
     * @param {String} location The location or file id to check.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    existsOffline: function (location, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            self._getOfflineFileInfo(location)
                .then(function (fileInfo) {
                    return self._getOfflineLocation(fileInfo);
                })
                .then(function (offlineUrl) {
                    if (offlineUrl) {
                        return self._offlineFilesProcessor.fileStore.getFileByAbsolutePath(offlineUrl);
                    }
                })
                .then(function (offlineFile) {
                    return !!offlineFile;
                })
                .then(success)
                .catch(function (err) {
                    if (err.code === EverliveErrors.itemNotFound.code) {
                        return success(false);
                    }

                    return error.apply(this, arguments);
                });
        }, success, error);
    },


    /**
     * Physically deletes the offline copy of a file.
     * @memberof OfflineFilesModule.prototype
     * @method purge
     * @param {String} location The location or file id to remove.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Physically deletes the offline copy of a file.
     * @memberof OfflineFilesModule.prototype
     * @method purge
     * @param {String} location The location or file id to check.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    purge: function (location, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            self._getOfflineFileInfo(location)
                .then(function (fileInfo) {
                    return self._getOfflineLocation(fileInfo);
                })
                .then(function (location) {
                    if (location) {
                        return self._offlineFilesProcessor.purge(location);
                    }
                })
                .then(success)
                .catch(error);
        }, success, error);
    },

    /**
     * Gets the native URL for a file that is stored offline.
     * @memberof OfflineFilesModule.prototype
     * @method getOfflineLocation
     * @param {String} location The location or file id to process.
     * @returns {Promise} The promise for the request
     */
    /**
     * Gets the native URL for a file that is stored offline.
     * @memberof OfflineFilesModule.prototype
     * @method getOfflineLocation
     * @param {String} location The location or file id to process.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    getOfflineLocation: function (location, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            self._getOfflineFileInfo(location)
                .then(self._getOfflineLocation.bind(self))
                .then(function (offlineLocation) {
                    if (offlineLocation) {
                        return self.existsOffline(offlineLocation)
                            .then(function (exists) {
                                if (exists) {
                                    return offlineLocation;
                                }

                                return null;
                            });
                    }

                    return null;
                })
                .then(success)
                .catch(error);
        }, success, error);
    },

    _getOfflineFileInfo: function (location) {
        var self = this;
        var sanitizedUrl = this._sanitizeUrl(location);

        return new rsvp.Promise(function (resolve, reject) {
            self._everlive.Files
                .isSync(true)
                .useOffline(true)
                .getById(sanitizedUrl)
                .then(function (response) {
                    var file = response.result;
                    resolve({
                        location: file.Uri,
                        filename: file.Filename,
                        Id: sanitizedUrl
                    });
                })
                .catch(function (err) {
                    if (err && err.code === EverliveErrors.itemNotFound.code) {
                        resolve({
                            location: location
                        });
                    } else {
                        reject(err);
                    }
                });
        });
    },

    changeFileExtensionById: function (id, extension) {
        var self = this;

        if (typeof extension !== 'string') {
            return new rsvp.Promise(function (resolve) {
                resolve();
            });
        }

        return self._changeExtension(id, extension);
    },

    _changeExtension: function (id, newExtension) {
        var self = this;

        var dataDir;

        var fileStore = self._offlineFilesProcessor.fileStore;
        var fileName = id + newExtension;
        return fileStore.getFilesDirectory()
            .then(function (directoryEntry) {
                dataDir = directoryEntry;
                return self.getOfflineLocation(id);
            })
            .then(function (localPath) {

                var existingFileName = path.basename(localPath);
                if (existingFileName !== fileName) {
                    return fileStore.getFileByAbsolutePath(localPath)
                        .then(function (fileEntry) {
                            return fileStore.renameFile(dataDir, fileEntry, fileName);
                        })
                        .then(function () {
                            return self._offlineFilesProcessor.getOfflineFilesData();
                        })
                        .then(function (offlineFilesData) {
                            var mappedEntry = _.findWhere(offlineFilesData, {offlineLocation: localPath});
                            if (!mappedEntry) {
                                throw new EverliveError('Could not find a cached location for the specified file.');
                            }

                            var previousLocation = mappedEntry.offlineLocation;
                            var previousExtension = path.extname(previousLocation);
                            var actualLocation = previousLocation.slice(0, previousLocation.length - previousExtension.length) + newExtension;
                            mappedEntry.offlineLocation = actualLocation;

                            return self._offlineFilesProcessor.saveOfflineFilesData();
                        });
                }
            });
    }
};

module.exports = OfflineFilesModule;
},{"../AutoQueue":39,"../EverliveError":42,"../Request":47,"../common":53,"../utils":94,"node-cryptojs-aes":24,"path":4}],68:[function(require,module,exports){
'use strict';

var EverliveErrorModule = require('../EverliveError');
var EverliveError = EverliveErrorModule.EverliveError;
var EverliveErrors = EverliveErrorModule.EverliveErrors;
var FileStore = require('../storages/FileStore');
var platform = require('../everlive.platform');
var constants = require('../constants');
var common = require('../common');
var rsvp = common.rsvp;
var utils = require('../utils');
var _ = common._;
var path = require('path');

var FILES_METADATA_FILE_NAME = 'filesMetadataMap';

var OfflineFilesProcessor = function (setup, everlive) {
    this.fileStore = new FileStore(setup.files.storagePath, setup);
    this.filesMetaStore = new FileStore(setup.files.metaPath, setup);
    this._everlive = everlive;
};

OfflineFilesProcessor.prototype = {
    validateFileCreateObject: function (obj, isSync) {
        return new rsvp.Promise(function (resolve, reject) {
            if (!obj.base64 && !isSync) {
                return reject(new EverliveError(EverliveErrors.missingOrInvalidFileContent));
            } else if (!obj.ContentType) {
                return reject(new EverliveError(EverliveErrors.missingContentType));
            } else if (!obj.Filename) {
                //TODO: [offline] add an appropriate error
                return reject(new EverliveError(EverliveErrors.invalidRequest));
            }

            resolve();
        });
    },

    getOfflineFilesData: function () {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            if (!self._offlineFilesData) {
                return self.filesMetaStore.getFile(FILES_METADATA_FILE_NAME)
                    .then(function (metadataFileHandle) {
                        return self.filesMetaStore.readFileAsText(metadataFileHandle);
                    })
                    .then(function (metadataText) {
                        if (!metadataText) {
                            metadataText = '[]';
                        }

                        self._offlineFilesData = JSON.parse(metadataText);
                        resolve(self._offlineFilesData);
                    }).catch(reject);
            } else {
                resolve(self._offlineFilesData);
            }
        });
    },

    saveOfflineFilesData: function () {
        var self = this;

        return self.getOfflineFilesData()
            .then(function (offlineFilesData) {
                return self.filesMetaStore.writeText(FILES_METADATA_FILE_NAME, JSON.stringify(offlineFilesData));
            });
    },

    upsertFileFromObject: function (obj, isCreate, isSync) {
        var self = this;

        if (!isSync) {
            if (isCreate) {
                if (!obj.base64) {
                    return utils.rejectedPromise(new EverliveError(EverliveErrors.missingOrInvalidFileContent));
                }

                if (!obj.ContentType) {
                    return utils.rejectedPromise(new EverliveError(EverliveErrors.missingContentType));
                }
            } else {
                if (!obj.base64) {
                    return utils.successfulPromise();
                }
            }
        }

        if (!obj.base64) {
            var id = utils.getId(obj);
            var uri;
            var downloadFilePromise = obj.Uri ? utils.successfulPromise(obj.Uri) :
                self._everlive.files
                    .isSync(isSync)
                    .applyOffline(false)
                    .getDownloadUrlById(id);

            return downloadFilePromise.then(function (_uri) {
                uri = _uri;
                return self._everlive.offlineStorage.files.existsOffline(id);
            }).then(function (exists) {
                if (!exists) {
                    return self._everlive.offlineStorage.files._saveFile(uri, obj.Filename);
                }
            });
        }

        obj.Storage = 'internal';
        return utils.successfulPromise().then(function () {
            if (!isSync) {
                return self.validateFileCreateObject(obj, isSync);
            }
        }).then(function () {
            var onlineLocation = obj.Uri;
            var filename = self.getFilenameForObject(obj);

            var offlineFileInfo;
            var base64Contents = obj.base64;
            delete obj.base64;

            var contents = utils.b64toBlob(base64Contents, obj.ContentType);

            return self.writeFile(filename, contents)
                .then(function (fileInfo) {
                    offlineFileInfo = fileInfo;
                    return self.getOfflineFilesData();
                })
                .then(function (offlineFilesData) {
                    offlineFilesData.push({
                        offlineLocation: offlineFileInfo.offlineLocation,
                        onlineLocation: onlineLocation,
                        id: obj._id
                    });

                    obj.Length = offlineFileInfo.size;
                    return self.saveOfflineFilesData();
                });
        });
    },

    purge: function (localLocation) {
        var self = this;

        return this.getOfflineFilesData()
            .then(function (offlineFilesData) {
                var offlineFile = _.where(offlineFilesData, {offlineLocation: localLocation});

                // TODO: [offline] check if the length of offlineFile === 0
                var offlineInfoIndex = offlineFilesData.indexOf(offlineFile[0]);
                if (offlineInfoIndex !== -1) {
                    offlineFilesData.splice(offlineInfoIndex, 1);
                }

                return self.saveOfflineFilesData();
            })
            .then(function () {
                return self.fileStore.getFileByAbsolutePath(localLocation);
            }).then(function (file) {
                if (file) {
                    return self.fileStore.removeFile(file);
                }
            });
    },

    writeFile: function (filename, contents, folder) {
        var self = this;
        var offlineLocation;

        return self.fileStore.writeText(filename, contents, folder)
            .then(function (locationOnDisk) {
                offlineLocation = locationOnDisk;
                return self.saveOfflineFilesData();
            })
            .then(function () {
                return self.fileStore.getFileSize(filename, folder);
            })
            .then(function (size) {
                return {
                    size: size,
                    offlineLocation: offlineLocation
                };
            });
    },

    getFilenameForObject: function (obj) {
        var extension = path.extname(obj.Filename);
        return obj._id + extension;
    },

    getOfflineLocation: function (url, id) {
        return this.getOfflineFilesData()
            .then(function (offlineFilesData) {
                if (!url && !id) {
                    return;
                }

                for (var i = 0; i < offlineFilesData.length; i++) {
                    var fileEntry = offlineFilesData[i];
                    var urlMatches = (url && (fileEntry.offlineLocation === url || fileEntry.onlineLocation === url));
                    var idMatches = (id && fileEntry.id === id);
                    if (urlMatches || idMatches) {
                        return fileEntry.offlineLocation;
                    }
                }
            });
    }
};

module.exports = OfflineFilesProcessor;
},{"../EverliveError":42,"../common":53,"../constants":54,"../everlive.platform":56,"../storages/FileStore":87,"../utils":94,"path":4}],69:[function(require,module,exports){
'use strict';

var DataQuery = require('../query/DataQuery');
var utils = require('../utils');
var offlineTransformations = require('./offlineTransformations');
var expandProcessor = require('../ExpandProcessor');

var everliveErrorModule = require('../EverliveError');
var EverliveError = everliveErrorModule.EverliveError;
var EverliveErrors = everliveErrorModule.EverliveErrors;

var buildPromise = require('../utils').buildPromise;
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var mingo = common.Mingo;
var mongoQuery = common.mongoQuery;
var Query = require('../query/Query');

var path = require('path');

var constants = require('../constants');
var Headers = constants.Headers;
var offlineItemStates = constants.offlineItemStates;

var unsupportedOfflineHeaders = [Headers.powerFields];

var unsupportedUsersOperations = {};
unsupportedUsersOperations[DataQuery.operations.create] = true;
unsupportedUsersOperations[DataQuery.operations.update] = true;
unsupportedUsersOperations[DataQuery.operations.remove] = true;
unsupportedUsersOperations[DataQuery.operations.removeSingle] = true;
unsupportedUsersOperations[DataQuery.operations.rawUpdate] = true;
unsupportedUsersOperations[DataQuery.operations.setAcl] = true;
unsupportedUsersOperations[DataQuery.operations.setOwner] = true;
unsupportedUsersOperations[DataQuery.operations.userLoginWithProvider] = true;
unsupportedUsersOperations[DataQuery.operations.userLinkWithProvider] = true;
unsupportedUsersOperations[DataQuery.operations.userUnlinkFromProvider] = true;
unsupportedUsersOperations[DataQuery.operations.userLogin] = true;
unsupportedUsersOperations[DataQuery.operations.userLogout] = true;
unsupportedUsersOperations[DataQuery.operations.userChangePassword] = true;
unsupportedUsersOperations[DataQuery.operations.userResetPassword] = true;

function buildUsersErrorMessage(dataQuery) {
    var unsupportedUserSocialProviderOperations = [
        DataQuery.operations.userLoginWithProvider,
        DataQuery.operations.userLinkWithProvider,
        DataQuery.operations.userUnlinkFromProvider
    ];

    var operation = dataQuery.operation;
    if (unsupportedUserSocialProviderOperations.indexOf(operation) !== -1) {
        operation += dataQuery.data.Provider || dataQuery.data.Identity.Provider;
    }

    return 'The Users operation ' + operation + ' is not supported in offline mode';
}

function buildFilesErrorMessage(dataQuery) {
    return 'The Files operation ' + dataQuery.operation + ' is not supported in offline mode';
}

function OfflineQueryProcessor(persister, encryptionProvider, offlineFilesProcessor, everlive, setup) {
    this._collectionCache = {};
    this.offlineFilesProcessor = offlineFilesProcessor;
    this._persister = persister;
    this._encryptionProvider = encryptionProvider;
    this.everlive = everlive;
    this.setup = setup;
}

OfflineQueryProcessor.prototype = {
    processQuery: function (dataQuery) {
        var unsupportedClientOpMessage = this.getUnsupportedClientOpMessage(dataQuery);
        if (unsupportedClientOpMessage && !dataQuery.isSync) {
            return new rsvp.Promise(function (resolve, reject) {
                reject(new EverliveError(unsupportedClientOpMessage));
            });
        }

        var queryParams = dataQuery.getQueryParameters();
        var unsupportedOperators = utils.getUnsupportedOperators(queryParams.filter);
        var unsupportedOperatorCount = unsupportedOperators.length;
        if (unsupportedOperatorCount) {
            return new rsvp.Promise(function (resolve, reject) {
                var errorMessage;
                if (unsupportedOperatorCount === 1) {
                    errorMessage = 'The operator ' + unsupportedOperators[0] + ' is not supported in offline mode.';
                } else {
                    errorMessage = 'The operators ' + unsupportedOperators.join(',') + 'are not supported in offline mode.';
                }

                reject(new EverliveError(errorMessage, EverliveErrors.operationNotSupportedOffline.code));
            });
        }

        offlineTransformations.traverseAndTransformFilterId(queryParams.filter);

        switch (dataQuery.operation) {
            case DataQuery.operations.read:
                return this.read(dataQuery, queryParams.filter, queryParams.sort, queryParams.skip, queryParams.limit, queryParams.select, queryParams.expand);
            case DataQuery.operations.readById:
                return this.readById(dataQuery, queryParams.expand);
            case DataQuery.operations.filesGetDownloadUrlById:
                return this.getDownloadUrlById(dataQuery);
            case DataQuery.operations.count:
                return this.count(dataQuery, queryParams.filter);
            case DataQuery.operations.create:
                return this.create(dataQuery);
            case DataQuery.operations.rawUpdate:
            case DataQuery.operations.update:
                return this.update(dataQuery, queryParams.filter);
            case DataQuery.operations.filesUpdateContent:
                return this.updateFileContent(dataQuery, queryParams.filter);
            case DataQuery.operations.remove:
                return this.remove(dataQuery, queryParams.filter);
            case DataQuery.operations.removeSingle:
                queryParams.filter._id = dataQuery.additionalOptions.id;
                return this.remove(dataQuery, queryParams.filter);
            default:
                return new rsvp.Promise(function (resolve, reject) {
                    if (dataQuery.isSync) {
                        resolve();
                    } else {
                        reject(new EverliveError(dataQuery.operation + ' is not supported in offline mode'));
                    }
                });
        }
    },

    getDownloadUrlById: function (dataQuery) {
        var self = this;
        var id = dataQuery.additionalOptions.id;
        var offlineFilePath;

        return self.everlive
            .files
            .useOffline(true)
            .isSync(dataQuery.isSync)
            .getById(id)
            .then(function (res) {
                var file = res.result;
                return self.everlive.offlineStorage.files._getFileUrlForId(file.Id, file.Filename);
            })
            .then(function (filePath) {
                offlineFilePath = filePath;
                return self.everlive.offlineStorage._offlineFilesProcessor.fileStore.getFileByAbsolutePath(filePath);
            })
            .then(function (fileEntry) {
                if (fileEntry) {
                    return {
                        result: {
                            Uri: offlineFilePath
                        }
                    }
                }

                return {
                    result: {}
                }
            });
    },

    getUnsupportedClientOpMessage: function (dataQuery) {
        for (var i = 0; i < unsupportedOfflineHeaders.length; i++) {
            var header = unsupportedOfflineHeaders[i];
            if (dataQuery.getHeader(header)) {
                return 'The header ' + header + ' is not supported in offline mode';
            }
        }

        if (utils.isContentType.users(dataQuery.collectionName) && unsupportedUsersOperations[dataQuery.operation]) {
            return buildUsersErrorMessage(dataQuery);
        }

        var isSingle = dataQuery.additionalOptions && dataQuery.additionalOptions.id;
        var isUpdateByFilter = dataQuery.operation === DataQuery.operations.update && !isSingle;
        var isRawUpdate = dataQuery.operation === DataQuery.operations.rawUpdate;
        if (utils.isContentType.files(dataQuery.collectionName) && (isRawUpdate || isUpdateByFilter)) {
            return buildFilesErrorMessage(dataQuery);
        }
    },

    _getCreateResult: function (createdItems, returnFullItem) {
        if (createdItems.length === 1) {
            var result;
            if (returnFullItem) {
                var item = _.extend({}, createdItems[0]);
                result = offlineTransformations.idTransform(item);
            } else {
                result = {
                    CreatedAt: utils.cloneDate(createdItems[0].CreatedAt),
                    Id: createdItems[0]._id
                }
            }

            return {
                result: result
            };
        } else {
            var multipleCreateResult = [];
            _.each(createdItems, function (createdItem) {
                var item;
                if (returnFullItem) {
                    var itemCopy = _.extend({}, createdItem);
                    item = offlineTransformations.idTransform(itemCopy);
                } else {
                    item = {
                        CreatedAt: utils.cloneDate(createdItem.CreatedAt),
                        Id: createdItem._id
                    };
                }
                multipleCreateResult.push(item);
            });

            return {
                result: multipleCreateResult
            };
        }
    },

    create: function (dataQuery) {
        var self = this;

        return self._createItems(dataQuery.collectionName, dataQuery.data, dataQuery.isSync, dataQuery.preserveState)
            .then(function (createdItems) {
                var isFilesQuery = utils.isContentType.files(dataQuery.collectionName);
                return self._getCreateResult(createdItems, isFilesQuery);
            });
    },

    read: function (dataQuery, filter, sort, skip, limit, select, expand) {
        var self = this;
        var expandResult;

        return new rsvp.Promise(function (resolve, reject) {
            var collectionLength;

            self._prepareExpand(expand, dataQuery, true)
                .then(function (prepareExpandResult) {
                    expandResult = prepareExpandResult;
                    if (prepareExpandResult) {
                        select = prepareExpandResult.mainQueryFieldsExpression;
                    }

                    return self._getCollection(dataQuery.collectionName);
                })
                .then(function (collection) {
                    var result = self._readInternal(collection, filter, sort, skip, limit, select);

                    if (skip || limit) {
                        var all = self._readInternal(collection);
                        collectionLength = all.length;
                    }

                    if (!self._shouldAutogenerateIdForContentType(dataQuery.collectionName)) {
                        result = offlineTransformations.removeIdTransform(result, true);
                    } else {
                        result = offlineTransformations.idTransform(result);
                    }

                    return self._expandResult(expandResult, result);
                })
                .then(function (result) {
                    var response = self._transformOfflineResult(result, collectionLength, dataQuery);
                    resolve(response);
                })
                .catch(reject);
        });
    },

    _readInternal: function (collection, filter, sort, skip, limit, select) {
        var filterCopy = _.extend({}, filter);
        var actualFilter = this._getWithoutDeletedFilter(filterCopy);
        offlineTransformations.traverseAndTransformFilterId(actualFilter);
        var query = mingo.Query(actualFilter);
        var cursor = mingo.Cursor(collection, query, select);
        if (sort) {
            cursor = cursor.sort(sort);
        }

        if (skip) {
            cursor.skip(skip);
        }

        if (limit) {
            cursor.limit(limit);
        }

        return _.map(cursor.all(), function (item) {
            return _.extend({}, item);
        });
    },

    readById: function (dataQuery, expand) {
        var self = this;
        var expandResult;
        return self._prepareExpand(expand, dataQuery, false)
            .then(function (prepareExpandResult) {
                expandResult = prepareExpandResult;
                return self._getCollection(dataQuery.collectionName);
            })
            .then(function (collection) {
                return new rsvp.Promise(function (resolve, reject) {
                    var item = self._getById(collection, dataQuery.additionalOptions.id);

                    if (!item) {
                        return reject(new EverliveError(EverliveErrors.itemNotFound));
                    }

                    item = offlineTransformations.idTransform(item);
                    return self._expandResult(expandResult, item).then(resolve).catch(reject);
                });
            })
            .then(function (result) {
                return self._transformOfflineResult(result, null, dataQuery);
            });
    },

    _getById: function (collection, id) {
        if (!id) {
            throw new EverliveError('Id field is mandatory when using offline storage');
        }

        if (collection[id]) {
            var item = _.extend({}, collection[id]);
            var isDeleted = item && item[constants.offlineItemsStateMarker] === offlineItemStates.deleted;

            return isDeleted ? undefined : item;
        }
    },

    _prepareExpand: function (expand, dataQuery, isArray) {
        return new rsvp.Promise(function (resolve, reject) {
            if (expand) {
                expandProcessor.prepare(expand, dataQuery.collectionName, isArray, dataQuery.fields, null, null, function (err, prepareResult) {
                    if (err) {
                        if (err.name === 'ExpandError') {
                            err.code = EverliveErrors.invalidExpandExpression.code;
                        }
                        return reject(err);
                    }
                    resolve(prepareResult);
                });
            } else {
                resolve();
            }
        });
    },

    _expandResult: function (prepareExpandResult, result) {
        var self = this;
        return new rsvp.Promise(function (resolve, reject) {
            if (prepareExpandResult) {
                expandProcessor.expand(prepareExpandResult.relationsTree, result, {
                    offlineModule: self
                }, function (err, result) {
                    if (err) {
                        if (err.name === 'ExpandError') {
                            err.code = EverliveErrors.invalidExpandExpression.code;
                        }
                        return reject(err);
                    }
                    resolve(result);
                });
            } else {
                resolve(result);
            }
        });
    },

    _getWithoutDeletedFilter: function (filter) {
        var withoutDeletedFilter = {
            $and: []
        };
        withoutDeletedFilter.$and.push(filter);
        var deleteOfflineFilter = {};
        deleteOfflineFilter[constants.offlineItemsStateMarker] = {$ne: offlineItemStates.deleted};
        withoutDeletedFilter.$and.push(deleteOfflineFilter);
        return withoutDeletedFilter;
    },

    _getUpdateItemsResult: function (updateItems) {
        var updatedItemCount = updateItems.length;
        var modifiedAtResult = updatedItemCount ? updateItems[0].ModifiedAt : new Date();

        return {
            ModifiedAt: modifiedAtResult,
            result: updatedItemCount
        };
    },

    update: function (dataQuery, filter) {
        var self = this;

        return this._updateItems(dataQuery, dataQuery.data, filter, dataQuery.isSync).then(function (updateItems) {
            return self._getUpdateItemsResult(updateItems);
        });
    },

    remove: function (dataQuery, filter) {
        return this._removeItems(dataQuery, filter, dataQuery.isSync);
    },

    count: function (dataQuery, filter) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            self._getCollection(dataQuery.collectionName)
                .then(function (collection) {
                    var filterResult = self._readInternal(collection, filter);
                    resolve({result: filterResult.length});
                }).catch(reject);
        });
    },

    _setItemDates: function (currentItem, itemToCreate, contentType) {
        // we need to manually clone the dates in order to dereference them from the original object as
        // _.extends will pass a reference to the original date instead of creating a new instance
        if (currentItem.CreatedAt && currentItem.CreatedAt instanceof Date) {
            itemToCreate.CreatedAt = utils.cloneDate(currentItem.CreatedAt);
        } else {
            itemToCreate.CreatedAt = new Date();
        }

        if (currentItem.ModifiedAt && currentItem.ModifiedAt instanceof Date) {
            itemToCreate.ModifiedAt = utils.cloneDate(currentItem.ModifiedAt);
        } else {
            itemToCreate.ModifiedAt = utils.cloneDate(itemToCreate.CreatedAt);
        }

        itemToCreate.CreatedBy = itemToCreate.CreatedBy || this.everlive.setup.principalId || constants.guidEmpty;
        itemToCreate.ModifiedBy = itemToCreate.ModifiedBy || itemToCreate.CreatedBy;
        if (contentType === 'Users') {
            itemToCreate.Owner = itemToCreate._id;
        } else {
            itemToCreate.Owner = itemToCreate.CreatedBy || constants.guidEmpty;
        }
    },

    _mapCreateItem: function (currentItem, collection, isSync, preserveState, contentType) {
        var self = this;

        var itemToCreate = _.extend({}, currentItem);
        itemToCreate._id = itemToCreate.Id || utils.uuid();
        delete itemToCreate.Id;

        var existingItem = self._getById(collection, itemToCreate._id);
        var itemExists = !!existingItem;
        var state;
        if (itemExists && (!isSync && !preserveState)) {
            // TODO: [offline] return the same error as the server does
            throw new EverliveError('An item with the specified id already exists');
        } else {
            if (isSync && preserveState && itemExists) {
                state = existingItem[constants.offlineItemsStateMarker];
            } else {
                state = isSync ? undefined : offlineItemStates.created; // set the state to created only if not syncing
            }
        }

        function processItemResult() {
            self._setItemDates(currentItem, itemToCreate, contentType);
            self._setItem(collection, _.extend({}, itemToCreate), state);
            return itemToCreate;
        }

        if (utils.isContentType.files(contentType)) {
            return self.offlineFilesProcessor.upsertFileFromObject(itemToCreate, true, isSync).then(processItemResult);
        } else {
            return processItemResult();
        }
    },

    _createItems: function (contentType, items, isSync, preserveState) {
        var self = this;
        return this._getCollection(contentType)
            .then(function (collection) {
                var itemsForCreate = _.isArray(items) ? items : [items];
                var createdItems = _.map(itemsForCreate, function (currentItem) {
                    return self._mapCreateItem(currentItem, collection, isSync, preserveState, contentType);
                });

                return rsvp.all(createdItems)
                    .then(function (items) {
                        return self._persistData(contentType)
                            .then(function () {
                                // Ids are generated regardless of the autoGenerateId option. However the Id's are omitted when returning
                                // the items to the client if autoGenerateId is false
                                if (!self._shouldAutogenerateIdForContentType(contentType) && !isSync) {
                                    createdItems = offlineTransformations.removeIdTransform(items);
                                }

                                return items;
                            });
                    });
            });
    },

    _applyUpdateOperation: function (originalUpdateExpression, itemToUpdate, collection, isSync, modifiedAt) {
        var dbOperators = utils.getDbOperators(originalUpdateExpression, true);
        var hasDbOperator = dbOperators.length !== 0;

        var updateExpression;
        if (hasDbOperator) {
            updateExpression = originalUpdateExpression;
        } else {
            updateExpression = {
                $set: originalUpdateExpression
            };
        }
        var updateExpressionForUser = {
            ModifiedBy: this.everlive.setup.principalId || constants.guidEmpty
        };
        updateExpression.$set = _.extend(updateExpressionForUser, updateExpression.$set);

        if (isSync) {
            updateExpression.$set.ModifiedAt = utils.cloneDate(originalUpdateExpression.ModifiedAt || modifiedAt);
        }

        mongoQuery(itemToUpdate, {}, updateExpression, {strict: true}); // Setting strict to true so only exact matches would be updated

        itemToUpdate._id = itemToUpdate._id || updateExpression._id || updateExpression.Id;
        delete itemToUpdate.Id;

        var newState;
        if (isSync) {
            newState = undefined;
        } else if (itemToUpdate[constants.offlineItemsStateMarker] === offlineItemStates.created) {
            newState = offlineItemStates.created;
        } else {
            newState = offlineItemStates.modified;
        }

        this._setItem(collection, itemToUpdate, newState);
    },

    updateFileContent: function (dataQuery) {
        var isSync = dataQuery.isSync;
        var updateExpression = dataQuery.data;
        var self = this;
        var itemId = dataQuery.additionalOptions.id;
        var updateItems;
        var typeName = dataQuery.collectionName;
        return this._getCollection(typeName)
            .then(function (collection) {
                var singleItemForUpdate = self._getById(collection, itemId);
                updateItems = [singleItemForUpdate];
                singleItemForUpdate.base64 = updateExpression.base64;
                singleItemForUpdate.Filename = updateExpression.Filename;
                singleItemForUpdate.ContentType = updateExpression.ContentType;
                delete singleItemForUpdate.Uri;

                return self._overwriteFile(itemId, singleItemForUpdate, isSync)
                    .then(function () {
                        self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection);
                        self._setItem(collection, singleItemForUpdate, constants.offlineItemStates.modified);
                        return self._persistData(typeName);
                    })
                    .then(function () {
                        return self._getUpdateItemsResult(updateItems);
                    })
            });
    },

    _overwriteFile: function (itemId, itemForUpdate, isSync) {
        var self = this;

        return self.everlive.offlineStorage.files.purge(itemId)
            .then(function () {
                return self.offlineFilesProcessor.upsertFileFromObject(itemForUpdate, true, isSync);
            })
    },

    _updateItems: function (dataQuery, updateExpression, filter, isSync) {
        var self = this;
        var collectionName = dataQuery.collectionName;

        return self._getCollection(collectionName)
            .then(function (collection) {
                var updateItems;

                if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
                    var itemId = dataQuery.additionalOptions.id;
                    var singleItemForUpdate = self._getById(collection, itemId);
                    updateItems = [singleItemForUpdate];

                    if (utils.isContentType.files(collectionName) && updateExpression.$set && updateExpression.$set.Filename || updateExpression.Filename) {
                        var filename = updateExpression.Filename || updateExpression.$set.Filename;
                        var extension = path.extname(filename);
                        return self.everlive.offlineStorage.files.changeFileExtensionById(itemId, extension)
                            .then(function () {
                                self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection, isSync, dataQuery.ModifiedAt);
                                return self._persistData(collectionName);
                            })
                            .then(function () {
                                return updateItems;
                            });
                    } else {
                        self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection, isSync, dataQuery.ModifiedAt);
                    }
                } else {
                    updateItems = self._readInternal(collection, filter);
                    for (var i = 0; i < updateItems.length; i++) {
                        var itemToUpdate = updateItems[i];
                        var itemExists = !!self._getById(collection, itemToUpdate._id.toString());

                        if (!itemExists && !isSync) {
                            // TODO: [offline] return the correct error
                            throw new EverliveError(EverliveErrors.itemNotFound);
                        }

                        self._applyUpdateOperation(updateExpression, itemToUpdate, collection, isSync, dataQuery.ModifiedAt);
                    }
                }

                return self._persistData(collectionName)
                    .then(function () {
                        return updateItems;
                    });
            });
    },

    _getAllCollections: function () {
        var self = this;
        return new rsvp.Promise(function (resolve, reject) {
            self._persister.getAllData(function (allData) {
                _.each(allData, function (value, key) {
                    var decryptedData = self._encryptionProvider.decrypt(value);
                    allData[key] = JSON.parse(decryptedData || '{}', utils.parseUtilities.getReviver());
                });

                resolve(allData);
            }, reject);
        });
    },

    _getCollection: function (contentType) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            // check the persister if there is no data in the collection cache for this content type
            if (!self._collectionCache[contentType]) {
                self._persister.getData(contentType, function (data) {
                    var decryptedDataRaw = self._encryptionProvider.decrypt(data);
                    var decryptedData = JSON.parse(decryptedDataRaw || '{}', utils.parseUtilities.getReviver());
                    self._collectionCache[contentType] = decryptedData;

                    resolve(self._collectionCache[contentType]);
                }, reject);
            } else {
                resolve(self._collectionCache[contentType]);
            }
        });
    },

    _setItem: function (collection, item, state) {
        if (!state) {
            delete item[constants.offlineItemsStateMarker];
        } else {
            item[constants.offlineItemsStateMarker] = state;
        }

        collection[item._id] = item;
    },


    _getDirtyItems: function (collection) {
        var filter = {};
        filter[constants.offlineItemsStateMarker] = {$exists: true};
        var query = mingo.Query(filter);
        var cursor = mingo.Cursor(collection, query);
        return cursor.all();
    },

    _persistData: function (contentType) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            var contentTypeData = self._collectionCache[contentType] || {};
            self._transformPersistedData(contentType, contentTypeData);
            var contentTypeDataRaw = JSON.stringify(contentTypeData);
            var contentTypeDataRawEncrypted = self._encryptionProvider.encrypt(contentTypeDataRaw);
            self._persister.saveData(contentType, contentTypeDataRawEncrypted, resolve, reject);
        });
    },

    _shouldAutogenerateIdForContentType: function (contentType) {
        return !(this.setup && this.setup.typeSettings && this.setup.typeSettings[contentType] && this.setup.typeSettings[contentType].autoGenerateId === false);
    },

    _clearItem: function (collection, item) {
        delete collection[item._id];
    },

    _mapRemoveItem: function (itemToRemove, collection, isSync, collectionName) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            if (utils.isContentType.files(collectionName)) {
                return self.everlive.offlineStorage.files.purge(itemToRemove._id).then(resolve, reject);
            } else {
                return resolve();
            }
        }).then(function () {
                itemToRemove._id = itemToRemove._id || itemToRemove.Id;

                var itemExists = !!self._getById(collection, itemToRemove._id.toString());
                if (!itemExists && !isSync) {
                    throw new EverliveError('Cannot delete item - item with id ' + itemToRemove._id + ' does not exist.');
                }

                // if the item has existed only offline or the data is syncing
                // and the item was deleted by the conflict resolution strategy
                var removeFromMemory = itemToRemove[constants.offlineItemsStateMarker] === offlineItemStates.created || isSync;
                if (removeFromMemory) {
                    self._clearItem(collection, itemToRemove);
                } else {
                    self._setItem(collection, itemToRemove, offlineItemStates.deleted);
                }
            });
    },

    _removeItems: function (dataQuery, filter, isSync) {
        var self = this;
        var collectionName = dataQuery.collectionName;

        return self._getCollection(collectionName)
            .then(function (collection) {
                var itemsToRemove = self._readInternal(collection, filter);

                var removedItemsPromises = _.map(itemsToRemove, function (itemToRemove) {
                    return self._mapRemoveItem(itemToRemove, collection, isSync, collectionName);
                });

                return rsvp.all(removedItemsPromises);
            })
            .then(function (itemsToRemove) {
                return self._persistData(collectionName)
                    .then(function () {
                        return itemsToRemove;
                    });
            })
            .then(function (itemsToRemove) {
                return self._transformOfflineResult(itemsToRemove.length);
            });
    },

    _applyTransformations: function (transformedResult, transformations) {
        if (Array.isArray(transformedResult.result)) {
            _.each(transformations, function (transformation) {
                transformedResult.result.map(function (value, key) {
                    transformedResult.result[key] = transformation(value);
                });
            });
        } else {
            _.each(transformations, function (transformation) {
                transformedResult.result = transformation(transformedResult.result);
            });
        }
    },

    _transformOfflineResult: function (resultSet, count, dataQuery, additionalTransformations) {
        var transformedResult = {
            result: resultSet,
            count: count || (resultSet || []).length
        };

        if ((count !== undefined && count !== null) || Array.isArray(resultSet)) {
            transformedResult.count = count || resultSet.length;
        }

        var transformations = [];

        transformations.push(offlineTransformations.idTransform);
        transformations.push(offlineTransformations.removeMarkersTransform);

        if (dataQuery) {
            var includeCount = dataQuery.getHeader(Headers.includeCount);
            if (includeCount === false) {
                delete transformedResult.count;
            }

            var singleFieldExpression = dataQuery.getHeader(Headers.singleField);
            if (typeof singleFieldExpression === 'string') {
                transformations.push(offlineTransformations.singleFieldTransform.bind(this, singleFieldExpression));
            }
        }

        if (additionalTransformations) {
            transformations = transformations.concat(additionalTransformations);
        }

        this._applyTransformations(transformedResult, transformations);

        if (transformedResult.count === undefined) {
            delete transformedResult.count;
        }

        return transformedResult;
    },

    _transformPersistedData: function (contentType, contentTypeData) {
        var transformFields = [];

        if (contentType === 'Users') {
            transformFields = transformFields.concat(['Password', 'SecretQuestionId', 'SecretAnswer']);
        }

        if (transformFields.length) {
            _.each(contentTypeData, function (contentTypeObject) {
                offlineTransformations.removeFieldsTransform(contentTypeObject, transformFields);
            });
        }
    },

    purgeAll: function (success, error) {
        var self = this;
        this._collectionCache = {};
        return buildPromise(function (success, error) {
            self._persister.purgeAll(function () {
                if (self.everlive.setup.caching) {
                    self.everlive.cache.clearAll(success, error);
                } else {
                    success();
                }
            }, error);
        }, success, error);
    },

    purge: function (contentType, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            self._persister.purge(contentType, function () {
                if (self.everlive.setup.caching) {
                    self.everlive.cache.clear(contentType, success, error);
                } else {
                    success();
                }
            }, error);
        }, success, error);
    }
};

module.exports = OfflineQueryProcessor;
},{"../EverliveError":42,"../ExpandProcessor":43,"../common":53,"../constants":54,"../query/DataQuery":80,"../query/Query":81,"../utils":94,"./offlineTransformations":73,"path":4}],70:[function(require,module,exports){
var DataQuery = require('../query/DataQuery');
var everliveErrorModule = require('../EverliveError');
var EverliveError = everliveErrorModule.EverliveError;
var EverliveErrors = everliveErrorModule.EverliveErrors;
var constants = require('../constants');
var offlineItemStates = constants.offlineItemStates;
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var utils = require('../utils');
var Request = require('../Request');
var offlineTransformations = require('./offlineTransformations');
var buildPromise = require('../utils').buildPromise;
var OfflineQueryProcessor = require('./OfflineQueryProcessor');
var OfflineFilesProcessor = require('./OfflineFilesProcessor');
var OfflineFilesModule = require('./OfflineFilesModule');
var path = require('path');

var syncLocation = {
    server: 'server',
    client: 'client'
};

/**
 * @class OfflineModule
 * @classDesc A class providing access to the various offline storage features.
 */

/**
 * Represents the {@link OfflineModule} class.
 * @memberOf Everlive.prototype
 * @member {OfflineModule} offlineStorage
 */

module.exports = (function () {
    function OfflineModule(everlive, options, persister, encryptionProvider) {
        this._everlive = everlive;
        this.setup = options;
        this._isSynchronizing = false;
        this._encryptionProvider = encryptionProvider;

        this._offlineFilesProcessor = new OfflineFilesProcessor(this.setup, this._everlive);
        this._queryProcessor = new OfflineQueryProcessor(persister, encryptionProvider,
            this._offlineFilesProcessor, this._everlive, this.setup);

        /**
         * @memberOf Everlive.prototype
         * @instance
         * @description An instance of the [OfflineFilesModule]{@link OfflineFilesModule} class for working with files in offline mode.
         * @member {OfflineFilesModule} files
         */
        this.files = new OfflineFilesModule(this._offlineFilesProcessor,
            this._everlive, this.setup.files.maxConcurrentDownloads);
    }

    var getSyncFilterForItem = function (item) {
        var filter = getSyncFilterNoModifiedAt(item);
        filter.ModifiedAt = item.ModifiedAt;
        return filter;
    };

    var getSyncFilterNoModifiedAt = function (item) {
        return {
            Id: item.Id
        }
    };


    OfflineModule.prototype = {
        /**
         * Removes all data from the offline storage.
         * @method purgeAll
         * @name purgeAll
         * @memberOf OfflineModule.prototype
         * @param {function} [success] A success callback.
         * @param {function} [error] An error callback.
         */
        /**
         * Removes all data from the offline storage.
         * @method purgeAll
         * @name purgeAll
         * @memberOf OfflineModule.prototype
         * @returns Promise
         */
        purgeAll: function (success, error) {
            return this._queryProcessor.purgeAll(success, error);
        },

        /**
         * Removes all data for a specific content type from the offline storage.
         * @method purge
         * @name purge
         * @memberOf OfflineModule.prototype
         * @param {string} contentType The content type to purge.
         * @param {function} [success] A success callback.
         * @param {function} [error] An error callback.
         */
        /**
         * Removes all data for a specific content type from the offline storage.
         * @method purge
         * @name purge
         * @memberOf OfflineModule.prototype
         * @param {string} contentType The content type to purge.
         * @returns Promise
         */
        purge: function (contentType, success, error) {
            return this._queryProcessor.purge(contentType, success, error);
        },

        processQuery: function (query) {
            return this._queryProcessor.processQuery(query);
        },

        _setOffline: function (offline) {
            this.setup.offline = offline;
        },

        isOnline: function () {
            return !this.setup.offline;
        },

        _prepareSyncData: function (contentTypesForSync) {
            var self = this;

            var contentTypesSyncData = {};
            var conflicts = [];
            _.each(contentTypesForSync, function (contentType, typeName) {
                var syncItems = offlineTransformations.idTransform(contentType.offlineItemsToSync);
                var syncData = self._getSyncItemStates(typeName, syncItems, contentType.serverItems);
                conflicts.push(syncData.conflicts);
                contentTypesSyncData[typeName] = syncData.itemsForSync;
            });

            return {
                conflicts: conflicts,
                contentTypesSyncData: contentTypesSyncData
            };
        },

        _resolveConflicts: function (syncData) {
            var self = this;
            return this._applyResolutionStrategy(syncData.conflicts)
                .then(function () {
                    return self._mergeResolvedConflicts(syncData.conflicts, syncData.contentTypesSyncData);
                })
                .then(function () {
                    return syncData.contentTypesSyncData;
                });
        },

        isSynchronizing: function () {
            return this._isSynchronizing;
        },

        _fireSyncStart: function () {
            var self = this;

            return new rsvp.Promise(function (resolve) {
                if (!self._isSynchronizing) {
                    self._isSynchronizing = true;
                    self._everlive._emitter.emit('syncStart');
                    resolve();
                } else {
                    resolve();
                }
            });
        },

        _fireSyncEnd: function () {
            this._isSynchronizing = false;
            this._everlive._emitter.emit('syncEnd', this._syncResultInfo);
            delete this._syncResultInfo;
        },

        _eachSyncItem: function (items, getFilterFunction, contentTypeName, operation) {
            var self = this;

            _.each(items, function (item) {
                var itemFilter = getFilterFunction(item.remoteItem);
                // if we already have an error for this item we do not want to try and sync it again
                var resultItem = item.resultingItem;
                var isCustom = item.isCustom;
                var resolutionType = item.resolutionType;
                if (_.some(self._syncResultInfo.failedItems[contentTypeName], {itemId: resultItem.Id})) {
                    return;
                }

                operation(resultItem, itemFilter, isCustom, resolutionType);
            });
        },

        _shouldAutogenerateIdForContentType: function (collectionName) {
            return this._queryProcessor._shouldAutogenerateIdForContentType(collectionName);
        },

        _addCreatedFileToSyncPromises: function (resultingItemsForCreate, syncPromises, collectionName) {
            var self = this;

            _.each(resultingItemsForCreate, function (item) {
                var filesCollection = self._everlive.files;
                syncPromises[item.Id] = new rsvp.Promise(function (resolve, reject) {
                    self.files.getOfflineLocation(item.Id)
                        .then(function (location) {
                            if (location) {
                                return self._transferFile(false, item, location);
                            }
                        }, function (err) {
                            reject({
                                type: offlineItemStates.created,
                                items: item,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.server
                            });
                        })
                        .then(function (res) {
                            var mergedWithServerResponseItem = _.extend({}, item, res.result);
                            self._onItemProcessed(mergedWithServerResponseItem, collectionName, syncLocation.server, offlineItemStates.created);
                            return filesCollection
                                .isSync(true)
                                .useOffline(true)
                                .updateSingle(mergedWithServerResponseItem);
                        }, function (err) {
                            reject({
                                type: offlineItemStates.created,
                                items: item,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.server
                            });
                        })
                        .then(resolve, function (err) {
                            reject({
                                type: offlineItemStates.modified,
                                items: item,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.client
                            });
                        });
                });
            });
        },

        _transferFile: function (isUpdate, item, location) {
            var sdk = this._everlive;

            return new rsvp.Promise(function (resolve, reject) {
                var self = this;
                var uploadUrl = sdk.files.getUploadUrl();
                var fileExistsPromise = utils.successfulPromise();

                if (isUpdate) {
                    fileExistsPromise = new rsvp.Promise(function (resolve) {
                        sdk.files
                            .isSync(true)
                            .applyOffline(false)
                            .getById(item.Id)
                            .then(function () {
                                resolve(true);
                            }).catch(function () {
                                resolve(false);
                            });
                    });
                }

                fileExistsPromise.then(function (fileExistsOnServer) {
                    var canUpdate = isUpdate && fileExistsOnServer;
                    if (canUpdate) {
                        uploadUrl += '/' + item.Id + '/Content';
                    }

                    var fileTransfer = new FileTransfer();
                    var fileKey = constants.fileUploadKey;
                    var options = {
                        fileKey: fileKey,
                        httpMethod: canUpdate ? 'PUT' : 'POST',
                        mimeType: item.ContentType,
                        fileName: item.Filename,
                        headers: sdk.buildAuthHeader()
                    };

                    options.params = {};

                    _.each(item, function (value, key) {
                        if (key.toLowerCase() !== 'base64') {
                            var prefixedKey = constants.fileUploadKey + constants.fileUploadDelimiter + key;
                            options.params[prefixedKey] = value;
                        }
                    });

                    fileTransfer.upload(location, uploadUrl, function (result) {
                        var parsedResult = utils.parseUtilities.parseJSON(result.response);
                        if (parsedResult.Result === false) {
                            reject.apply(self, arguments);
                        } else if (_.isArray(parsedResult.Result)) {
                            resolve({
                                result: parsedResult.Result[0]
                            })
                        } else {
                            resolve(parsedResult);
                        }
                    }, reject, options, true);
                });
            });
        },

        _addCreatedObjectToSyncPromises: function (syncPromises, dataCollection, resultingItemsForCreate, contentTypeData, collectionName, ids) {
            var self = this;

            var promise = new rsvp.Promise(function (resolve, reject) {
                dataCollection
                    .isSync(true)
                    .applyOffline(false)
                    .create(resultingItemsForCreate)
                    .then(function (res) {
                        resultingItemsForCreate = _.map(resultingItemsForCreate, function (item, index) {
                            item.Id = res.result[index].Id;
                            item.CreatedAt = item.ModifiedAt = res.result[index].CreatedAt;
                            var resultingItem = _.find(contentTypeData.createdItems, function (createdItem) {
                                return createdItem.resultingItem.Id === item.Id;
                            });

                            if (resultingItem.isCustom) {
                                self._onItemProcessed(item, collectionName, syncLocation.client, offlineItemStates.modified);
                            }

                            return item;
                        });
                    }, function (err) {
                        throw {
                            type: offlineItemStates.created,
                            items: resultingItemsForCreate,
                            contentType: collectionName,
                            error: err,
                            storage: syncLocation.server
                        };
                    })
                    .then(function () {
                        return dataCollection
                            .isSync(true)
                            .useOffline(true)
                            .create(resultingItemsForCreate)
                            .then(function () {
                                _.each(resultingItemsForCreate, function (createdItem) {
                                    self._onItemProcessed(createdItem, collectionName, syncLocation.server,
                                        offlineItemStates.created);
                                });
                            }, function (err) {
                                throw {
                                    type: offlineItemStates.created,
                                    items: resultingItemsForCreate,
                                    contentType: collectionName,
                                    error: err,
                                    storage: syncLocation.client
                                };
                            });
                    })
                    .then(function () {
                        if (ids && ids.length) {
                            var filter = {Id: {$in: ids}};
                            return dataCollection
                                .isSync(true)
                                .useOffline(true)
                                .destroy(filter)
                                .catch(function (err) {
                                    throw {
                                        type: offlineItemStates.created,
                                        items: resultingItemsForCreate,
                                        contentType: collectionName,
                                        error: err,
                                        storage: syncLocation.client
                                    };
                                });
                        }
                    })
                    .then(resolve)
                    .catch(function (err) {
                        reject(err);
                    });
            });

            _.each(resultingItemsForCreate, function (item) {
                syncPromises[item.Id] = promise;
            });

            return resultingItemsForCreate;
        },

        _addCreatedItemsForSync: function (contentTypeData, syncPromises, dataCollection) {
            var collectionName = dataCollection.collectionName;

            var resultingItemsForCreate = _.pluck(contentTypeData.createdItems, 'resultingItem');
            var ids;
            if (!this._shouldAutogenerateIdForContentType(collectionName)) {
                ids = _.pluck(resultingItemsForCreate, 'Id');
                resultingItemsForCreate = offlineTransformations.removeIdTransform(resultingItemsForCreate);
            }

            if (utils.isContentType.files(collectionName)) {
                return this._addCreatedFileToSyncPromises(resultingItemsForCreate, syncPromises, collectionName);
            } else {
                return this._addCreatedObjectToSyncPromises(syncPromises, dataCollection, resultingItemsForCreate, contentTypeData, collectionName, ids);
            }
        },

        _addUpdatedItemsForSync: function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemUpdateOperation) {
            var self = this;
            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.modifiedItems, getFilterOperation, collectionName, itemUpdateOperation);
        },

        _addDeletedItemsForSync: function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemDeleteOperation) {
            var self = this;

            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.deletedItems, getFilterOperation, collectionName, itemDeleteOperation);
        },

        _onSyncResponse: function (res, item, collectionName, operation, isCustomItem) {
            var self = this;

            if (res.result !== 1) {
                return new rsvp.Promise(function (resolve, reject) {
                    reject(_.extend({}, EverliveErrors.syncConflict, {
                        contentType: collectionName
                    }));
                });
            } else {
                if (operation === DataQuery.operations.update) {
                    self._onItemProcessed(item, collectionName, syncLocation.server, offlineItemStates.modified);
                    var updatedItem = _.extend({}, item, {
                        ModifiedAt: res.ModifiedAt
                    });

                    var updateQuery = new DataQuery({
                        operation: operation,
                        data: updatedItem,
                        additionalOptions: {
                            id: item.Id
                        },
                        collectionName: collectionName,
                        isSync: true
                    });

                    return this.processQuery(updateQuery)
                        .then(function () {
                            if (isCustomItem) {
                                var existingItem = _.find(self._syncResultInfo.syncedItems[collectionName], function (syncedItem) {
                                    return syncedItem.itemId === item.Id;
                                });

                                if (!existingItem) {
                                    self._onItemProcessed(item, collectionName, syncLocation.client, offlineItemStates.modified);
                                }
                            }
                        });
                } else if (operation === DataQuery.operations.remove) {
                    self._onItemProcessed(item, collectionName, syncLocation.server, offlineItemStates.deleted);
                    return this._purgeById(collectionName, item.Id)
                        .then(function () {
                            if (isCustomItem) {
                                self._onItemProcessed(item, collectionName, syncLocation.client, offlineItemStates.deleted);
                            }
                        });
                }
            }
        },

        _purgeById: function (contentType, itemId) {
            var self = this;

            return this._queryProcessor._getCollection(contentType)
                .then(function (collection) {
                    delete collection[itemId];
                    return self._queryProcessor._persistData(contentType);
                });
        },

        sync: function () {
            var self = this;
            self._syncResultInfo = self._syncResultInfo || {
                syncedItems: {},
                syncedToServer: 0,
                syncedToClient: 0,
                failedItems: {},
                error: undefined // added for visibility
            };

            if (!this.isOnline()) {
                throw new EverliveError('Cannot synchronize while offline');
            }

            self._fireSyncStart()
                .then(function () {
                    return self._applySync();
                })
                .then(function (syncResults) {
                    var conflictsWhileSync = [];
                    _.each(syncResults, function (syncResult, itemId) {
                        if (syncResult && syncResult.state === 'rejected') {
                            if (syncResult.reason && syncResult.reason.code === EverliveErrors.syncConflict.code) {
                                conflictsWhileSync.push(syncResult);
                            } else {
                                // to save time and traffic we are using a single create request for all items
                                // this is why if there is an error we need to split the items we tried to create
                                // and set the same error for all items.
                                self._onItemFailed(syncResult, itemId);
                            }
                        }
                    });

                    if (conflictsWhileSync.length) {
                        return self.sync();
                    } else {
                        self._fireSyncEnd();
                    }
                })
                .catch(function (err) {
                    self._syncResultInfo.error = err;
                    self._fireSyncEnd();
                });
        },

        _handleKeepServer: function (typeName, conflictingItem, offlineSyncOperations, contentTypeSyncData) {
            var self = this;

            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var syncQuery;
            if (serverItem && clientItem) {
                // update the item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    additionalOptions: {
                        id: serverItem.Id
                    },
                    data: serverItem
                });
            } else if (serverItem && !clientItem) {
                // create item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: serverItem
                });
            } else if (!serverItem && clientItem) {
                // delete item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.removeSingle,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepServer" resolution strategy.');
            }

            syncQuery.isSync = true;
            offlineSyncOperations.push(new rsvp.Promise(function (resolve, reject) {
                self.processQuery(syncQuery)
                    .then(function () {
                        switch (syncQuery.operation) {
                            case DataQuery.operations.update:
                                self._onItemProcessed(serverItem, typeName, syncLocation.client, offlineItemStates.modified);
                                // the files content type is special and needs to enable the file contents offline, so we cannot only
                                // update the data
                                if (utils.isContentType.files(typeName)) {
                                    contentTypeSyncData.modifiedItems.push({
                                        remoteItem: conflictingItem.serverItem,
                                        resultingItem: serverItem,
                                        resolutionType: constants.ConflictResolution.KeepServer
                                    });
                                }
                                break;
                            case DataQuery.operations.create:
                                self._onItemProcessed(serverItem, typeName, syncLocation.client, offlineItemStates.created);
                                break;
                            case DataQuery.operations.removeSingle:
                                self._onItemProcessed(clientItem, typeName, syncLocation.client, offlineItemStates.deleted);
                                break;
                        }
                        resolve();
                    }, function (err) {
                        var itemId;
                        var operation;
                        switch (syncQuery.operation) {
                            case DataQuery.operations.update:
                                itemId = serverItem.Id;
                                operation = offlineItemStates.modified;
                                break;
                            case DataQuery.operations.create:
                                itemId = serverItem.Id;
                                operation = offlineItemStates.created;
                                break;
                            case DataQuery.operations.removeSingle:
                                itemId = clientItem.Id;
                                operation = offlineItemStates.deleted;
                                break;
                        }

                        reject({
                            itemId: itemId,
                            type: operation,
                            contentType: syncQuery.collectionName,
                            error: err,
                            storage: syncLocation.client
                        })
                    })
            }));
        },

        _handleKeepClient: function (conflictingItem, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var resultingItem;
            var collection;

            if (serverItem && clientItem) {
                resultingItem = _.extend(clientItem, {ModifiedAt: new Date(serverItem.ModifiedAt)});
                collection = contentTypeSyncData.modifiedItems;
            } else if (serverItem && !clientItem) {
                resultingItem = serverItem;
                collection = contentTypeSyncData.deletedItems;
            } else if (!serverItem && clientItem) {
                resultingItem = clientItem;
                collection = contentTypeSyncData.createdItems;
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepClient" resolution strategy.');
            }

            collection.push({
                remoteItem: conflictingItem.serverItem,
                resultingItem: resultingItem,
                resolutionType: constants.ConflictResolution.KeepClient
            });
        },

        _handleCustom: function (conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var customItem = _.omit(conflictingItem.result.item, 'CreatedAt', 'ModifiedAt');
            if (serverItem && customItem) {
                var createItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: serverItem // create the server item offline and it will be updated when sync finishes
                });

                createItemOfflineQuery.preserveState = true;
                createItemOfflineQuery.isSync = true;

                offlineSyncOperations.push(this.processQuery(createItemOfflineQuery));

                this._onItemProcessed(serverItem, typeName, syncLocation.client, offlineItemStates.created);
            }

            if (serverItem && customItem && !clientItem) {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem,
                    isCustom: true
                });
            } else if (serverItem && !customItem) {
                contentTypeSyncData.deletedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: serverItem,
                    isCustom: true
                });
            } else if (!serverItem && customItem && clientItem) {
                var updateItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    data: customItem,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });

                offlineSyncOperations.push(this.processQuery(updateItemOfflineQuery));
                customItem.Id = clientItem.Id;

                contentTypeSyncData.createdItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem,
                    isCustom: true
                });
            } else {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem,
                    isCustom: true
                });
            }
        },

        _mergeResolvedConflicts: function (conflicts, syncData) {
            var self = this;

            var offlineSyncOperations = [];
            _.each(conflicts, function (conflict) {
                var typeName = conflict.contentTypeName;
                _.each(conflict.conflictingItems, function (conflictingItem) {
                    var contentTypeSyncData = syncData[typeName];
                    switch (conflictingItem.result.resolutionType) {
                        case constants.ConflictResolution.KeepServer:
                            self._handleKeepServer(typeName, conflictingItem, offlineSyncOperations, contentTypeSyncData);
                            break;
                        case constants.ConflictResolution.KeepClient:
                            self._handleKeepClient(conflictingItem, contentTypeSyncData);
                            break;
                        case constants.ConflictResolution.Custom:
                            if (utils.isContentType.files(typeName)) {
                                var err = EverliveErrors.customFileSyncNotSupported;
                                throw new EverliveError(err.message, err.code);
                            }

                            self._handleCustom(conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData);
                            break;
                        case constants.ConflictResolution.Skip:
                            break;
                    }
                });
            });

            return rsvp.all(offlineSyncOperations);
        },

        _getSyncItemStates: function (contentType, offlineItems, serverItems) {
            var self = this;

            var contentTypeSyncData = {
                itemsForSync: {
                    createdItems: [],
                    modifiedItems: [],
                    deletedItems: []
                },
                conflicts: {
                    contentTypeName: contentType,
                    conflictingItems: []
                }
            };

            _.each(offlineItems, function (offlineItem) {
                var serverItem = _.findWhere(serverItems, {Id: offlineItem.Id});
                if (serverItem) {
                    if (serverItem.Id === offlineItem.Id && offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.created) {
                        if (self.setup.conflicts.strategy === constants.ConflictResolutionStrategy.Custom) {
                            self._onItemFailed({
                                type: offlineItemStates.modified,
                                storage: syncLocation.client,
                                error: new EverliveError(EverliveErrors.syncError),
                                contentType: contentType
                            }, offlineItem.Id);

                            return self._onItemFailed({
                                type: offlineItemStates.modified,
                                storage: syncLocation.server,
                                error: new EverliveError(EverliveErrors.syncError),
                                contentType: contentType
                            }, serverItem.Id);
                        } else {
                            return self._onItemFailed({
                                type: offlineItemStates.created,
                                storage: syncLocation.client,
                                error: new EverliveError(EverliveErrors.syncError),
                                contentType: contentType
                            }, serverItem.Id);
                        }
                    }

                    var clientItemChanged = !!offlineItem[constants.offlineItemsStateMarker];
                    var hasUpdateConflict = false;

                    if (clientItemChanged) {
                        hasUpdateConflict = serverItem.ModifiedAt.getTime() !== offlineItem.ModifiedAt.getTime()
                        || offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted;
                        //TODO: when an item is removed offline its ModifiedAt field is not set, check if it needs to be set or we can use this
                    }

                    if (hasUpdateConflict) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            // if the item was modified on the server and deleted locally we have a conflict and set the client item to null
                            // otherwise it is a simple modification conflict
                            clientItem: offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted ? null : offlineItem,
                            serverItem: serverItem,
                            result: {}
                        });
                    } else {
                        if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted) {
                            contentTypeSyncData.itemsForSync.deletedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        } else {
                            contentTypeSyncData.itemsForSync.modifiedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        }
                    }
                } else {
                    // if the item in memory has been modified, but the item on the server has been deleted
                    if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.modified) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            clientItem: offlineItem,
                            serverItem: null,
                            result: {}
                        });
                    } else {
                        contentTypeSyncData.itemsForSync.createdItems.push({
                            remoteItem: serverItem,
                            resultingItem: offlineItem
                        });
                    }
                }

                delete offlineItem[constants.offlineItemsStateMarker];
            });

            return contentTypeSyncData;
        },

        _setResolutionTypeForItem: function (resolutionType, conflictingItem) {
            conflictingItem.result = {
                resolutionType: resolutionType
            };
        },

        _applyResolutionStrategy: function (conflicts) {
            var self = this;
            var conflictResolutionStrategy = self.setup.conflicts.strategy;
            return new rsvp.Promise(function (resolve, reject) {
                var conflictResolutionPromises = [];

                for (var i = 0; i < conflicts.length; i++) {
                    var conflict = conflicts[i];
                    if (conflict.conflictingItems.length) {
                        switch (conflictResolutionStrategy) {
                            case constants.ConflictResolutionStrategy.ServerWins:
                                _.each(conflict.conflictingItems,
                                    self._setResolutionTypeForItem.bind(self, constants.ConflictResolution.KeepServer));
                                break;
                            case constants.ConflictResolutionStrategy.Custom:
                                var customStrategy = self.setup.conflicts.implementation;
                                if (!customStrategy) {
                                    return reject(new EverliveError('Implementation of the conflict resolution strategy ' +
                                    'must be provided when set to Custom'));
                                }

                                conflictResolutionPromises.push(new rsvp.Promise(function (resolve) {
                                    customStrategy(conflicts, resolve)
                                }));
                                break;
                            default:
                                return reject(new EverliveError('Invalid resolution strategy provided'));
                        }
                    }
                }

                rsvp.all(conflictResolutionPromises)
                    .then(function () {
                        resolve();
                    });
            });
        },

        _getSyncPromiseBatch: function (contentType, batchIds) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                var dataQuery = new DataQuery({
                    collectionName: contentType,
                    filter: {
                        'Id': {
                            '$in': batchIds
                        }
                    },
                    operation: DataQuery.operations.read,
                    onSuccess: function (res) {
                        resolve(res.result);
                    },
                    applyOffline: false,
                    onError: reject
                });

                var getRequestOptionsFromQuery = RequestOptionsBuilder[dataQuery.operation];
                var requestOptions = getRequestOptionsFromQuery(dataQuery);
                var request = new Request(self._everlive.setup, requestOptions);
                request.send();
            });
        },

        _getDirtyItems: function (collection) {
            return this._queryProcessor._getDirtyItems(collection);
        },

        _getSyncPromiseForCollection: function (collection, contentType) {
            var self = this;

            var batches = [];
            var batchSize = constants.syncBatchSize;

            var offlineItemsToSync = self._getDirtyItems(collection);

            var allIdsForSync;
            if (this._shouldAutogenerateIdForContentType(contentType)) {
                allIdsForSync = _.pluck(offlineItemsToSync, '_id');
            } else {
                allIdsForSync = _.pluck(_.reject(offlineItemsToSync, function (offlineItem) {
                    return offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.created;
                }), '_id');
            }

            var batchCount = Math.ceil(allIdsForSync.length / batchSize);

            for (var i = 0; i < batchCount; i++) {
                var batchSkipSize = i * batchSize;
                var batchIds = allIdsForSync.slice(batchSkipSize, batchSkipSize + batchSize);
                var syncGetServerItemsPromise = this._getSyncPromiseBatch(contentType, batchIds);
                batches.push(syncGetServerItemsPromise);
            }

            return rsvp.all(batches)
                .then(function (serverItemsSyncResponses) {
                    var result = {
                        serverItems: []
                    };

                    _.each(serverItemsSyncResponses, function (serverItems) {
                        result.serverItems = _.union(result.serverItems, serverItems);
                    });

                    result.offlineItemsToSync = offlineItemsToSync;
                    return result;
                });
        },

        _onItemFailed: function (syncResult, itemId) {
            var self = this;

            var results = syncResult.reason ? syncResult.reason : syncResult;
            var targetType = results.contentType;

            var getFailedItem = function (id) {
                var pickedObject = _.pick(results, 'storage', 'type', 'error');
                return _.extend({
                    itemId: id,
                    contentType: targetType
                }, pickedObject);
            };

            var failedItems = [];
            if (results.type === offlineItemStates.created && results.items) {
                failedItems = _.map(results.items, function (item) {
                    return getFailedItem(item.Id);
                });
            } else {
                failedItems.push(getFailedItem(itemId));
            }

            self._syncResultInfo.failedItems[targetType] = self._syncResultInfo.failedItems[targetType] || [];
            _.each(failedItems, function (failedItem) {
                self._syncResultInfo.failedItems[targetType].push(failedItem);
                self._fireItemProcessed(failedItem);
            });
        },

        _onItemProcessed: function (item, contentType, syncStorage, syncType) {
            var syncInfo = {
                itemId: item.Id,
                type: syncType,
                storage: syncStorage,
                contentType: contentType
            };

            this._syncResultInfo.syncedItems[contentType] = this._syncResultInfo.syncedItems[contentType] || [];
            this._syncResultInfo.syncedItems[contentType].push(syncInfo);

            if (syncInfo.storage == syncLocation.server) {
                this._syncResultInfo.syncedToServer++;
            } else {
                this._syncResultInfo.syncedToClient++;
            }

            this._fireItemProcessed(syncInfo);
        },

        _fireItemProcessed: function (syncInfo) {
            this._everlive._emitter.emit('itemProcessed', syncInfo);
        },

        _getClientWinsSyncData: function (collections) {
            var self = this;
            var syncData = {};
            _.each(collections, function (collection, typeName) {
                if (!syncData[typeName]) {
                    syncData[typeName] = {
                        createdItems: [],
                        modifiedItems: [],
                        deletedItems: []
                    };
                }

                var dirtyItems = self._getDirtyItems(collection);
                var itemsForSync = offlineTransformations.idTransform(dirtyItems);

                _.each(itemsForSync, function (itemForSync) {
                    switch (itemForSync[constants.offlineItemsStateMarker]) {
                        case offlineItemStates.created:
                            syncData[typeName].createdItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case offlineItemStates.modified:
                            syncData[typeName].modifiedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case offlineItemStates.deleted:
                            syncData[typeName].deletedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                    }

                    delete itemForSync[constants.offlineItemsStateMarker];
                });
            });

            return syncData;
        },

        _getModifiedFilesForSyncClientWins: function (itemId, item, collectionName) {
            var self = this;
            var sdk = self._everlive;

            return new rsvp.Promise(function (resolve, reject) {
                var offlineFiles = self.files;
                offlineFiles.getOfflineLocation(itemId)
                    .then(function (location) {
                        if (location) {
                            return self._transferFile(true, item, location)
                                .then(function (result) {
                                    if (result.Result === false) {
                                        reject({
                                            type: offlineItemStates.modified,
                                            itemId: item.Id,
                                            contentType: collectionName,
                                            error: result,
                                            storage: syncLocation.server
                                        });
                                    } else {
                                        return {
                                            result: result
                                        };
                                    }
                                }, function (err) {
                                    reject({
                                        type: offlineItemStates.modified,
                                        itemId: item.Id,
                                        contentType: collectionName,
                                        error: err,
                                        storage: syncLocation.server
                                    });
                                });
                        } else {
                            return sdk.files
                                .isSync(true)
                                .applyOffline(false)
                                .updateSingle(item)
                                .then(function (response) {
                                    return response;
                                }, function (err) {
                                    reject({
                                        type: offlineItemStates.modified,
                                        itemId: item.Id,
                                        contentType: collectionName,
                                        error: err,
                                        storage: syncLocation.server
                                    });
                                });
                        }
                    })
                    .then(function (onlineResponse) {
                        var onlineResult = onlineResponse.result;
                        item.ModifiedAt = onlineResult.ModifiedAt;
                        self._onItemProcessed(item, collectionName, syncLocation.server, offlineItemStates.modified);
                        return sdk.files
                            .isSync(true)
                            .useOffline(true)
                            .updateSingle(item);
                    })
                    .then(resolve)
                    .catch(function (err) {
                        reject({
                            type: offlineItemStates.modified,
                            itemId: item.Id,
                            contentType: collectionName,
                            error: err,
                            storage: syncLocation.server
                        });
                    });
            });
        },

        _getModifiedItemForSyncClientWins: function (dataCollection, item, collectionName) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                return dataCollection
                    .isSync(true)
                    .applyOffline(false)
                    .updateSingle(item)
                    .then(function (res) {
                        self._onItemProcessed(item, collectionName, syncLocation.server, offlineItemStates.modified);
                        var updatedItem = _.extend({}, item, {
                            ModifiedAt: res.ModifiedAt
                        });

                        var updateQuery = new DataQuery({
                            operation: DataQuery.operations.update,
                            data: updatedItem,
                            additionalOptions: {
                                id: item.Id
                            },
                            collectionName: collectionName,
                            isSync: true
                        });

                        return self.processQuery(updateQuery);
                    }, function (res) {
                        reject({
                            storage: syncLocation.server,
                            type: offlineItemStates.modified,
                            itemId: item.Id,
                            contentType: collectionName,
                            error: res
                        });
                    })
                    .then(resolve, function (err) {
                        reject({
                            storage: syncLocation.client,
                            type: offlineItemStates.modified,
                            itemId: item.Id,
                            contentType: collectionName,
                            error: err
                        });
                    });
            });
        },

        _addModifiedItemsForSyncClientWins: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addUpdatedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection, function (item) {
                var itemId = item.Id;
                if (!itemId) {
                    throw new EverliveError('When updating an item it must have an Id field.');
                }
                var collectionName = dataCollection.collectionName;

                if (utils.isContentType.files(collectionName)) {
                    syncPromises[itemId] = self._getModifiedFilesForSyncClientWins(itemId, item, collectionName);
                } else {
                    syncPromises[itemId] = self._getModifiedItemForSyncClientWins(dataCollection, item, collectionName);
                }
            });
        },

        _addDeletedItemsForSyncClientWins: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addDeletedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection,
                function (item, itemFilter) {
                    var collectionName = dataCollection.collectionName;
                    syncPromises[item.Id] = new rsvp.Promise(function (resolve, reject) {
                        var itemId = item.Id;
                        if (!itemId) {
                            throw new EverliveError('When deleting an item it must have an Id field.');
                        }

                        return dataCollection
                            .isSync(true)
                            .applyOffline(false)
                            .destroySingle(itemFilter)
                            .then(function () {
                                self._onItemProcessed(item, collectionName, syncLocation.server, offlineItemStates.deleted);
                                return self._purgeById(collectionName, item.Id).then(function () {
                                    resolve();
                                }, function (err) {
                                    reject(_.extend({}, {
                                        storage: syncLocation.client,
                                        type: offlineItemStates.deleted,
                                        contentType: collectionName,
                                        itemId: itemId,
                                        error: err
                                    }));
                                });
                            }, function (err) {
                                reject(_.extend({}, {
                                    storage: syncLocation.server,
                                    type: offlineItemStates.deleted,
                                    contentType: collectionName,
                                    error: err,
                                    itemId: itemId
                                }));
                            });
                    });
                });
        },

        _applyClientWins: function (collections) {
            var self = this;
            var syncData = this._getClientWinsSyncData(collections);
            var syncPromises = {};

            _.each(syncData, function (contentTypeData, typeName) {
                var dataCollection = self._everlive.data(typeName);
                if (contentTypeData.createdItems.length) {
                    self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.modifiedItems.length) {
                    self._addModifiedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.deletedItems.length) {
                    self._addDeletedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }
            });

            return rsvp.hashSettled(syncPromises);
        },

        _modifyFileStandardSync: function (syncPromises, itemId, item, collectionName, resolutionType) {
            var self = this;

            var filesCollection = self._everlive.files;
            syncPromises[itemId] = new rsvp.Promise(function (resolve, reject) {
                var offlineLocation;
                self.files.getOfflineLocation(itemId)
                    .then(function (locationOnDisk) {
                        offlineLocation = locationOnDisk;
                    })
                    .then(function () {
                        return filesCollection
                            .isSync(true)
                            .applyOffline(false)
                            .getById(itemId);
                    })
                    .then(function (response) {
                        var file = response.result;
                        if (file.ModifiedAt.getTime() !== item.ModifiedAt.getTime()) {
                            reject(_.extend({}, new EverliveError(EverliveErrors.syncConflict), {
                                contentType: collectionName
                            }));
                        } else {
                            if (offlineLocation) {
                                if (resolutionType === constants.ConflictResolution.KeepServer) {
                                    return self.files._saveFile(item.Uri, item.Filename, item.Id)
                                        .then(function () {
                                            return self._offlineFilesProcessor.purge(offlineLocation);
                                        })
                                        .then(function () {
                                            return response;
                                        });
                                } else if (resolutionType === constants.ConflictResolution.KeepClient) {
                                    return self._transferFile(true, item, offlineLocation);
                                }
                            }
                        }
                    })
                    .then(function () {
                        return self._everlive.files
                            .isSync(true)
                            .useOffline(true)
                            .updateSingle(item);
                    })
                    .then(resolve)
                    .catch(reject);
            });
        },

        _modifyContentTypeStandardSync: function (syncPromises, itemId, dataCollection, item, itemFilter, collectionName, isCustom) {
            var self = this;

            syncPromises[itemId] = dataCollection
                .isSync(true)
                .applyOffline(false)
                .update(item, itemFilter)
                .then(function (res) {
                    return self._onSyncResponse(res, item, collectionName, DataQuery.operations.update, isCustom);
                }, function (err) {
                    return new rsvp.Promise(function (resolve, reject) {
                        reject({
                            type: offlineItemStates.modified,
                            itemId: item.Id,
                            contentType: collectionName,
                            error: err,
                            storage: syncLocation.server
                        });
                    });
                });
        },

        _applyStandardSync: function (collections) {
            var self = this;

            var promises = {};
            _.each(collections, function (collection, contentType) {
                promises[contentType] = self._getSyncPromiseForCollection(collection, contentType);
            });

            return rsvp.hash(promises)
                .then(function (contentTypes) {
                    return self._prepareSyncData(contentTypes);
                })
                .then(function (syncData) {
                    return self._resolveConflicts(syncData);
                })
                .then(function (contentTypeSyncData) {
                    var syncPromises = {};
                    _.each(contentTypeSyncData, function (contentTypeData, collectionName) {
                        var dataCollection = self._everlive.data(collectionName);
                        if (contentTypeData.createdItems.length) {
                            self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                        }

                        if (contentTypeData.modifiedItems.length) {
                            self._addUpdatedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter, isCustom, resolutionType) {
                                var itemId = item.Id;

                                if (utils.isContentType.files(collectionName)) {
                                    self._modifyFileStandardSync(syncPromises, itemId, item, collectionName, resolutionType, isCustom);
                                } else {
                                    self._modifyContentTypeStandardSync(syncPromises, itemId, dataCollection, item, itemFilter, collectionName, isCustom);
                                }
                            });
                        }

                        if (contentTypeData.deletedItems.length) {
                            self._addDeletedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter, isCustom) {
                                syncPromises[item.Id] = dataCollection
                                    .isSync(true)
                                    .applyOffline(false)
                                    .destroy(itemFilter)
                                    .then(function (res) {
                                        return self._onSyncResponse(res, item, collectionName, DataQuery.operations.remove, isCustom);
                                    }, function (err) {
                                        return new rsvp.Promise(function (resolve, reject) {
                                            reject({
                                                type: offlineItemStates.deleted,
                                                itemId: item.Id,
                                                contentType: collectionName,
                                                error: err,
                                                storage: syncLocation.server
                                            });
                                        });
                                    });
                            });
                        }
                    });

                    return rsvp.hashSettled(syncPromises);
                });
        },

        _applySync: function () {
            var self = this;

            return this._queryProcessor._getAllCollections()
                .then(function (collections) {
                    if (self.setup.conflicts.strategy === constants.ConflictResolutionStrategy.ClientWins) {
                        return self._applyClientWins(collections);
                    } else {
                        return self._applyStandardSync(collections);
                    }
                });
        },

        /**
         * Get all the offline items that have not been synced online.
         * @method getItemsForSync
         * @name getItemsForSync
         * @memberOf OfflineModule.prototype
         * @param {function} [success] A success callback.
         * @param {function} [error] An error callback.
         */
        /**
         * Get all the offline items that have not been synced online.
         * @method getItemsForSync
         * @name getItemsForSync
         * @memberOf OfflineModule.prototype
         * @returns Promise
         */
        getItemsForSync: function (success, error) {
            var self = this;
            var dirtyItemsForSync = {};
            return buildPromise(function (successCb, errorCb) {
                self._queryProcessor._getAllCollections()
                    .then(function (collections) {
                        _.each(collections, function (collection, collectionName) {
                            var dirtyItems = self._getDirtyItems(collection);
                            dirtyItemsForSync[collectionName] = _.map(dirtyItems, function (item) {
                                var itemForSync = {
                                    item: _.extend({}, item),
                                    action: item[constants.offlineItemsStateMarker]
                                };

                                delete itemForSync.item[constants.offlineItemsStateMarker];
                                return itemForSync;
                            });
                        });

                        successCb(dirtyItemsForSync);
                    }).catch(errorCb);
            }, success, error);
        }
    };

    return OfflineModule;
})();

},{"../EverliveError":42,"../Request":47,"../common":53,"../constants":54,"../query/DataQuery":80,"../query/RequestOptionsBuilder":83,"../utils":94,"./OfflineFilesModule":67,"./OfflineFilesProcessor":68,"./OfflineQueryProcessor":69,"./offlineTransformations":73,"path":4}],71:[function(require,module,exports){
var constants = require('../constants');
var persisters = require('./offlinePersisters');
var LocalStoragePersister = persisters.LocalStoragePersister;
var FileSystemPersister = persisters.FileSystemPersister;
var OfflineStorageModule = require('./OfflineStorageModule');
var EverliveError = require('../EverliveError').EverliveError;
var isNativeScript = require('../everlive.platform').isNativeScript;
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var CryptographicProvider = require('../encryption/CryptographicProvider');

var defaultOfflineStorageOptions = {
    autoSync: true,
    enabled: true,
    conflicts: {
        strategy: constants.ConflictResolutionStrategy.ClientWins,
        implementation: null
    },
    offline: false,
    storage: {
        name: '',
        provider: isNativeScript ? constants.StorageProvider.FileSystem : constants.StorageProvider.LocalStorage,
        implementation: null,
        storagePath: constants.DefaultStoragePath
    },
    typeSettings: {},
    encryption: {
        provider: constants.EncryptionProvider.Default,
        implementation: null,
        key: ''
    },
    files: {
        storagePath: constants.DefaultFilesStoragePath,
        metaPath: constants.DefaultFilesMetadataPath,
        maxConcurrentDownloads: constants.MaxConcurrentDownloadTasks
    }
};

module.exports = (function () {

    var conflictResolutionStrategies = {};

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ClientWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(local);
        });
    };

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ServerWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(server);
        });
    };

    var initStoragePersister = function initStoragePersister(options) {
        var storageKey = options.storage.name || 'everliveOfflineStorage_' + this.setup.apiKey;
        var persister = persisters.getPersister(storageKey, options);
        options.storage.implementation = persister;
        return persister;
    };

    var initEncryptionProvider = function initEncryptionProvider(options) {
        var encryptor;
        var encryptionProvider = options.encryption.provider;
        var encryptionImplementation = options.encryption.implementation;
        if (_.isObject(encryptionImplementation) && encryptionProvider === constants.EncryptionProvider.Custom) {
            encryptor = encryptionImplementation;
        } else {
            switch (encryptionProvider) {
                case constants.EncryptionProvider.Default:
                    encryptor = new CryptographicProvider(options);
                    break;
                case constants.EncryptionProvider.Custom:
                    throw new EverliveError('Custom encryption provider requires an implementation object');
                default:
                    throw new EverliveError('Unsupported encryption provider ' + encryptionProvider);
            }
        }

        options.encryption.implementation = encryptor;
        return encryptor;
    };

    function buildOfflineStorageOptions(sdkOptions) {
        var storageOptions = sdkOptions.offline || sdkOptions.offlineStorage;
        var options;
        if (storageOptions === true) { // explicit check for shorthand initialization
            options = _.defaults({}, defaultOfflineStorageOptions);
        } else if (_.isObject(storageOptions)) {
            options = _.defaults(storageOptions, defaultOfflineStorageOptions);
            options.storage = _.defaults(storageOptions.storage, defaultOfflineStorageOptions.storage);
            options.encryption = _.defaults(storageOptions.encryption, defaultOfflineStorageOptions.encryption);
            options.conflicts = _.defaults(storageOptions.conflicts, defaultOfflineStorageOptions.conflicts);
            options.files = _.defaults(storageOptions.files, defaultOfflineStorageOptions.files);
        } else {
            options = _.defaults({}, defaultOfflineStorageOptions);
            options.enabled = false;
            if (!storageOptions) {
                sdkOptions.offlineStorage = options;
            }
        }

        options.cacheEnabled = sdkOptions.caching && sdkOptions.caching.enabled;
        return options;
    }

    var buildOfflineStorageModule = function buildOfflineStorageModule(sdkOptions) {
        var options = buildOfflineStorageOptions(sdkOptions);
        var persister = initStoragePersister.call(this, options);
        var encryptionProvider = initEncryptionProvider.call(this, options);

        return new OfflineStorageModule(this, options, persister, encryptionProvider);
    };

    var initOfflineStorage = function (options) {
        this.offlineStorage = buildOfflineStorageModule.call(this, options);
    };

    return {
        initOfflineStorage: initOfflineStorage,
        buildOfflineStorageOptions: buildOfflineStorageOptions
    }
}());
},{"../EverliveError":42,"../common":53,"../constants":54,"../encryption/CryptographicProvider":55,"../everlive.platform":56,"./OfflineStorageModule":70,"./offlinePersisters":72}],72:[function(require,module,exports){
var BasePersister = require('./persisters/BasePersister');
var LocalStoragePersister = require('./persisters/LocalStoragePersister');
var FileSystemPersister = require('./persisters/FileSystemPersister');
var constants = require('../constants');
var EverliveError = require('../EverliveError').EverliveError;
var _ = require('../common')._;

module.exports = {
    BasePersister: BasePersister,
    LocalStoragePersister: LocalStoragePersister,
    FileSystemPersister: FileSystemPersister,
    getPersister: function (storageKey, options) {
        var persister;

        var storageProvider = options.storage.provider;
        var storageProviderImplementation = options.storage.implementation;
        if (_.isObject(storageProviderImplementation) && storageProvider === constants.StorageProvider.Custom) {
            persister = storageProviderImplementation;
        } else {
            switch (storageProvider) {
                case constants.StorageProvider.LocalStorage:
                    persister = new LocalStoragePersister(storageKey, options);
                    break;
                case constants.StorageProvider.FileSystem:
                    persister = new FileSystemPersister(storageKey, options);
                    break;
                case constants.StorageProvider.Custom:
                    throw new EverliveError('Custom storage provider requires an implementation object');
                default:
                    throw new EverliveError('Unsupported storage type ' + storageProvider);
            }
        }

        return persister;
    }
};
},{"../EverliveError":42,"../common":53,"../constants":54,"./persisters/BasePersister":74,"./persisters/FileSystemPersister":75,"./persisters/LocalStoragePersister":76}],73:[function(require,module,exports){
'use strict';

var constants = require('../constants');
var _ = require('../common')._;
var offlineItemStateMarker = constants.offlineItemsStateMarker;

var traverseAndApply = function (value, operation, additionalOptions) {
    if (_.isArray(value)) {
        return _.map(value, function (item) {
            return operation(item, additionalOptions);
        });
    } else {
        return operation(value, additionalOptions);
    }
};

var idTransformation = function (value) {
    if (typeof value === 'object' && value._id && !value.Id) {
        value.Id = value._id;
        delete value._id;
    }

    return value;
};

var removeIdTransform = function (value, opts) {
    var verifyStateCreated = opts.verifyStateCreated;
    var shouldModifyObject = verifyStateCreated ? value[constants.offlineItemsStateMarker] === constants.offlineItemStates.created : true;
    if (typeof value === 'object' && (value._id || value.Id) && shouldModifyObject) {
        delete value._id;
        delete value.Id;
    }

    return value;
};

var removeMarkerTransform = function (value) {
    delete value[offlineItemStateMarker];
    return value;
};

var offlineTransformations = {
    removeIdTransform: function (value, verifyStateCreated) {
        return traverseAndApply(value, removeIdTransform, {verifyStateCreated: verifyStateCreated});
    },
    idTransform: function (value) {
        return traverseAndApply(value, idTransformation);
    },
    singleFieldTransform: function (singleFieldExpression, value) {
        if (typeof value === 'undefined' || value === null) {
            return null;
        } else {
            return value[singleFieldExpression];
        }
    },
    traverseAndTransformFilterId: function (filterObj) {
        if (filterObj && filterObj.Id) {
            filterObj._id = filterObj.Id;
            delete filterObj.Id;
        }

        for (var prop in filterObj) {
            if (filterObj.hasOwnProperty(prop)) {
                var objectMember = filterObj[prop];
                if (typeof objectMember === 'object') {
                    offlineTransformations.traverseAndTransformFilterId(objectMember);
                }
            }
        }
    },
    removeMarkersTransform: function (value) {
        return traverseAndApply(value, removeMarkerTransform);
    },
    removeFieldsTransform: function (value, fields) {
        _.each(fields, function (field) {
            delete value[field];
        });

        return value;
    }
};

module.exports = offlineTransformations;
},{"../common":53,"../constants":54}],74:[function(require,module,exports){
'use strict';

var EverliveError = require('../../EverliveError').EverliveError;
var utils = require('../../utils');
var common = require('../../common');
var _ = common._;
var rsvp = common.rsvp;

var BasePersister = (function () {

    /**
     * @class BasePersister
     * @classdesc An abstraction layer for all persisters. Every persister can write/read
     * data to/from a specific place. The data is saved as key-value pairs where the keys are
     * content types.
     */
    function BasePersister(key, options) {
        this.key = key;
        this.options = options;
        this.contentTypesStoreKey = this.key + '@ContentTypes';
    }

    BasePersister.prototype = {
        /**
         * Gets all the saved data.
         * @method getAllData
         * @memberof BasePersister
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @returns {Object} The keys are the content types and the values are the corresponding data items.
         */
        getAllData: function (success, error) {
            var self = this;
            var promises = {};
            this._getContentTypes(function (contentTypes) {
                _.each(contentTypes, function (contentType) {
                    promises[contentType] = new rsvp.Promise(function (resolve, reject) {
                        self.getData(contentType, resolve, reject);
                    });
                });

                rsvp.hash(promises)
                    .then(success)
                    .catch(error);
            }, error);
        },

        /**
         * Returns the saved data for a specific content type.
         * @method getData
         * @param {string} contentType The content type for which to retrieve the data.
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @memberof BasePersister
         * @returns {string} The retrieved data.
         */
        getData: function (contentType, success, error) {
            throw new EverliveError('The method getData is not implemented');
        },

        /**
         * Saves data for a specific content type.
         * @method saveData
         * @param {string} contentType The content for which to save the data.
         * @param {string} data The data corresponding to the specified content type.
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @memberof BasePersister
         */
        saveData: function (contentType, data, success, error) {
            throw new EverliveError('The method saveData is not implemented');
        },

        /**
         * Clears the persisted data for a specific content type.
         * @method purge
         * @param {string} contentType The content type for which to clear the data.
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @memberof BasePersister
         */
        purge: function (contentType, success, error) {
            throw new EverliveError('The method clear is not implemented');
        },

        /**
         * Clears all persisted data in the offline store.
         * @method purgeAll
         * @memberof BasePersister
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         */
        purgeAll: function (success, error) {
            throw new EverliveError('The method clearAll is not implemented');
        },

        _getKey: function (contentType) {
            return this.key + '_' + contentType;
        },

        _getContentTypes: function (success, error) {
            throw new EverliveError('The method _getContentTypes is not implemented');
        }
    };

    return BasePersister;
}());

module.exports = BasePersister;
},{"../../EverliveError":42,"../../common":53,"../../utils":94}],75:[function(require,module,exports){
'use strict';

var FileStore = require('../../storages/FileStore');
var BasePersister = require('./BasePersister');
var EverliveError = require('../../EverliveError').EverliveError;
var common = require('../../common');
var _ = common._;
var platform = require('../../everlive.platform');
var rsvp = common.rsvp;
var util = require('util');
var path = require('path');
var utils = require('../../utils');

var FileSystemPersister = (function () {
    /**
     * @class FileSystemPersister
     * @protected
     * @extends BasePersister
     */
    function FileSystemPersister(key, options) {
        BasePersister.apply(this, arguments);
        this.fileStore = new FileStore(options.storage.storagePath, options);
    }

    util.inherits(FileSystemPersister, BasePersister);

    FileSystemPersister.prototype.getAllData = function (success, error) {
        var errorHandler = this._fileSystemErrorHandler(error);
        FileSystemPersister.super_.prototype.getAllData.call(this, success, errorHandler);
    };

    FileSystemPersister.prototype.getData = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this.getFileHandle(contentType, function (fileEntry) {
            self._readFileContent(fileEntry, success, errorHandler);
        }, error);
    };

    FileSystemPersister.prototype.saveData = function (contentType, data, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this.getFileHandle(contentType, function (fileEntry) {
            self._writeFileContent(fileEntry, data, function () {
                self._saveContentTypes(contentType, success, errorHandler);
            }, errorHandler);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purge = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this.getFileHandle(contentType, function (fileEntry) {
            self.fileStore.removeFile(fileEntry).then(function () {
                success();
            }).catch(error);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purgeAll = function (success, error) {
        var errorHandler = this._fileSystemErrorHandler(error);
        this.fileStore.removeFilesDirectory()
            .then(function () {
                success();
            })
            .catch(errorHandler);
    };

    FileSystemPersister.prototype._getContentTypes = function (success, error) {
        this.getData(this.contentTypesStoreKey, function (savedContentTypesRaw) {
            var savedContentTypes = JSON.parse(savedContentTypesRaw || '[]');
            success(savedContentTypes);
        }, error);
    };

    FileSystemPersister.prototype._saveContentTypes = function (contentType, success, error) {
        var self = this;
        this._getContentTypes(function (savedContentTypes) {
            if (!_.contains(savedContentTypes, contentType)) {
                savedContentTypes.push(contentType);
            }

            self.getFileHandle(self.contentTypesStoreKey, function (contentTypesFile) {
                self._writeFileContent(contentTypesFile, JSON.stringify(savedContentTypes), success, error);
            }, error);
        });
    };

    FileSystemPersister.prototype.getFileHandle = function (contentType, success, error) {
        var self = this;
        var path = self._getFilePath(contentType);
        this.fileStore.getFilesDirectory()
            .then(function () {
                return self.fileStore.getFile(path);
            })
            .then(function (fileHandle) {
                success(fileHandle);
            })
            .catch(error);
    };

    FileSystemPersister.prototype._readFileContent = function (fileEntry, success, error) {
        this.fileStore.readFileAsText(fileEntry).then(function (content) {
            success(content);
        }).catch(error);
    };

    FileSystemPersister.prototype._writeFileContent = function (fileEntry, content, success, error) {
        this.fileStore.writeTextToFile(fileEntry, content)
            .then(success)
            .catch(error);
    };

    FileSystemPersister.prototype._getFilePath = function (contentType) {
        return this._getKey(contentType);
        //return utils.joinPath(this.fileStore.filesDirectoryPath, this._getKey(contentType));
    };

    FileSystemPersister.prototype._fileSystemErrorHandler = function (callback) {
        return this.fileStore.getErrorHandler(callback);
    };

    return FileSystemPersister;
}());

module.exports = FileSystemPersister;
},{"../../EverliveError":42,"../../common":53,"../../everlive.platform":56,"../../storages/FileStore":87,"../../utils":94,"./BasePersister":74,"path":4,"util":7}],76:[function(require,module,exports){
'use strict';

var common = require('../../common');
var _ = common._;
var rsvp = common.rsvp;
var util = require('util');
var LocalStore = require('../../storages/LocalStore');
var BasePersister = require('./BasePersister');

var LocalStoragePersister = (function () {

    /**
     * @class LocalStoragePersister
     * @extends BasePersister
     */
    function LocalStoragePersister(key, options) {
        BasePersister.apply(this, arguments);
        this._localStore = new LocalStore(options);
    }

    util.inherits(LocalStoragePersister, BasePersister);

    LocalStoragePersister.prototype.getData = function (contentType, success, error) {
        try {
            var key = this._getKey(contentType);
            var storedItem = this._getItem(key);
            success(storedItem);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.saveData = function (contentType, data, success, error) {
        try {
            var contentTypeKey = this._getKey(contentType);
            this._setItem(contentTypeKey, data);
            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purge = function (contentType, success, error) {
        var self = this;

        try {
            var key = this._getKey(contentType);
            this._removeItem(key);
            this._getContentTypes(function (contentTypes) {
                contentTypes = _.without(contentTypes, contentType);
                self._setContentTypesCollection(contentTypes);
                success();
            }, error);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purgeAll = function (success, error) {
        try {
            var self = this;

            this._getContentTypes(function (contentTypes) {
                _.each(contentTypes, function (contentType) {
                    var contentTypeKey = self._getKey(contentType);
                    self._removeItem(contentTypeKey);
                });

                self._removeItem(self.contentTypesStoreKey);
                success();
            }, error);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype._getItem = function (key) {
        return this._localStore.getItem(key);
    };

    LocalStoragePersister.prototype._setItem = function (key, value) {
        return this._localStore.setItem(key, value);
    };

    LocalStoragePersister.prototype._removeItem = function (key) {
        return this._localStore.removeItem(key);
    };

    LocalStoragePersister.prototype._getKey = function (contentType) {
        this._addTypeToCollectionsCache(contentType);
        return LocalStoragePersister.super_.prototype._getKey.apply(this, arguments);
    };

    LocalStoragePersister.prototype._getContentTypes = function (success, error) {
        try {
            var localStorageString = this._getItem(this.contentTypesStoreKey);

            var data = [];
            if (localStorageString) {
                data = JSON.parse(localStorageString);
            }

            success(data);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype._setContentTypesCollection = function (collection) {
        this._setItem(this.contentTypesStoreKey, JSON.stringify(collection));
    };

    LocalStoragePersister.prototype._addTypeToCollectionsCache = function (typeName) {
        var self = this;
        this._getContentTypes(function (contentTypes) {
            if (!_.contains(contentTypes, typeName)) {
                contentTypes.push(typeName);
                self._setContentTypesCollection(contentTypes);
            }
        });
    };

    return LocalStoragePersister;
}());

module.exports = LocalStoragePersister;
},{"../../common":53,"../../storages/LocalStore":88,"./BasePersister":74,"util":7}],77:[function(require,module,exports){
var buildPromise = require('../utils').buildPromise;
var EverliveError = require('../EverliveError').EverliveError;
var Platform = require('../constants').Platform;
var common = require('../common');
var jstz = common.jstz;
var _ = common._;

module.exports = (function () {
    /**
     * @class CurrentDevice
     * @deprecated
     * @protected
     * @param pushHandler
     * @constructor
     */
    var CurrentDevice = function (pushHandler) {

        if (!window.cordova) {
                throw new EverliveError('Error: currentDevice() can only be called from within a hybrid mobile app, after \'deviceready\' event has been fired.');
        }

        this._pushHandler = pushHandler;
        this._initSuccessCallback = null;
        this._initErrorCallback = null;

        //Suffix for the global callback functions
        this._globalFunctionSuffix = null;

        this.pushSettings = null;
        this.pushToken = null;
        this.isInitialized = false;
        this.isInitializing = false;

        this.emulatorMode = false;
    };

    CurrentDevice.ensurePushIsAvailable = function() {
        var isPushNotificationPluginAvailable = (typeof window !== 'undefined' && window.plugins && window.plugins.pushNotification);

        if (!isPushNotificationPluginAvailable) {
            throw new EverliveError("The push notification plugin is not available. Ensure that the pushNotification plugin is included " +
            "and use after `deviceready` event has been fired.");
        }

    };

    CurrentDevice.prototype = {

        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @returns {Object} The promise for the request.
         */
        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        enableNotifications: function (pushSettings, success, error) {
            this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);

            return buildPromise(_.bind(this._initialize, this), success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @returns {Object} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        disableNotifications: function (success, error) {
            var self = this;

            return this.unregister().then(
                function () {
                    return buildPromise(
                        function (success, error) {
                            if (self.emulatorMode) {
                                success();
                            } else {
                                var pushNotification = window.plugins.pushNotification;
                                var unregisterOptions;
                                var platformType = self._getPlatformType();
                                if (platformType === Platform.WindowsPhone) {
                                    unregisterOptions = {'channelName': self.pushSettings.wp8.channelName};
                                }
                                pushNotification.unregister(
                                    function () {
                                        self.isInitialized = false;
                                        success();
                                    },
                                    error,
                                    unregisterOptions
                                );
                            }
                        },
                        success,
                        error
                    );
                },
                error
            );
        },

        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @returns {Object} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @param {Function} success Callback to invoke on success.
         * @param {Function} error Callback to invoke on error.
         */
        getRegistration: function (success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
        },

        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @returns {Object} The promise for the request.
         */
        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    return self._pushHandler.devices.create(deviceRegistration, success, error);
                },
                error
            );
        },

        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @returns {Object} The promise for the request.
         */
        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        unregister: function (success, error) {
            var deviceId = encodeURIComponent(device.uuid);
            return this._pushHandler.devices.destroySingle({Id: 'HardwareId/' + deviceId}, success, error);
        },

        /**
         * Updates the registration of the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @returns {Object} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
                    return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
                },
                error
            );
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function (options, onSuccess, onError) {
            options = options || {};
            var pushNotification = window.plugins.pushNotification;

            return buildPromise(function (successCb, errorCb) {
                pushNotification.areNotificationsEnabled(successCb, errorCb, options);
            }, onSuccess, onError);
        },

        _initializeInteractivePush: function (iOSSettings, success, error) {
            var pushPlugin = window.plugins.pushNotification;

            var interactiveSettings = iOSSettings.interactiveSettings;
            var notificationTypes = [];
            if (iOSSettings.alert) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Alert);
            }
            if (iOSSettings.badge) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Badge);
            }
            if (iOSSettings.sound) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Sound);
            }

            var getAction = function (actionIdentifier) {
                var action = _.find(interactiveSettings.actions, function (action) {
                    return action.identifier === actionIdentifier;
                });

                return action;
            };
            var categories = _.map(interactiveSettings.categories, function (category) {
                return {
                    identifier: category.identifier,
                    actionsForDefaultContext: _.map(category.actionsForDefaultContext, getAction),
                    actionsForMinimalContext: _.map(category.actionsForMinimalContext, getAction)
                }
            });

            pushPlugin.registerUserNotificationSettings(
                // the success callback which will immediately return (APNs is not contacted for this)
                success,
                // called in case the configuration is incorrect
                error, {
                    // asking permission for these features
                    types: notificationTypes,
                    // register these categories
                    categories: categories
                }
            );
        },

        //Initializes the push functionality on the device.
        _initialize: function (success, error) {
            var self = this;

            if (this.isInitializing) {
                error(new EverliveError('Push notifications are currently initializing.'));
                return;
            }

            if (!this.emulatorMode && (!window.navigator || !window.navigator.globalization)) {
                error(new EverliveError('The globalization plugin is not initialized.'));
                return;
            }

            if (!this.emulatorMode && (!window.plugins || !window.plugins.pushNotification)) {
                error(new EverliveError('The push notifications plugin is not initialized.'));
                return;
            }

            this._initSuccessCallback = success;
            this._initErrorCallback = error;

            if (this.isInitialized) {
                this._deviceRegistrationSuccess(this.pushToken);
                return;
            }

            if (this.emulatorMode) {
                setTimeout(
                    function () {
                        self._deviceRegistrationSuccess('fake_push_token');
                    },
                    1000
                );
                return;
            }

            this.isInitializing = true;

            var suffix = this._globalFunctionSuffix;
            if (!suffix) {
                suffix = Date.now().toString();
                this._globalFunctionSuffix = suffix;
            }

            var pushNotification = window.plugins.pushNotification;

            var platformType = this._getPlatformType();
            if (platformType === Platform.iOS) {
                //Initialize global APN callback
                var apnCallbackName = 'apnCallback_' + suffix;
                Everlive.PushCallbacks[apnCallbackName] = _.bind(this._onNotificationAPN, this);

                //Construct registration options object and validate iOS settings
                var apnRegistrationOptions = this.pushSettings.iOS;
                apnRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + apnCallbackName;

                //Register for APN
                pushNotification.register(
                    _.bind(this._successfulRegistrationAPN, this),
                    _.bind(this._failedRegistrationAPN, this),
                    apnRegistrationOptions
                );
            } else if (platformType === Platform.Android) {
                //Initialize global GCM callback
                var gcmCallbackName = 'gcmCallback_' + suffix;
                Everlive.PushCallbacks[gcmCallbackName] = _.bind(this._onNotificationGCM, this);

                //Construct registration options object and validate the Android settings
                var gcmRegistrationOptions = this.pushSettings.android;
                this._validateAndroidSettings(gcmRegistrationOptions);
                gcmRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + gcmCallbackName;

                //Register for GCM
                pushNotification.register(
                    _.bind(this._successSentRegistrationGCM, this),
                    _.bind(this._errorSentRegistrationGCM, this),
                    gcmRegistrationOptions
                );
            } else if (platformType === Platform.WindowsPhone) {
                //Initialize global WP8 callbacks.
                var wp8CallbackName = 'wp8Callback_' + suffix;
                var wp8RegistrationSuccessCallbackName = 'wp8RegistrationSuccessCallback_' + suffix;
                var wp8RegistrationErrorCallbackName = 'wp8RegistrationErrorCallback_' + suffix;

                Everlive.PushCallbacks[wp8CallbackName] = _.bind(this._onNotificationWP8, this);
                Everlive.PushCallbacks[wp8RegistrationSuccessCallbackName] = _.bind(this._deviceRegistrationSuccessWP, this);
                Everlive.PushCallbacks[wp8RegistrationErrorCallbackName] = _.bind(this._deviceRegistrationFailed, this);

                //Construct registration options object and validate the WP8  settings
                var wp8RegistrationOptions = this.pushSettings.wp8;
                this._validateWP8Settings(wp8RegistrationOptions);
                wp8RegistrationOptions.ecb = 'Everlive.PushCallbacks.' + wp8CallbackName;
                wp8RegistrationOptions.uccb = 'Everlive.PushCallbacks.' + wp8RegistrationSuccessCallbackName;
                wp8RegistrationOptions.errcb = 'Everlive.PushCallbacks.' + wp8RegistrationErrorCallbackName;


                pushNotification.register(
                    _.bind(this._successSentRegistrationWP8, this),
                    _.bind(this._errorSentRegistrationWP8, this),
                    wp8RegistrationOptions
                );

            } else {
                throw new EverliveError('The current platform is not supported: ' + device.platform);
            }
        },

        _deviceRegistrationSuccessWP: function (result) {
            this._deviceRegistrationSuccess(result.uri);
        },

        _validateAndroidSettings: function (androidSettings) {
            if (!androidSettings.senderID) {
                throw new EverliveError('Sender ID (project number) is not set in the android settings.');
            }
        },

        _validateWP8Settings: function (settings) {
            if (!settings.channelName) {
                throw new EverliveError('channelName is not set in the WP8 settings.');
            }
        },

        _cleanPlatformsPushSettings: function (pushSettings) {
            var cleanSettings = {};
            pushSettings = pushSettings || {};

            var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
                if (!pushSettings[platform]) {
                    return;
                }

                newSettingsObject[platform] = newSettingsObject[platform] || {};
                var newPlatformSettings = pushSettings[platform];
                var settings = newSettingsObject[platform];
                _.each(allowedFields, function (allowedField) {
                    if (newPlatformSettings.hasOwnProperty(allowedField)) {
                        settings[allowedField] = newPlatformSettings[allowedField];
                    }
                });
            };

            addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
            addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);
            addSettingsForPlatform(cleanSettings, 'wp8', ['channelName']);

            var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS', 'notificationCallbackWP8'];
            _.each(callbackFields, function (callbackField) {
                var callback = pushSettings[callbackField];
                if (callback) {
                    if (typeof callback !== 'function') {
                        throw new EverliveError('The "' + callbackField + '" of the push settings should be a function');
                    }

                    cleanSettings[callbackField] = pushSettings[callbackField];
                }
            });

            if (pushSettings.customParameters) {
                cleanSettings.customParameters = pushSettings.customParameters;
            }

            return cleanSettings;
        },

        _populateRegistrationObject: function (deviceRegistration, success, error) {
            var self = this;

            return buildPromise(
                function (success, error) {
                    if (!self.pushToken) {
                        throw new EverliveError('Push token is not available.');
                    }

                    self._getLocaleName(
                        function (locale) {
                            var deviceId = self._getDeviceId();
                            var hardwareModel = device.model;
                            var platformType = self._getPlatformType();
                            var timeZone = jstz.determine().name();
                            var pushToken = self.pushToken;
                            var language = locale.value;
                            var platformVersion = device.version;

                            deviceRegistration.HardwareId = deviceId;
                            deviceRegistration.HardwareModel = hardwareModel;
                            deviceRegistration.PlatformType = platformType;
                            deviceRegistration.PlatformVersion = platformVersion;
                            deviceRegistration.TimeZone = timeZone;
                            deviceRegistration.PushToken = pushToken;
                            deviceRegistration.Locale = language;

                            success();
                        },
                        error
                    );
                },
                success,
                error
            );
        },

        _getLocaleName: function (success, error) {
            if (this.emulatorMode) {
                success({value: 'en_US'});
            } else {
                navigator.globalization.getLocaleName(
                    function (locale) {
                        success(locale);
                    },
                    error
                );
                navigator.globalization.getLocaleName(
                    function (locale) {
                    },
                    error
                );
            }
        },

        _getDeviceId: function () {
            return device.uuid;
        },

        //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
        _getPlatformType: function () {
            var psLower = device.platform.toLowerCase();
            switch (psLower) {
                case 'ios':
                case 'iphone':
                case 'ipad':
                    return Platform.iOS;
                case 'android':
                    return Platform.Android;
                case 'wince':
                    return Platform.WindowsPhone;
                case 'win32nt': // real wp8 devices return this string as platform identifier.
                    return Platform.WindowsPhone;
                default:
                    return Platform.Unknown;
            }
        },

        _deviceRegistrationFailed: function (error) {
            this.pushToken = null;
            this.isInitializing = false;
            this.isInitialized = false;

            if (this._initErrorCallback) {
                this._initErrorCallback({error: error});
            }
        },

        _deviceRegistrationSuccess: function (token) {
            this.pushToken = token;
            this.isInitializing = false;
            this.isInitialized = true;

            if (this._initSuccessCallback) {
                this._initSuccessCallback({token: token});
            }
        },

        //Occurs when the device registration in APN succeeds
        _successfulRegistrationAPN: function (token) {
            var self = this;
            if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
                this._initializeInteractivePush(
                    this.pushSettings.iOS,
                    function () {
                        self._deviceRegistrationSuccess(token);
                    },
                    function (err) {
                        throw new EverliveError('The interactive push configuration is incorrect: ' + err);
                    }
                );
            } else {
                this._deviceRegistrationSuccess(token);
            }
        },

        //Occurs if the device registration in APN fails
        _failedRegistrationAPN: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when device registration has been successfully sent to GCM
        _successSentRegistrationGCM: function (id) {
            //console.log("Successfully sent request for registering with GCM.");
        },
        //Occurs when device registration has been successfully sent for WP8
        _successSentRegistrationWP8: function (id) {
            //console.log("Successfully sent request for registering WP8 .");
        },
        //Occurs when an error occured when sending registration request for WP8
        _errorSentRegistrationWP8: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when an error occured when sending registration request to GCM
        _errorSentRegistrationGCM: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //This function receives all notification events from APN
        _onNotificationAPN: function (e) {
            this._raiseNotificationEventIOS(e);
        },
        //This function receives all notification events for WP8
        _onNotificationWP8: function (e) {
            this._raiseNotificationEventWP8(e);
        },

        //This function receives all notification events from GCM
        _onNotificationGCM: function onNotificationGCM(e) {
            switch (e.event) {
                case 'registered':
                    if (e.regid.length > 0) {
                        this._deviceRegistrationSuccess(e.regid);
                    }
                    break;
                case 'message':
                    this._raiseNotificationEventAndroid(e);
                    break;
                case 'error':
                    if (!this.pushToken) {
                        this._deviceRegistrationFailed(e);
                    } else {
                        this._raiseNotificationEventAndroid(e);
                    }
                    break;
                default:
                    this._raiseNotificationEventAndroid(e);
                    break;
            }
        },

        _raiseNotificationEventAndroid: function (e) {
            if (this.pushSettings.notificationCallbackAndroid) {
                this.pushSettings.notificationCallbackAndroid(e);
            }
        },
        _raiseNotificationEventIOS: function (e) {
            if (this.pushSettings.notificationCallbackIOS) {
                this.pushSettings.notificationCallbackIOS(e);
            }
        },
        _raiseNotificationEventWP8: function (e) {
            if (this.pushSettings.notificationCallbackWP8) {
                this.pushSettings.notificationCallbackWP8(e);
            }
        }
    };

    return CurrentDevice;
}());

},{"../EverliveError":42,"../common":53,"../constants":54,"../utils":94}],78:[function(require,module,exports){
var platform = require('../everlive.platform');
var _ = require('../common')._;

'use strict';

if (platform.isNativeScript) {
	var NativeScriptCurrentDevice = require('./NativeScriptCurrentDevice');
    module.exports = NativeScriptCurrentDevice;
} else if (platform.isCordova || platform.isDesktop) {
	var CordovaCurrentDevice = require('./CordovaCurrentDevice');
    module.exports = CordovaCurrentDevice;
} else {
    module.exports = _.noop;
}
},{"../common":53,"../everlive.platform":56,"./CordovaCurrentDevice":77,"./NativeScriptCurrentDevice":79}],79:[function(require,module,exports){
var buildPromise = require('../utils').buildPromise;
var EverliveError = require('../EverliveError').EverliveError;
var Platform = require('../constants').Platform;
var common = require('../common');
var jstz = common.jstz;
var _ = common._;
var tnsPushPlugin = require('nativescript-push-notifications');
var tnsPlatform = require('platform');

module.exports = (function () {
    /**
     * @class CurrentDevice
     * @deprecated
     * @protected
     * @param pushHandler
     * @constructor
     */
    var CurrentDevice = function (pushHandler) {
        this._pushHandler = pushHandler;
        this._initSuccessCallback = null;
        this._initErrorCallback = null;

        //Suffix for the global callback functions
        this._globalFunctionSuffix = null;

        this.pushSettings = null;
        this.pushToken = null;
        this.isInitialized = false;
        this.isInitializing = false;

        this.emulatorMode = false;
    };

    CurrentDevice.ensurePushIsAvailable = function() {
        // NativeScript will throw an error when the TNS Push Plugin cannot be required. So this is actually unreachable.
    };

    CurrentDevice.prototype = {

        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @returns {Object} The promise for the request.
         */
        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        enableNotifications: function (pushSettings, success, error) {
            this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);

            return buildPromise(_.bind(this._initialize, this), success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @returns {Object} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        disableNotifications: function (successCb, errorCb) {
            var self = this;

            return this.unregister().then(
                function () {
                    return buildPromise(
                        function (success, error) {
                            var successCallback = function successCallback() {
                                    self.isInitialized = false;
                                    success();
                                };


                            var platformType = self._getPlatformType();
                            if(platformType === Platform.Android) {
                                return tnsPushPlugin.unregister(successCallback, error, self.pushSettings.android);
                            }

                            tnsPushPlugin.unregister(successCallback, error);
                        },
                        successCb,
                        errorCb
                    );
                },
                errorCb
            );
        },

        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @returns {Object} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @param {Function} success Callback to invoke on success.
         * @param {Function} error Callback to invoke on error.
         */
        getRegistration: function (success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
        },

        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @returns {Object} The promise for the request.
         */
        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    return self._pushHandler.devices.create(deviceRegistration, success, error);
                },
                error
            );
        },

        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @returns {Object} The promise for the request.
         */
        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        unregister: function (success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.destroySingle({Id: 'HardwareId/' + deviceId}, success, error);
        },

        /**
         * Updates the registration of the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @returns {Object} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
                    return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
                },
                error
            );
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function (options, onSuccess, onError) {
            options = options || {};
            
            return buildPromise(function (successCb, errorCb) {
                tnsPushPlugin.areNotificationsEnabled(successCb, errorCb, options);
            }, onSuccess, onError);
        },

        _initializeInteractivePush: function (iOSSettings, success, error) {
            tnsPushPlugin.registerUserNotificationSettings(
                // the success callback which will immediately return (APNs is not contacted for this)
                success,
                // called in case the configuration is incorrect
                error
            );
        },

        //Initializes the push functionality on the device.
        _initialize: function (success, error) {
            if (this.isInitializing) {
                error(new EverliveError('Push notifications are currently initializing.'));
                return;
            }

            this._initSuccessCallback = success;
            this._initErrorCallback = error;

            if (this.isInitialized) {
                this._deviceRegistrationSuccess(this.pushToken);
                return;
            }

            this.isInitializing = true;

            var suffix = this._globalFunctionSuffix;
            if (!suffix) {
                suffix = Date.now().toString();
                this._globalFunctionSuffix = suffix;
            }

            var platformType = this._getPlatformType();
            if (platformType === Platform.iOS) {
                //Construct registration options object and validate iOS settings
                var apnRegistrationOptions = this.pushSettings.iOS;

                apnRegistrationOptions.notificationCallbackIOS = this.pushSettings.notificationCallbackIOS;
                //Register for APN
                tnsPushPlugin.register(
                    apnRegistrationOptions,
                    _.bind(this._successfulRegistrationAPN, this),
                    _.bind(this._failedRegistrationAPN, this)                    
                );
            } else if (platformType === Platform.Android) {
                // Ensure the required fields are present in the Android Settings
                var gcmRegistrationOptions = this.pushSettings.android;
                this._validateAndroidSettings(gcmRegistrationOptions);

                gcmRegistrationOptions.notificationCallbackAndroid = this.pushSettings.notificationCallbackAndroid;

                //Register for GCM
                tnsPushPlugin.register(
                    gcmRegistrationOptions,
                    _.bind(this._successSentRegistrationGCM, this),
                    _.bind(this._errorSentRegistrationGCM, this)
                );
            } else {
                throw new EverliveError('The current platform is not supported: ' + tnsPlatform.device.os);
            }
        },

        _validateAndroidSettings: function (androidSettings) {
            if (!androidSettings.senderID) {
                throw new EverliveError('Sender ID (project number) is not set in the android settings.');
            }
        },
        _cleanPlatformsPushSettings: function (pushSettings) {
            var cleanSettings = {};
            pushSettings = pushSettings || {};

            var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
                if (!pushSettings[platform]) {
                    return;
                }

                newSettingsObject[platform] = newSettingsObject[platform] || {};
                var newPlatformSettings = pushSettings[platform];
                var settings = newSettingsObject[platform];
                _.each(allowedFields, function (allowedField) {
                    if (newPlatformSettings.hasOwnProperty(allowedField)) {
                        settings[allowedField] = newPlatformSettings[allowedField];
                    }
                });
            };

            addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
            addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);

            var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS'];
            _.each(callbackFields, function (callbackField) {
                var callback = pushSettings[callbackField];
                if (callback) {
                    if (typeof callback !== 'function') {
                        throw new EverliveError('The "' + callbackField + '" of the push settings should be a function');
                    }

                    cleanSettings[callbackField] = pushSettings[callbackField];
                }
            });

            if (pushSettings.customParameters) {
                cleanSettings.customParameters = pushSettings.customParameters;
            }

            return cleanSettings;
        },

        _populateRegistrationObject: function (deviceRegistration, success, error) {
            var self = this;

            return buildPromise(
                function (success, error) {
                    if (!self.pushToken) {
                        throw new EverliveError('Push token is not available.');
                    }

                    self._getLocaleName(
                        function (locale) {
                            var deviceId = self._getDeviceId();
                            var hardwareModel = tnsPlatform.device.model;
                            var platformType = self._getPlatformType();
                            var timeZone = jstz.determine().name();
                            var pushToken = self.pushToken;
                            var language = 'en_US'; //TODO
                            var platformVersion = tnsPlatform.device.osVersion;

                            deviceRegistration.HardwareId = deviceId;
                            deviceRegistration.HardwareModel = hardwareModel;
                            deviceRegistration.PlatformType = platformType;
                            deviceRegistration.PlatformVersion = platformVersion;
                            deviceRegistration.TimeZone = timeZone;
                            deviceRegistration.PushToken = pushToken;
                            deviceRegistration.Locale = language;

                            success();
                        },
                        error
                    );
                },
                success,
                error
            );
        },

        _getLocaleName: function (success, error) {
            return success(); // TODO            
            /* TODO: Must translate somehow to NativeScript to get the current locale
            if (this.emulatorMode) {
                success({value: 'en_US'});
            } else {
                navigator.globalization.getLocaleName(
                    function (locale) {
                        success(locale);
                    },
                    error
                );
                navigator.globalization.getLocaleName(
                    function (locale) {
                    },
                    error
                );
            }*/
        },

        _getDeviceId: function () {
            return tnsPlatform.device.uuid;
        },

        //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
        _getPlatformType: function () {
            var psLower = tnsPlatform.device.os.toLowerCase();
            switch (psLower) {
                case 'ios':
                case 'iphone':
                case 'ipad':
                    return Platform.iOS;
                case 'android':
                    return Platform.Android;
                default:
                    return Platform.Unknown;
            }
        },

        _deviceRegistrationFailed: function (error) {
            this.pushToken = null;
            this.isInitializing = false;
            this.isInitialized = false;

            if (this._initErrorCallback) {
                this._initErrorCallback({error: error});
            }
        },

        _deviceRegistrationSuccess: function (token) {
            this.pushToken = token;
            this.isInitializing = false;
            this.isInitialized = true;

            if (this._initSuccessCallback) {
                this._initSuccessCallback({token: token});
            }
        },

        //Occurs when the device registration in APN succeeds
        _successfulRegistrationAPN: function (token) {
            var self = this;
            if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
                this._initializeInteractivePush(
                    this.pushSettings.iOS,
                    function () {
                        self._deviceRegistrationSuccess(token);
                    },
                    function (err) {
                        throw new EverliveError('The interactive push configuration is incorrect: ' + err);
                    }
                );
            } else {
                this._deviceRegistrationSuccess(token);
            }
        },

        //Occurs if the device registration in APN fails
        _failedRegistrationAPN: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when device registration has been successfully sent to GCM
        _successSentRegistrationGCM: function (token) {
            //console.log("Successfully sent request for registering with GCM.");

            // set on message received.
            tnsPushPlugin.onMessageReceived(this.pushSettings.notificationCallbackAndroid);

            this._deviceRegistrationSuccess(token);
        },

        //Occurs when an error occured when sending registration request to GCM
        _errorSentRegistrationGCM: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //This function receives all notification events from APN
        _onNotificationAPN: function (e) {
            this._raiseNotificationEventIOS(e);
        },

        //This function receives all notification events from GCM
        _onNotificationGCM: function onNotificationGCM(e) {
            switch (e.event) {
                case 'registered':
                    if (e.regid.length > 0) {
                        this._deviceRegistrationSuccess(e.regid);
                    }
                    break;
                case 'message':
                    this._raiseNotificationEventAndroid(e);
                    break;
                case 'error':
                    if (!this.pushToken) {
                        this._deviceRegistrationFailed(e);
                    } else {
                        this._raiseNotificationEventAndroid(e);
                    }
                    break;
                default:
                    this._raiseNotificationEventAndroid(e);
                    break;
            }
        },

        _raiseNotificationEventAndroid: function (e) {
            if (this.pushSettings.notificationCallbackAndroid) {
                this.pushSettings.notificationCallbackAndroid(e);
            }
        },
        _raiseNotificationEventIOS: function (e) {
            if (this.pushSettings.notificationCallbackIOS) {
                this.pushSettings.notificationCallbackIOS(e);
            }
        }
    };

    return CurrentDevice;
}());

},{"../EverliveError":42,"../common":53,"../constants":54,"../utils":94,"nativescript-push-notifications":"nativescript-push-notifications","platform":"platform"}],80:[function(require,module,exports){
var _ = require('../common')._;
var constants = require('../constants');
var Query = require('../query/Query');
var Headers = constants.Headers;

module.exports = (function () {
    // TODO: [offline] Update the structure - filter field can be refactored for example and a skip/limit/sort property can be added
    var DataQuery = function (config) {
        this.collectionName = config.collectionName;
        this.headers = config.headers || {};
        this.filter = config.filter;
        this.onSuccess = config.onSuccess;
        this.onError = config.onError;
        this.operation = config.operation;
        this.parse = config.parse;
        this.additionalOptions = config.additionalOptions;
        this.data = config.data;
        this.useOffline = config.useOffline;
        this.applyOffline = config.applyOffline;
        this.noRetry = config.noRetry; //retry will be done by default, when a request fails because of expired token, once the authentication.completeAuthentication in sdk is called.
        this.skipAuth = config.skipAuth; //if set to true, the sdk will not require authorization if the data query fails because of expired token. Used internally for various login methods.
        this._normalizedHeaders = null;
        this.isSync = config.isSync;
    };

    DataQuery.prototype = {
        _normalizeHeaders: function () {
            var self = this;
            var headerKeys = Object.keys(this.headers);

            this._normalizedHeaders = {};
            _.each(headerKeys, function (headerKey) {
                var normalizedKey = headerKey.toLowerCase();
                self._normalizedHeaders[normalizedKey] = self.headers[headerKey];
            });
        },

        getHeader: function (header) {
            if (!this._normalizedHeaders) {
                this._normalizeHeaders();
            }

            var normalizedHeader = header.toLowerCase();
            return this._normalizedHeaders[normalizedHeader];
        },

        getHeaderAsJSON: function (header) {
            if (!this._normalizedHeaders) {
                this._normalizeHeaders();
            }

            var headerValue = this._normalizedHeaders[header.toLowerCase()];
            if (_.isObject(headerValue)) {
                return headerValue;
            }
            if (_.isString(headerValue)) {
                try {
                    return JSON.parse(headerValue);
                } catch (e) {
                    return headerValue;
                }
            } else {
                return headerValue;
            }
        },

        getQueryParameters: function () {
            var queryParams = {};

            if (this.operation === DataQuery.operations.readById) {
                queryParams.filter = this.additionalOptions.id;
                queryParams.expand = this.getHeaderAsJSON(Headers.expand);
            } else {
                var sort = this.getHeaderAsJSON(Headers.sort);
                var limit = this.getHeaderAsJSON(Headers.take);
                var skip = this.getHeaderAsJSON(Headers.skip);
                var select = this.getHeaderAsJSON(Headers.select);
                var filter = this.getHeaderAsJSON(Headers.filter);
                var expand = this.getHeaderAsJSON(Headers.expand);

                if (this.filter instanceof Query) {
                    var filterObj = this.filter.build();
                    queryParams.filter = filterObj.$where || filter || {};
                    queryParams.sort = filterObj.$sort || sort;
                    queryParams.limit = filterObj.$take || limit;
                    queryParams.skip = filterObj.$skip || skip;
                    queryParams.select = filterObj.$select || select;
                    queryParams.expand = filterObj.$expand || expand;
                } else {
                    queryParams.filter = (this.filter || filter) || {};
                    queryParams.sort = sort;
                    queryParams.limit = limit;
                    queryParams.skip = skip;
                    queryParams.select = select;
                    queryParams.expand = expand;
                }
            }

            return queryParams;
        }
    };

    DataQuery.operations = {
        read: 'read',
        create: 'create',
        update: 'update',
        remove: 'destroy',
        removeSingle: 'destroySingle',
        readById: 'readById',
        count: 'count',
        rawUpdate: 'rawUpdate',
        setAcl: 'setAcl',
        setOwner: 'setOwner',
        userLogin: 'login',
        userLogout: 'logout',
        userChangePassword: 'changePassword',
        userLoginWithProvider: 'loginWith',
        userLinkWithProvider: 'linkWith',
        userUnlinkFromProvider: 'unlinkFrom',
        userResetPassword: 'resetPassword',
        userSetPassword: 'setPassword',
        filesUpdateContent: 'updateContent',
        filesGetDownloadUrlById: 'downloadUrlById'
    };

    return DataQuery;
}());
},{"../common":53,"../constants":54,"../query/Query":81}],81:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;
var WhereQuery = require('./WhereQuery');
var QueryBuilder = require('./QueryBuilder');

module.exports = (function () {
    /**
     * @class Query
     * @classdesc A query class used to describe a request that will be made to the {{site.TelerikBackendServices}} JavaScript API.
     * @param {object} [filter] A [filter expression]({% slug rest-api-querying-filtering %}) definition.
     * @param {object} [fields] A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
     * @param {object} [sort] A [sort expression]({% slug rest-api-querying-sorting %}) definition.
     * @param {number} [skip] Number of items to skip. Used for paging.
     * @param {number} [take] Number of items to take. Used for paging.
     * @param {object} [expand] An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
     */
    function Query(filter, fields, sort, skip, take, expand) {
        this.filter = filter;
        this.fields = fields;
        this.sort = sort;
        this.toskip = skip;
        this.totake = take;
        this.expandExpression = expand;
        this.expr = new Expression(OperatorType.query);
    }

    Query.prototype = {
        /** Applies a filter to the current query. This allows you to retrieve only a subset of the items based on various filtering criteria.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @param {object} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Query}
         */
        /** Defines a filter definition for the current query.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @returns {WhereQuery}
         */
        where: function (filter) {
            if (filter) {
                return this._simple(OperatorType.filter, [filter]);
            }
            else {
                return new WhereQuery(this);
            }
        },
        /** Applies a fields selection to the current query. This allows you to retrieve only a subset of all available item fields.
         * @memberOf Query.prototype
         * @method select
         * @param {object} fieldsExpression A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
         * @returns {Query}
         */
        select: function () {
            return this._simple(OperatorType.select, arguments);
        },
        // TODO
        //exclude: function () {
        //    return this._simple(OperatorType.exclude, arguments);
        //},
        /** Sorts the items in the current query in ascending order by the specified field.
         * @memberOf Query.prototype
         * @method order
         * @param {string} field The field name to order by in ascending order.
         * @returns {Query}
         */
        order: function (field) {
            return this._simple(OperatorType.order, [field]);
        },
        /** Sorts the items in the current query in descending order by the specified field.
         * @memberOf Query.prototype
         * @method orderDesc
         * @param {string} field The field name to order by in descending order.
         * @returns {Query}
         */
        orderDesc: function (field) {
            return this._simple(OperatorType.order_desc, [field]);
        },
        /** Skips a certain number of items from the beginning before returning the rest of the items. Used for paging.
         * @memberOf Query.prototype
         * @method skip
         * @see [query.take]{@link query.take}
         * @param {number} value The number of items to skip.
         * @returns {Query}
         */
        skip: function (value) {
            return this._simple(OperatorType.skip, [value]);
        },
        /** Takes a specified number of items from the query result. Used for paging.
         * @memberOf Query.prototype
         * @method take
         * @see [query.skip]{@link query.skip}
         * @param {number} value The number of items to take.
         * @returns {Query}
         */
        take: function (value) {
            return this._simple(OperatorType.take, [value]);
        },
        /** Sets an expand expression for the current query. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Query.prototype
         * @method expand
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Query}
         */
        expand: function (expandExpression) {
            return this._simple(OperatorType.expand, [expandExpression]);
        },
        /** Builds an object containing the different expressions that will be sent to {{site.TelerikBackendServices}}. It basically translates any previously specified expressions into standard queries that {{site.bs}} can understand.
         * @memberOf Query.prototype
         * @method build
         * @returns {{$where,$select,$sort,$skip,$take,$expand}}
         */
        build: function () {
            return new QueryBuilder(this).build();
        },
        _simple: function (op, oprs) {
            var args = [].slice.call(oprs);
            this.expr.addOperand(new Expression(op, args));
            return this;
        }
    };

    return Query;
}());
},{"../Expression":44,"../constants":54,"./QueryBuilder":82,"./WhereQuery":84}],82:[function(require,module,exports){
var constants = require('../constants');
var OperatorType = constants.OperatorType;
var _ = require('../common')._;
var GeoPoint = require('../GeoPoint');
var EverliveError = require('../EverliveError').EverliveError;
var Expression = require('../Expression');
var maxDistanceConsts = constants.maxDistanceConsts;
var radiusConsts = constants.radiusConsts;

module.exports = (function () {
    function QueryBuilder(query) {
        this.query = query;
        this.expr = query.expr;
    }

    QueryBuilder.prototype = {
        // TODO merge the two objects before returning them
        build: function () {
            var query = this.query;
            if (query.filter || query.fields || query.sort || query.toskip || query.totake || query.expandExpression) {
                return {
                    $where: query.filter || null,
                    $select: query.fields || null,
                    $sort: query.sort || null,
                    $skip: query.toskip || null,
                    $take: query.totake || null,
                    $expand: query.expandExpression || null
                };
            }
            return {
                $where: this._buildWhere(),
                $select: this._buildSelect(),
                $sort: this._buildSort(),
                $skip: this._getSkip(),
                $take: this._getTake(),
                $expand: this._getExpand()
            };
        },
        _getSkip: function () {
            var skipExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.skip;
            });
            return skipExpression ? skipExpression.operands[0] : null;
        },
        _getTake: function () {
            var takeExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.take;
            });
            return takeExpression ? takeExpression.operands[0] : null;
        },
        _getExpand: function () {
            var expandExpression = _.chain(this.expr.operands)
                .filter(function (value) {
                    return value.operator === OperatorType.expand;
                })
                .reduce(function (result, expression) { //expression contains operands and has operator type expand
                    return _.extend(result, expression.operands[0]);
                }, {})
                .value();
            return _.isEmpty(expandExpression) ? null : expandExpression;
        },
        _buildSelect: function () {
            var selectExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.select;
            });
            var result = {};
            if (selectExpression) {
                _.reduce(selectExpression.operands, function (memo, value) {
                    memo[value] = 1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildSort: function () {
            var sortExpressions = _.filter(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.order || value.operator === OperatorType.order_desc;
            });
            var result = {};
            if (sortExpressions.length > 0) {
                _.reduce(sortExpressions, function (memo, value) {
                    memo[value.operands[0]] = value.operator === OperatorType.order ? 1 : -1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildWhere: function () {
            var whereExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.where;
            });
            if (whereExpression) {
                return this._build(new Expression(OperatorType.and, whereExpression.operands));
            }
            else {
                var filterExpression = _.find(this.expr.operands, function (value, index, list) {
                    return value.operator === OperatorType.filter;
                });
                if (filterExpression) {
                    return filterExpression.operands[0];
                }
                return null;
            }
        },
        _build: function (expr) {
            if (this._isSimple(expr)) {
                return this._simple(expr);
            }
            else if (this._isRegex(expr)) {
                return this._regex(expr);
            }
            else if (this._isGeo(expr)) {
                return this._geo(expr);
            }
            else if (this._isAnd(expr)) {
                return this._and(expr);
            }
            else if (this._isOr(expr)) {
                return this._or(expr);
            }
            else if (this._isNot(expr)) {
                return this._not(expr);
            }
        },
        _isSimple: function (expr) {
            return expr.operator >= OperatorType.equal && expr.operator <= OperatorType.size;
        },
        _simple: function (expr) {
            var term = {}, fieldTerm = {};
            var operands = expr.operands;
            var operator = this._translateoperator(expr.operator);
            if (operator) {
                term[operator] = operands[1];
            }
            else {
                term = operands[1];
            }
            fieldTerm[operands[0]] = term;
            return fieldTerm;
        },
        _isRegex: function (expr) {
            return expr.operator >= OperatorType.regex && expr.operator <= OperatorType.endsWith;
        },
        _regex: function (expr) {
            var fieldTerm = {};
            var regex = this._getRegex(expr);
            var regexValue = this._getRegexValue(regex);
            var operands = expr.operands;
            fieldTerm[operands[0]] = regexValue;
            return fieldTerm;
        },
        _getRegex: function (expr) {
            var pattern = expr.operands[1];
            var flags = expr.operands[2] ? expr.operands[2] : '';
            switch (expr.operator) {
                case OperatorType.regex:
                    return pattern instanceof RegExp ? pattern : new RegExp(pattern, flags);
                case OperatorType.startsWith:
                    return new RegExp("^" + pattern, flags);
                case OperatorType.endsWith:
                    return new RegExp(pattern + "$", flags);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getRegexValue: function (regex) {
            var options = '';
            if (regex.global) {
                options += 'g';
            }
            if (regex.multiline) {
                options += 'm';
            }
            if (regex.ignoreCase) {
                options += 'i';
            }
            return {$regex: regex.source, $options: options};
        },
        _isGeo: function (expr) {
            return expr.operator >= OperatorType.nearShpere && expr.operator <= OperatorType.withinShpere;
        },
        _geo: function (expr) {
            var fieldTerm = {};
            var operands = expr.operands;
            fieldTerm[operands[0]] = this._getGeoTerm(expr);
            return fieldTerm;
        },
        _getGeoTerm: function (expr) {
            switch (expr.operator) {
                case OperatorType.nearShpere:
                    return this._getNearSphereTerm(expr);
                case OperatorType.withinBox:
                    return this._getWithinBox(expr);
                case OperatorType.withinPolygon:
                    return this._getWithinPolygon(expr);
                case OperatorType.withinShpere:
                    return this._getWithinCenterSphere(expr);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getNearSphereTerm: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var maxDistance = operands[2];
            var metrics = operands[3];
            var maxDistanceConst;
            var term = {
                '$nearSphere': center
            };
            if (typeof maxDistance !== 'undefined') {
                maxDistanceConst = maxDistanceConsts[metrics] || maxDistanceConsts.radians;
                term[maxDistanceConst] = maxDistance;
            }
            return term;
        },
        _getWithinBox: function (expr) {
            var operands = expr.operands;
            var bottomLeft = this._getGeoPoint(operands[1]);
            var upperRight = this._getGeoPoint(operands[2]);
            return {
                '$within': {
                    '$box': [bottomLeft, upperRight]
                }
            };
        },
        _getWithinPolygon: function (expr) {
            var operands = expr.operands;
            var points = this._getGeoPoints(operands[1]);
            return {
                '$within': {
                    '$polygon': points
                }
            };
        },
        _getWithinCenterSphere: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var radius = operands[2];
            var metrics = operands[3];
            var radiusConst = radiusConsts[metrics] || radiusConsts.radians;
            var sphereInfo = {
                'center': center
            };
            sphereInfo[radiusConst] = radius;
            return {
                '$within': {
                    '$centerSphere': sphereInfo
                }
            };
        },
        _getGeoPoint: function (point) {
            if (_.isArray(point)) {
                return new GeoPoint(point[0], point[1]);
            }
            return point;
        },
        _getGeoPoints: function (points) {
            var self = this;
            return _.map(points, function (point) {
                return self._getGeoPoint(point);
            });
        },
        _isAnd: function (expr) {
            return expr.operator === OperatorType.and;
        },
        _and: function (expr) {
            var i, l, term, result = {};
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result = this._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            var i, l, key, value, newValue;
            var keys = _.keys(newObj);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                value = andObj[key];
                if (typeof value === 'undefined') {
                    andObj[key] = newObj[key];
                }
                else {
                    newValue = newObj[key];
                    if (typeof value === 'object' && typeof newValue === 'object') {
                        value = _.extend(value, newValue);
                    } else {
                        value = newValue;
                    }
                    andObj[key] = value;
                }
            }
            return andObj;
        },
        _isOr: function (expr) {
            return expr.operator === OperatorType.or;
        },
        _or: function (expr) {
            var i, l, term, result = [];
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _isNot: function (expr) {
            return expr.operator === OperatorType.not;
        },
        _not: function (expr) {
            return {$not: this._build(expr.operands[0])};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case OperatorType.equal:
                    return null;
                case OperatorType.not_equal:
                    return '$ne';
                case OperatorType.gt:
                    return '$gt';
                case OperatorType.lt:
                    return '$lt';
                case OperatorType.gte:
                    return '$gte';
                case OperatorType.lte:
                    return '$lte';
                case OperatorType.isin:
                    return '$in';
                case OperatorType.notin:
                    return '$nin';
                case OperatorType.all:
                    return '$all';
                case OperatorType.size:
                    return '$size';
            }
            throw new EverliveError('Unknown operator type.');
        }
    };

    return QueryBuilder;
}());
},{"../EverliveError":42,"../Expression":44,"../GeoPoint":45,"../common":53,"../constants":54}],83:[function(require,module,exports){
var DataQuery = require('./DataQuery');
var Request = require('../Request');
var _ = require('../common')._;

module.exports = (function () {
    var RequestOptionsBuilder = {};

    RequestOptionsBuilder._buildEndpointUrl = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
            endpoint += '/' + dataQuery.additionalOptions.id;
        }

        return endpoint;
    };

    RequestOptionsBuilder._buildBaseObject = function (dataQuery) {
        var defaultObject = {
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery),
            filter: dataQuery.filter,
            success: dataQuery.onSuccess,
            error: dataQuery.onError,
            data: dataQuery.data,
            headers: dataQuery.headers
        };

        if (dataQuery.parse) {
            defaultObject.parse = dataQuery.parse;
        }

        return defaultObject;
    };

    RequestOptionsBuilder._build = function (dataQuery, additionalOptions) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), additionalOptions);
    };

    RequestOptionsBuilder[DataQuery.operations.read] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.readById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.count] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: dataQuery.collectionName + '/_count'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.create] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.rawUpdate] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        var ofilter = null; // request options filter

        if (typeof filter === 'string') {
            endpoint += '/' + filter; // send the filter through query string
        } else if (typeof filter === 'object') {
            ofilter = filter; // send the filter as filter headers
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint,
            filter: ofilter
        });
    };

    RequestOptionsBuilder[DataQuery.operations.update] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.remove] = function (dataQuery) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), {
            method: 'DELETE'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.removeSingle] = RequestOptionsBuilder[DataQuery.operations.remove];

    RequestOptionsBuilder[DataQuery.operations.setAcl] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;

        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_acl';
        var method, data;
        if (dataQuery.additionalOptions.acl === null) {
            method = 'DELETE';
        } else {
            method = 'PUT';
            data = dataQuery.additionalOptions.acl;
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: method,
            endpoint: endpoint,
            data: data
        });
    };

    RequestOptionsBuilder[DataQuery.operations.setOwner] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_owner';

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogin] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: 'oauth/token',
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogout] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: 'oauth/logout'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userChangePassword] = function (dataQuery) {
        var keepTokens = dataQuery.additionalOptions.keepTokens;
        var endpoint = 'Users/changepassword';
        if (keepTokens) {
            endpoint += '?keepTokens=true';
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: endpoint,
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLoginWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            authHeaders: false
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLinkWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/link'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userUnlinkFromProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/unlink'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userResetPassword] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/resetpassword'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userSetPassword] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/setpassword'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesUpdateContent] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/Content'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesGetDownloadUrlById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    return RequestOptionsBuilder;
}());
},{"../Request":47,"../common":53,"./DataQuery":80}],84:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;

module.exports = (function () {
    /**
     * @classdesc A fluent API operation for creating a filter for a query by chaining different rules.
     * @class WhereQuery
     * @protected
     * @borrows WhereQuery#eq as WhereQuery#equal
     * @borrows WhereQuery#ne as WhereQuery#notEqual
     * @borrows WhereQuery#gt as WhereQuery#greaterThan
     * @borrows WhereQuery#gte as WhereQuery#greaterThanEqual
     * @borrows WhereQuery#lt as WhereQuery#lessThan
     * @borrows WhereQuery#lte as WhereQuery#lessThanEqual
     */
    function WhereQuery(parentQuery, exprOp, singleOperand) {
        this.parent = parentQuery;
        this.single = singleOperand;
        this.expr = new Expression(exprOp || OperatorType.where);
        this.parent.expr.addOperand(this.expr);
    }

    WhereQuery.prototype = {
        /**
         * Adds an `and` clause to the current condition and returns it for further chaining.
         * @method and
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        and: function () {
            return new WhereQuery(this, OperatorType.and);
        },
        /**
         * Adds an `or` clause to the current condition and returns it for further chaining.
         * @method or
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        or: function () {
            return new WhereQuery(this, OperatorType.or);
        },
        /**
         * Adds a `not` clause to the current condition and returns it for further chaining.
         * @method not
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        not: function () {
            return new WhereQuery(this, OperatorType.not, true);
        },
        _simple: function (operator) {
            var args = [].slice.call(arguments, 1);
            this.expr.addOperand(new Expression(operator, args));
            return this._done();
        },
        /**
         * Adds a condition that a field must be equal to a specific value.
         * @method eq
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the fields must be equal).
         * @returns {WhereQuery}
         */
        eq: function (field, value) {
            return this._simple(OperatorType.equal, field, value);
        },
        /**
         * Adds a condition that a field must *not* be equal to a specific value.
         * @method ne
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the field must not be equal).
         * @returns {WhereQuery}
         */
        ne: function (field, value) {
            return this._simple(OperatorType.not_equal, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than` a certain value. Applicable to Number, String, and Date fields.
         * @method gt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than).
         * @returns {WhereQuery}
         */
        gt: function (field, value) {
            return this._simple(OperatorType.gt, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method gte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than or equal to).
         * @returns {WhereQuery}
         */
        gte: function (field, value) {
            return this._simple(OperatorType.gte, field, value);
        },
        /**
         * Adds a condition that a field must be `less than` a certain value. Applicable to Number, String, and Date fields.
         * @method lt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than).
         * @returns {WhereQuery}
         */
        lt: function (field, value) {
            return this._simple(OperatorType.lt, field, value);
        },
        /**
         * Adds a condition that a field must be `less than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method lte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than or equal to).
         * @returns {WhereQuery}
         */
        lte: function (field, value) {
            return this._simple(OperatorType.lte, field, value);
        },
        /**
         * Adds a condition that a field must be in a set of values.
         * @method isin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of the values that the field should be in.
         * @returns {WhereQuery}
         */
        isin: function (field, value) {
            return this._simple(OperatorType.isin, field, value);
        },
        /**
         * Adds a condition that a field must *not* be in a set of values.
         * @method notin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field should not be in.
         * @returns {WhereQuery}
         */
        notin: function (field, value) {
            return this._simple(OperatorType.notin, field, value);
        },
        /**
         * Adds a condition that a field must include *all* of the specified values. Applicable to Array fields.
         * @method all
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field must include.
         * @returns {WhereQuery}
         */
        all: function (field, value) {
            return this._simple(OperatorType.all, field, value);
        },
        /**
         * Adds a condition that a field must contain an array whose length is larger than a specified value. Applicable to Array fields.
         * @method size
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {number} value The size that the array must be bigger than.
         * @returns {WhereQuery}
         */
        size: function (field, value) {
            return this._simple(OperatorType.size, field, value);
        },
        /**
         * Adds a condition that a field must satisfy a specified regex.
         * @method regex
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} regularExpression Regular expression in PCRE format.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        regex: function (field, value, flags) {
            return this._simple(OperatorType.regex, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *start* with a specified string.
         * @method startsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should start with.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        startsWith: function (field, value, flags) {
            return this._simple(OperatorType.startsWith, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *end* with a specified string.
         * @method endsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should end with.
         * @param {string} [options] A string of  regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        endsWith: function (field, value, flags) {
            return this._simple(OperatorType.endsWith, field, value, flags);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a certain distance from another geopoint. Applicable to GeoPoint fields only.
         * @method nearSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} point Comparison geopoint value.
         * @param {number} distance Distance value.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for distance. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        nearSphere: function (field, point, distance, metrics) {
            return this._simple(OperatorType.nearShpere, field, point, distance, metrics);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate rectangle. Applicable to GeoPoint fields only.
         * @method withinBox
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} pointBottomLeft Value representing the bottom left corner of the box.
         * @param {Everlive.GeoPoint} pointUpperRight Value representing the upper right corner of the box.
         * @example ```js
         var query = new Everlive.Query();
         query.where().withinBox('Location',
         new Everlive.GeoPoint(23.317871, 42.687709),
         new Everlive.GeoPoint(23.331346, 42.707075));
         ```
         * @returns {WhereQuery}
         */
        withinBox: function (field, pointBottomLeft, pointUpperRight) {
            return this._simple(OperatorType.withinBox, field, pointBottomLeft, pointUpperRight);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate polygon. The polygon is specified as an array of geopoints. The last point in the array is implicitly connected to the first point thus closing the shape. Applicable to GeoPoint fields only.
         * @method withinPolygon
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint[]} points Comparison value in the form of an array of geopoints defining the polygon.
         * @example ```js
         var point1 = new Everlive.GeoPoint(23.317871, 42.687709);
         var point2 = new Everlive.GeoPoint(42.698749, 42.698749);
         var point3 = new Everlive.GeoPoint(23.331346, 42.702282);

         var query = new Everlive.Query();
         query.where().withinPolygon("location", [point1, point2, point3]);
         * ```
         * @returns {WhereQuery}
         */
        withinPolygon: function (field, points) {
            return this._simple(OperatorType.withinPolygon, field, points);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a coordinate circle. Applicable to GeoPoint fields only.
         * @method withinCenterSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} center Comparison value specifying the center of the coordinate circle.
         * @param {number} radius Value specifying the radius length.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for radius length. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        withinCenterSphere: function (field, center, radius, metrics) {
            return this._simple(OperatorType.withinShpere, field, center, radius, metrics);
        },
        /**
         * Ends the definition of the current WhereQuery. You need to call this method in order to continue with the definition of the parent `Query`. All other `WhereQuery` methods return the current instance of `WhereQuery` to allow chaining.
         * @method done
         * @memberOf WhereQuery.prototype
         * @returns {Query}
         */
        done: function () {
            if (this.parent instanceof WhereQuery) {
                return this.parent._done();
            } else {
                return this.parent;
            }
        },
        _done: function () {
            if (this.single) {
                return this.parent;
            } else {
                return this;
            }
        }
    };

    WhereQuery.prototype.equal = WhereQuery.prototype.eq;
    WhereQuery.prototype.notEqual = WhereQuery.prototype.ne;
    WhereQuery.prototype.greaterThan = WhereQuery.prototype.gt;
    WhereQuery.prototype.greaterThanEqual = WhereQuery.prototype.gte;
    WhereQuery.prototype.lessThan = WhereQuery.prototype.lt;
    WhereQuery.prototype.lessThanEqual = WhereQuery.prototype.lte;

    return WhereQuery;
}());
},{"../Expression":44,"../constants":54}],85:[function(require,module,exports){
var http = require('http');
module.exports = (function () {
    'use strict';

    function reqwest(options) {
        var httpRequestOptions = {
            url: options.url,
            method: options.method,
            headers: options.headers || {}
        };

        if (options.data) {
            httpRequestOptions.content = options.data; // NOTE: If we pass null/undefined, it will raise an exception in the http module.
        }

        httpRequestOptions.headers['Accept'] = 'application/json';
        httpRequestOptions.headers['Content-Type'] = 'application/json';

        var noop = function () {
        };
        var success = options.success || noop;
        var error = options.error || noop;

        var requestSuccessCallback = function (response) {
            var contentString = response.content.toString();
            if (response.statusCode < 400) {
                // Success callback calls a custom parse function
                success(contentString);
            } else {
                // Error callback relies on a JSON Object with ResponseText inside
                error({
                    responseText: contentString
                });
            }
        };

        var requestErrorCallback = function (err) {
            // error: function(jqXHR, textStatus, errorThrown)
            // when timeouting for example (i.e. no internet connectivity), we get an err with content { message: "timeout...", stack: null }
            error({
                responseText: err
            });
        };

        http.request(httpRequestOptions).then(requestSuccessCallback, requestErrorCallback);
    }

    return reqwest;
}());
},{"http":"http"}],86:[function(require,module,exports){
(function (Buffer){
var url = require('url');
var http = require('http');
var https = require('https');
var rsvp = require('rsvp');
var zlib = require('zlib');
var _ = require('underscore');

module.exports = (function () {
    'use strict';

    function reqwest(options) {
        var urlParts = url.parse(options.url);
        var request;
        if (urlParts.protocol === 'https:') {
            request = https.request;
        }
        else {
            request = http.request;
        }
        var headers = options.headers || {};
        options.success = options.success || _.noop;
        options.error = options.error || _.noop;

        headers['Content-Type'] = options.contentType;
        var req = request({
            method: options.method,
            hostname: urlParts.hostname,
            port: urlParts.port,
            path: urlParts.path,
            headers: headers
        }, function (res) {
            var json = '';
            var contentEncoding = res.headers['content-encoding'];
            var responseProxy;
            switch (contentEncoding){
                case 'gzip':
                    responseProxy = zlib.createGunzip();
                    res.pipe(responseProxy);
                    break;
                default:
                    responseProxy = res;
                    responseProxy.setEncoding('utf8');
                    break;
            }

            responseProxy.on('data', function (data) {
                json += data.toString();
            });

            responseProxy.on('end', function () {
                // 1xx Informational, 2xx Success, 3xx Redirection, 4xx Client Error, 5xx Server Error
                if (res.statusCode >= 200 && res.statusCode < 400) {
                    options.success(json, res);
                } else {
                    if (json) {
                        options.error({ responseText: json });
                    }
                    else { // empty response
                        var error = new Error('Response error.');
                        error.statusCode = res.statusCode;
                        options.error({ responseText: error });
                    }
                }
            });
        });

        req.on('error', function (e) {
            options.error({ responseText: e }); // TODO
        });

        if (options.data) {
            var contentEncoding = headers['content-encoding'];
            switch (contentEncoding){
                case 'gzip':
                    var buf = new Buffer(options.data, 'utf-8');
                    zlib.gzip(buf, function (err, result) {
                        req.end(result);
                    });
                    break;
                default:
                    req.end(options.data);
                    break;
            }
        }
        else {
            req.end();
        }
    }

    return reqwest;
}());
}).call(this,require("buffer").Buffer)

},{"buffer":"buffer","http":"http","https":"https","rsvp":1,"underscore":1,"url":"url","zlib":"zlib"}],87:[function(require,module,exports){
var platform = require('../everlive.platform');
var WebFileStore = require('./WebFileStore');
var NativeScriptFileStore = require('./NativeScriptFileStore');
var _ = require('../common')._;

'use strict';

if (platform.isNativeScript) {
    module.exports = NativeScriptFileStore;
} else if (platform.isCordova || platform.isDesktop) {
    module.exports = WebFileStore;
} else {
    module.exports = _.noop;
}
},{"../common":53,"../everlive.platform":56,"./NativeScriptFileStore":89,"./WebFileStore":90}],88:[function(require,module,exports){
var platform = require('./../everlive.platform.js');
var isNativeScript = platform.isNativeScript;
var isNodejs = platform.isNodejs;
var constants = require('./../constants');

module.exports = (function () {
    'use strict';

    function initLocalStorage(options) {
        if (isNativeScript) {
            var localSettings;

            //workound for older nativescript versions
            try {
                localSettings = require('application-settings');
            } catch (e) {
                localSettings = require('local-settings');
            }

            return {
                getItem: function (key) {
                    return localSettings.getString(key);
                },

                removeItem: function (key) {
                    return localSettings.remove(key);
                },

                setItem: function (key, value) {
                    return localSettings.setString(key, value);
                }
            };
        } else {
            var localStorage;
            if (isNodejs) {
                var LocalStorage = require('node-localstorage').LocalStorage;
                localStorage = new LocalStorage(options.storage.storagePath);
            } else {
                localStorage = window.localStorage;
            }

            return {
                getItem: function (key) {
                    return localStorage.getItem(key);
                },

                removeItem: function (key) {
                    return localStorage.removeItem(key);
                },

                setItem: function (key, value) {
                    return localStorage.setItem(key, value);
                }
            };
        }
    }

    function LocalStore(options) {
        this.options = options;
        this._localStorage = initLocalStorage(this.options);
    }

    LocalStore.prototype = {
        getItem: function (key) {
            return this._localStorage.getItem(key);
        },

        removeItem: function (key) {
            return this._localStorage.removeItem(key);
        },

        setItem: function (key, value) {
            return this._localStorage.setItem(key, value);
        }
    };

    return LocalStore;
}());
},{"./../constants":54,"./../everlive.platform.js":56,"application-settings":"application-settings","local-settings":"local-settings","node-localstorage":"node-localstorage"}],89:[function(require,module,exports){
'use strict';

var common = require('../common');
var rsvp = common.rsvp;

function NativeScriptFileStore(storagePath, options) {
    this.options = options;
    this.fs = require('file-system');
    this.dataDirectoryPath = this.fs.knownFolders.documents().path;
    this.filesDirectoryPath = storagePath;
}

NativeScriptFileStore.prototype = {
    getErrorHandler: function (callback) {
        return function (e) {
            callback && callback(e);
        }
    },

    removeFilesDirectory: function (directoryEntry) {
        var filesDirectoryPath = this.fs.path.join(directoryEntry.path, this.filesDirectoryPath);
        var filesDirectory = this.fs.Folder.fromPath(filesDirectoryPath);
        return filesDirectory.remove();
    },

    removeFile: function (fileEntry) {
        return fileEntry.remove();
    },

    readFileAsText: function (fileEntry) {
        return fileEntry.readText();
    },

    writeTextToFile: function (fileEntry, content) {
        return fileEntry.writeText(content);
    },

    getFile: function (path) {
        var self = this;
        return new rsvp.Promise(function (resolve, reject) {
            self.resolveDataDirectory(function (directoryEntry) {
                var fullFilePath = self.fs.path.join(directoryEntry.path, path);
                var file = self.fs.File.fromPath(fullFilePath);
                resolve(file);
            }, reject);
        });
    },

    resolveDataDirectory: function () {
        var self = this;

        return new rsvp.Promise(function (resolve) {
            var dataDirectory = self.fs.Folder.fromPath(self.dataDirectoryPath);
            resolve(dataDirectory);
        });
    },

    ensureFilesDirectory: function () {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            self.resolveDataDirectory(function (directoryEntry) {
                var fileDirectoryPath = self.fs.path.join(directoryEntry.path, self.filesDirectoryPath);
                self.fs.Folder.fromPath(fileDirectoryPath);
                resolve();
            });
        });
    },

    getFilesDirectoryPath: function () {
        return this.filesDirectoryPath;
    },

    // TODO: [offline] Implement
    writeText: function (fileName, text) {
        throw new Error('Not implemented');
    },

    // TODO: [offline] Implement
    createDirectory: function () {
        throw new Error('Not implemented');
    },

    // TODO: [offline] Implement
    getFileSize: function (file, getFileSize) {
        throw new Error('Not implemented');
    },

    // TODO: [offline] Implement
    getFileByAbsolutePath: function (path) {
        throw new Error('Not implemented');
    },

    readFileAsBase64: function (file) {
        throw new Error('Not implemented');
    },

    renameFile: function () {
        throw new Error('Not implemented');
    },
};

module.exports = NativeScriptFileStore;
},{"../common":53,"file-system":"file-system"}],90:[function(require,module,exports){
'use strict';

var EverliveError = require('../EverliveError').EverliveError;
var common = require('../common');
var rsvp = common.rsvp;
var utils = require('../utils');
var platform = require('../everlive.platform');
var path = require('path');

var deviceReadyPromise = function () {
    return new rsvp.Promise(function (resolve) {
        document.addEventListener('deviceready', resolve);
    });
};

function WebFileStore(storagePath, options) {
    this.options = options;

    var filesDirectoryPath;

    if (platform.isWindowsPhone) {
        //windows phone does not handle leading or trailing slashes very well :(
        filesDirectoryPath = storagePath.replace(new RegExp('/', 'g'), '');
    } else {
        if (storagePath.lastIndexOf('/') === -1) {
            filesDirectoryPath = storagePath + '/';
        }
    }

    filesDirectoryPath = filesDirectoryPath || storagePath;

    var self = this;

    deviceReadyPromise()
        .then(function () {
            self.filesDirectoryPath = filesDirectoryPath;
            self._requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
            self._resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL;
            self._PERSISTENT_FILE_SYSTEM = window.LocalFileSystem ? window.LocalFileSystem.PERSISTENT : window.PERSISTENT;
        });
}

WebFileStore.prototype = {
    getErrorHandler: function getErrorHandler(callback) {
        var errorsMap = {
            '1000': 'NOT_FOUND'
        };

        _.each(Object.keys(FileError), function (error) {
            errorsMap[FileError[error]] = error;
        });

        return function (e) {
            if (!e.message) {
                e.message = errorsMap[e.code];
            }

            callback && callback(e);
        }
    },

    getDataDirectory: (function () {
        var fileSystemRoot;

        return function getDataDirectory() {
            var self = this;

            return deviceReadyPromise()
                .then(function () {
                    var requestFileSystem = function (bytes, success, error) {
                        self._requestFileSystem.call(window, self._PERSISTENT_FILE_SYSTEM, bytes, function (fileSystem) {
                            fileSystemRoot = fileSystem.root;
                            fileSystemRoot.nativeURL = fileSystemRoot.nativeURL || fileSystemRoot.toURL();
                            success(fileSystemRoot);
                        }, error);
                    };

                    return new rsvp.Promise(function (resolve, reject) {
                        if (fileSystemRoot) {
                            return resolve(fileSystemRoot);
                        }

                        if (platform.isDesktop) {
                            if (navigator && !navigator.webkitPersistentStorage) {
                                return reject(new EverliveError('FileSystemStorage can be used only with browsers supporting it. Consider using localStorage.'))
                            }

                            navigator.webkitPersistentStorage.requestQuota(self.options.storage.requestedQuota, function (grantedBytes) {
                                requestFileSystem(grantedBytes, resolve, reject);
                            }, reject);
                        } else {
                            requestFileSystem(0, resolve, reject);
                        }
                    });
                });
        };
    }()),

    getFilesDirectory: function getFilesDirectory() {
        var self = this;
        return new rsvp.Promise(function (resolve, reject) {
            self.getDataDirectory()
                .then(function (dataDirectory) {
                    dataDirectory.getDirectory(self.filesDirectoryPath, {
                        create: true,
                        exclusive: false
                    }, resolve, reject);
                })
                .catch(reject);
        });
    },

    removeFilesDirectory: function () {
        var self = this;

        return this.getFilesDirectory()
            .then(function (filesDirectory) {
                return self._removeFolderWrap(filesDirectory);
            });
    },

    removeFile: function (fileEntry) {
        return new rsvp.Promise(function (resolve, reject) {
            fileEntry.remove(function () {
                resolve();
            }, reject);
        });
    },

    readFileAsText: function (fileEntry) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            self.getFilesDirectory().then(function () {
                fileEntry.file(function (file) {
                    var reader = new FileReader();
                    reader.onloadend = function () {
                        var result = this.result;

                        //windows phone returns an object....
                        if (typeof this.result === 'object') {
                            result = JSON.stringify(this.result);
                        }

                        resolve(result);
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                }, reject);
            }).catch(reject);
        });
    },

    writeTextToFile: function (fileEntry, content) {
        var self = this;

        return self.getFilesDirectory()
            .then(function () {
                return self._getWriterWrap(fileEntry, content);
            });
    },

    getFileSize: function (filename, folder) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            var fileLocation = utils.joinPath(folder, filename);

            return self.getFile(fileLocation)
                .then(function (fileEntry) {
                    fileEntry.file(function (file) {
                        resolve(file.size);
                    }, reject);
                })
        });
    },

    getFile: function (fileName, dirEntry) {
        return this.getFilesDirectory()
            .then(function (directoryEntry) {
                var fileDirectory;
                if (dirEntry) {
                    fileDirectory = dirEntry;
                } else {
                    fileDirectory = directoryEntry;
                }

                return new rsvp.Promise(function (resolve, reject) {
                    fileDirectory.getFile(fileName, {
                        create: true,
                        exclusive: false
                    }, resolve, reject);
                });
            });
    },

    getFileByAbsolutePath: function (path) {
        var self = this;
        path = utils.transformPlatformPath(path);

        return new rsvp.Promise(function (resolve, reject) {
            self._resolveLocalFileSystemURL.call(window, path, resolve, function (err) {
                if (err && err.code === FileError.NOT_FOUND_ERR) {
                    return resolve();
                }

                return reject(err);
            });
        });
    },

    createDirectory: function (directory) {
        var self = this;

        return this.getFilesDirectory()
            .then(function (directoryEntry) {
                return self._getDirectoryWrap(directory, directoryEntry, {
                    create: true,
                    exclusive: false
                });
            });
    },

    renameFile: function (directoryEntry, fileEntry, filename) {
        return new rsvp.Promise(function (resolve, reject) {
            fileEntry.moveTo(directoryEntry, filename, resolve, reject);
        });
    },

    _getDirectoryWrap: function (directory, directoryEntry, options) {
        return new rsvp.Promise(function (resolve, reject) {
            directoryEntry.getDirectory(directory, options, resolve, reject);
        });
    },

    _removeFolderWrap: function (filesDirEntry) {
        return new rsvp.Promise(function (resolve, reject) {
            filesDirEntry.removeRecursively(function () {
                resolve();
            }, reject);
        });
    },

    _getWriterWrap: function (fileEntry, content) {
        return new rsvp.Promise(function (resolve, reject) {
            fileEntry.createWriter(function (fileWriter) {
                fileWriter.onwriteend = function () {
                    resolve();
                };

                fileWriter.onerror = reject;

                var bb = new Blob([content]);
                fileWriter.write(bb);
            }, reject);
        });
    },

    writeText: function (fileName, text, path) {
        var self = this;
        var fileHandle;

        return this.getFilesDirectory()
            .then(function (directoryEntry) {
                if (path) {
                    return self.createDirectory(path);
                } else {
                    return directoryEntry;
                }
            })
            .then(function (directoryEntry) {
                return self.getFile(fileName, directoryEntry);
            })
            .then(function (fileEntry) {
                fileHandle = fileEntry;
                return self.writeTextToFile(fileEntry, text);
            })
            .then(function () {
                // there  is a difference between the cordova implementation and the standard FileTransfer fileEntry
                return fileHandle.nativeURL || fileHandle.toURL();
            });
    },

    // http://stackoverflow.com/questions/9583363/get-base64-from-imageuri-with-phonegap
    readFileAsBase64: function (fileEntry) {
        return new rsvp.Promise(function (resolve, reject) {
            fileEntry.file(function (file) {
                var reader = new FileReader();
                reader.onloadend = function (evt) {
                    resolve(utils.arrayBufferToBase64(evt.target.result));
                };

                reader.readAsArrayBuffer(file);
            }, reject);
        });
    }
};

module.exports = WebFileStore;
},{"../EverliveError":42,"../common":53,"../everlive.platform":56,"../utils":94,"path":4}],91:[function(require,module,exports){
var buildPromise = require('../utils').buildPromise;
var constants = require('../constants');
var idField = constants.idField;
var DataQuery = require('../query/DataQuery');
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var rsvp = require('../common').rsvp;
var Request = require('../Request');
var Everlive = require('../Everlive');
var EverliveError = require('../EverliveError').EverliveError;
var EverliveErrors = require('../EverliveError').EverliveErrors;
var everlivePlatform = require('../everlive.platform').platform;
var _ = require('../common')._;
var utils = require('../utils');

module.exports = (function () {
    function mergeResultData(data, success) {
        return function (res, response) {
            var attrs = res.result;
            // support for kendo observable array
            if (_.isArray(data) || typeof data.length === 'number') {
                _.each(data, function (item, index) {
                    _.extend(item, attrs[index]);
                });
            }
            else {
                _.extend(data, attrs);
            }

            success(res, response);
        };
    }

    function mergeUpdateResultData(data, success) {
        return function (res) {
            var modifiedAt = res.ModifiedAt;
            data.ModifiedAt = modifiedAt;
            success(res);
        };
    }

    /**
     * @class Data
     * @classdesc A class that provides methods for all CRUD operations to a given {{site.bs}} data type. Covers advanced scenarios with custom headers and special server-side functionality.
     * @param {object} setup
     * @param {string} collectionName
     * @protected
     */
    function Data(setup, collectionName, offlineStorage, everlive) {
        this.setup = setup;
        this.collectionName = collectionName;
        this.options = null;
        this.offlineStorage = offlineStorage;
        this.everlive = everlive;
    }

    Data.prototype = {
        _isOnline: function () {
            return this.offlineStorage ? this.offlineStorage.isOnline() : true;
        },

        _getOfflineCreateData: function (query, requestResponse) {
            var createData;
            if (_.isArray(query.data)) {
                createData = [];
                for (var i = 0; i < query.data.length; i++) {
                    var objectToCreate = _.extend(query.data[i], requestResponse.result[i]);
                    createData.push(objectToCreate)
                }
            } else {
                createData = _.extend(query.data, requestResponse.result);
            }

            return createData;
        },
        _applyOffline: function (query, requestResponse) {
            var autoSyncEnabled = this.offlineStorage && this.offlineStorage.setup.autoSync;
            if (autoSyncEnabled) {
                switch (query.operation) {
                    case DataQuery.operations.read:
                    case DataQuery.operations.readById:
                        var syncReadQuery = new DataQuery(_.defaults({
                            data: requestResponse.result,
                            isSync: true,
                            operation: DataQuery.operations.create
                        }, query));
                        return this.offlineStorage.processQuery(syncReadQuery);
                    case DataQuery.operations.create:
                        var createData = this._getOfflineCreateData(query, requestResponse);
                        var createQuery = new DataQuery(_.defaults({
                            data: createData,
                            isSync: true
                        }, query));
                        return this.offlineStorage.processQuery(createQuery);
                    case DataQuery.operations.update:
                    case DataQuery.operations.rawUpdate:
                        query.isSync = true;
                        query.ModifiedAt = requestResponse.ModifiedAt;
                        return this.offlineStorage.processQuery(query);
                    default:
                        query.isSync = true;
                        return this.offlineStorage.processQuery(query);
                }
            }

            return new rsvp.Promise(function (resolve) {
                resolve();
            });
        },

        _setOption: function (key, value) {
            this.options = this.options || {};
            if (_.isObject(value)) {
                this.options[key] = _.extend({}, this.options[key], value);
            } else {
                this.options[key] = value;
            }
            return this;
        },

        /**
         * @memberOf Data.prototype
         * @method
         * Modifies whether the query should be invoked on the offline storage.
         * Default is true.
         * Only valid when offlineStorage is enabled.
         * @param useOffline
         * @returns {Data}
         * */
        useOffline: function (useOffline) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in useOffline() query modifier');
            }
            return this._setOption('useOffline', useOffline);
        },

        /**
         * @memberOf Data.prototype
         * @method
         * @name ignoreCache
         * Does not use the cache when retrieving the data.
         * Only valid when caching is enabled.
         * @returns {Data}
         * */
        ignoreCache: function () {
            return this._setOption('ignoreCache', true);
        },

        /**
         * @memberOf Data.prototype
         * @method
         * @name forceCache
         * Forces the request to get the data from the cache even if the data is already expired.
         * Only valid when caching is enabled.
         * @returns {Data}
         * */
        forceCache: function () {
            return this._setOption('forceCache', true);
        },

        /**
         * @memberOf Data.prototype
         * @method
         * @name maxAge
         * Sets cache expiration specifically for the current query
         * Only valid when caching is enabled.
         * @param maxAgeInMinutes
         * @returns {Data}
         * */
        maxAge: function (maxAgeInMinutes) {
            var maxAge = maxAgeInMinutes * 1000 * 60;
            return this._setOption('maxAge', maxAge);
        },

        isSync: function (isSync) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in isSync() query modifier');
            }
            return this._setOption('isSync', isSync);
        },

        /**
         * @memberOf Data.prototype
         * @method
         * Modifies whether the query should invoke the {{@link Authentication.prototype.hasAuthenticationRequirement}}.
         * Default is false.
         * Only valid when authentication module has an onAuthenticationRequired function .
         * @param skipAuth
         * @returns {Data}
         * */
        skipAuth: function (skipAuth) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in skipAuth() query modifier');
            }
            return this._setOption('skipAuth', skipAuth);
        },

        /**
         * Modifies whether the query should be applied offline, if the sdk is currenty working online.
         * Default is true.
         * Only valid when offlineStorage is enabled.
         * @memberOf Data.prototype
         * @method
         * @param applyOffline
         * @returns {Data}
         * */
        applyOffline: function (applyOffline) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in applyOffline() query modifier');
            }
            return this._setOption('applyOffline', applyOffline);
        },

        /**
         * Sets additional non-standard HTTP headers in the current data request. See [List of Non-Standard HTTP Headers]{{% slug rest-api-headers}} for more information.
         * @memberOf Data.prototype
         * @method
         * @param {object} headers Additional headers to be sent with the data request.
         * @returns {Data}
         */
        withHeaders: function (headers) {
            return this._setOption('headers', headers);
        },
        /**
         * Sets an expand expression to be used in the data request. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Data.prototype
         * @method
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Data}
         */
        expand: function (expandExpression) {
            var expandHeader = {
                'X-Everlive-Expand': JSON.stringify(expandExpression)
            };
            return this.withHeaders(expandHeader);
        },

        _applyQueryOffline: function (query) {
            var self = this;

            if (!query.applyOffline) {
                query.onError.call(this, new EverliveError('The applyOffline must be false when working offline.'));
            } else {
                self.offlineStorage.processQuery(query)
                    .then(function () {
                        query.onSuccess.apply(this, arguments);
                    }, function (err) {
                        if (!err.code) {
                            err = new EverliveError(err.message, EverliveErrors.generalDatabaseError.code);
                        }
                        query.onError.call(this, err);
                    });
            }
        },

        _sendRequest: function (query, online) {
            var self = this;

            var originalSuccess = query.onSuccess;
            query.onSuccess = function () {
                var args = arguments;
                var data = args[0];

                if (query.applyOffline) {
                    return self._applyOffline(query, data)
                        .then(function () {
                            originalSuccess.apply(this, args);
                        }, function (err) {
                            if (online && err.code === EverliveErrors.operationNotSupportedOffline.code) {
                                originalSuccess.apply(this, args);
                            } else {
                                query.onError.apply(this, arguments);
                            }
                        });
                } else {
                    return originalSuccess.apply(this, args);
                }
            };

            var getRequestOptionsFromQuery = RequestOptionsBuilder[query.operation];
            var requestOptions = getRequestOptionsFromQuery(query);
            this._setAdditionalHeaders(query, requestOptions);
            var request = new Request(this.setup, requestOptions);
            request.send();
        },

        _applyQueryOnline: function (query) {
            if (query.useCache) {
                this.everlive.cache._cacheDataQuery(query);
            } else {
                this._sendRequest(query, true);
            }
        },

        _setAdditionalHeaders: function (query, requestOptions) {
            if (query.isSync) {
                requestOptions.headers[constants.Headers.sync] = true;
            }

            var sdkHeaderValue = {
                sdk: 'js',
                platform: everlivePlatform
            };

            requestOptions.headers[constants.Headers.sdk] = JSON.stringify(sdkHeaderValue);
        },

        /**
         * Processes a query with all of its options. Applies the operation online/offline
         * @param {DataQuery} query The query to process
         * @private
         * @param {DataQuery} query
         * @returns {Promise}
         */
        processDataQuery: function (query) {
            var self = this;

            var offlineStorageEnabled = this.everlive._isOfflineStorageEnabled();
            query.useOffline = offlineStorageEnabled ? !this.everlive.isOnline() : false;

            if (this.options) {
                query = _.defaults(this.options, query);
            }
            var isCachingEnabled = (this.everlive.setup.caching === true || (this.everlive.setup.caching && this.everlive.setup.caching.enabled));
            var isSupportedInOffline = utils.isQuerySupportedOffline(query);

            query.useCache = isCachingEnabled && !query.isSync && isSupportedInOffline;
            query.applyOffline = query.applyOffline !== undefined ? query.applyOffline : offlineStorageEnabled || query.useCache;

            if (!query.useCache && query.forceCache) {
                query.onError.call(this, new EverliveError(EverliveErrors.cannotForceCacheWhenDisabled));
            }

            this.options = null;
            if (!query.skipAuth && this.everlive.authentication && this.everlive.authentication.isAuthenticationInProgress()) {
                query.onError = _.wrap(query.onError, function (errorFunc, err) {
                    if (err.code === EverliveErrors.invalidToken.code || err.code === EverliveErrors.expiredToken.code) {
                        var whenAuthenticatedPromise = self.everlive.authentication._ensureAuthentication();
                        if (!query.noRetry) {
                            whenAuthenticatedPromise.then(function () {
                                return self.processDataQuery(query);
                            });
                        }
                    } else {
                        errorFunc.call(self, err);
                    }
                });

                //if we are currently authenticating, queue the data query after we have logged in
                if (self.everlive.authentication.isAuthenticating()) {
                    var whenAuthenticatedPromise = self.everlive.authentication._ensureAuthentication();
                    if (!query.noRetry) {
                        whenAuthenticatedPromise.then(function () {
                            return self.processDataQuery(query);
                        });
                    }

                    return whenAuthenticatedPromise;
                }
            }

            if ((!query.isSync && this.offlineStorage && this.offlineStorage.isSynchronizing())) {
                query.onError.call(this, new EverliveError(EverliveErrors.syncInProgress));
            } else if (query.useOffline) {
                this._applyQueryOffline(query);
            } else {
                this._applyQueryOnline(query);
            }
        },
        // TODO implement options: { requestSettings: { executeServerCode: false } }. power fields queries could be added to that options argument
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        get: function (filter, success, error) {
            var self = this;

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.read,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: successCb,
                    onError: errorCb
                });

                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        // TODO handle options
        // TODO think to pass the id as a filter

        /**
         * Gets a data item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets an item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         * */
        getById: function (id, success, error) {
            var self = this;

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.readById,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    additionalOptions: {
                        id: id
                    },
                    onSuccess: successCb,
                    onError: errorCb
                });


                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Gets the count of the data items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets the count of the items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        count: function (filter, success, error) {
            var self = this;

            return buildPromise(function (sucessCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.count,
                    collectionName: self.collectionName,
                    filter: filter,
                    parse: Request.parsers.single,
                    onSuccess: sucessCb,
                    onError: errorCb
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Creates a data item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data Item or items that will be created.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Creates an item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data The item or items that will be created.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        create: function (data, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.create,
                    collectionName: self.collectionName,
                    data: data,
                    parse: Request.parsers.single,
                    onSuccess: mergeResultData(data, success),
                    onError: error
                });


                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updatedObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        rawUpdate: function (attrs, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.rawUpdate,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: attrs,
                    onSuccess: success,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        // TODO: Check if there is a case in which replace = true is passed to this function
        _update: function (attrs, filter, single, replace, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var data = {};
                data[replace ? '$replace' : '$set'] = attrs;

                // if the update is for a single item - merge the update result and add the ModifiedAt field to the result
                var onSuccess = single ? mergeUpdateResultData(attrs, success) : success;

                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.update,
                    collectionName: self.collectionName,
                    parse: Request.parsers.update,
                    filter: filter,
                    data: data,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    },
                    onSuccess: onSuccess,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Updates a single data item. This operation takes an object that specifies both the data item to be updated and the updated values.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} item The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the provided item.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} model The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        updateSingle: function (model, success, error) {
            return this._update(model, null, true, false, success, error);
        },

        /**
         * Updates all items that match a filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} updateObject The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all items that match the filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} model The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        update: function (model, filter, success, error) {
            return this._update(model, filter, false, false, success, error);
        },
        _destroy: function (attrs, filter, single, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: single ? DataQuery.operations.removeSingle : DataQuery.operations.remove,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: success,
                    onError: error,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    }
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} item Object containing the item ID to be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} model Object containing the item ID to be deleted.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        destroySingle: function (model, success, error) {
            return this._destroy(model, null, true, success, error);
        },

        /**
         * Deletes all data items that match a filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes all items that match the filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        destroy: function (filter, success, error) {
            return this._destroy(null, filter, false, success, error);
        },

        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {object} operationParameters An object that accepts operation parameters.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of an item with a specified ID.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        setAcl: function (acl, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setAcl,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    filter: filter,
                    additionalOptions: {
                        acl: acl
                    },
                    onSuccess: success,
                    onError: error
                });

                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {object} operationParameters An object that accepts operation parameters.
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.useOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        setOwner: function (ownerId, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setOwner,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: {
                        Owner: ownerId
                    },
                    onSuccess: success,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} item An object containing the item that is being saved.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} model An object containing the item that is being saved.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        save: function (model, success, error) {
            var self = this;
            var isNew = this.isNew(model);

            return buildPromise(function (success, error) {
                function saveSuccess(res) {
                    res.type = isNew ? 'create' : 'update';
                    success(res);
                }

                function saveError(err) {
                    err.type = isNew ? 'create' : 'update';
                    error(err);
                }

                if (isNew) {
                    return self.create(model, saveSuccess, saveError);
                } else {
                    return self.updateSingle(model, saveSuccess, saveError);
                }
            }, success, error);
        },
        /**
         * Checks if the specified data item is new or not.
         * @memberOf Data.prototype
         * @method
         * @param model Item to check.
         * @returns {boolean}
         */
        isNew: function (model) {
            return typeof model[idField] === 'undefined';
        }
    };

    return Data;
}());

},{"../Everlive":41,"../EverliveError":42,"../Request":47,"../common":53,"../constants":54,"../everlive.platform":56,"../query/DataQuery":80,"../query/RequestOptionsBuilder":83,"../utils":94}],92:[function(require,module,exports){
/**
 * @class Files
 * @protected
 * @extends Data
 */

var buildPromise = require('../utils').buildPromise;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var utils = require('../utils');

module.exports.addFilesFunctions = function addFilesFunctions(ns) {
    /**
     * Get a URL that can be used as an endpoint for uploading a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUploadUrl
     * @returns {string}
     */
    ns.getUploadUrl = function () {
        return utils.buildUrl(this.setup) + this.collectionName;
    };

    /**
     * Get the download URL for a file.
     * @memberof Files.prototype
     * @method getDownloadUrl
     * @deprecated
     * @see {@link Files.getDownloadUrlById}
     * @param {string} fileId The ID of the file.
     * @returns {string} url The download URL.
     */
    ns.getDownloadUrl = function (fileId) {
        return utils.buildUrl(this.setup) + this.collectionName + '/' + fileId + '/Download';
    };

    ns._getUpdateUrl = function (fileId) {
        return this.collectionName + '/' + fileId + '/Content';
    };

    /**
     * Get a URL that can be used as an endpoint for updating a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUpdateUrl
     * @param {string} fileId The ID of the file.
     * @returns {string} url The update URL.
     */
    ns.getUpdateUrl = function (fileId) {
        return utils.buildUrl(this.setup) + this._getUpdateUrl(fileId);
    };

    /**
     * Updates a file's content
     * @memberof Files.prototype
     * @method updateContent
     * @param {string} fileId File ID.
     * @param {Object} file The file metadata and the base64 encoded file content.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     * @returns {Promise} The promise for the request
     */
    ns.updateContent = function (fileId, file, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesUpdateContent,
                // the passed file content is base64 encoded
                data: file,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                onSuccess: success,
                onError: error
            });


            return self.processDataQuery(dataQuery);
        }, success, error);
    };

    /**
     * Gets the download URL for a file by ID.
     * @memberof Files.prototype
     * @method getDownloadUrlById
     * @param {string} fileId File ID.
     * @returns {Promise} The promise for the request
     */
    /**
     * Gets the download URL for a file by ID.
     * @memberof Files.prototype
     * @method getDownloadUrlById
     * @param {string} fileId File ID.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.getDownloadUrlById = function (fileId, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesGetDownloadUrlById,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                parse: Request.parsers.single,
                onSuccess: function (data) {
                    success(data.result.Uri);
                },
                onError: error
            });


            return self.processDataQuery(dataQuery);
        }, success, error);
    };

    ns.download = function (url, localPath, options, trustAllHosts, success, error) {
        return buildPromise(function (success, error) {
            if (!trustAllHosts) {
                trustAllHosts = false;
            }

            var fileTransfer = new FileTransfer();
            fileTransfer.download(url, localPath, success, error, trustAllHosts, options);
        }, success, error);
    };

    ns.upload = function (localPath, url, options, trustAllHosts, success, error) {
        return buildPromise(function (success, error) {
            if (!trustAllHosts) {
                trustAllHosts = false;
            }
            var fileTransfer = new FileTransfer();
            var uri = encodeURI(url);
            fileTransfer.upload(localPath, uri, success, error, options, trustAllHosts);
        }, success, error);
    }
};
},{"../Request":47,"../query/DataQuery":80,"../utils":94}],93:[function(require,module,exports){
/**
 * @class Users
 * @extends Data
 * @protected
 */

var utils = require('../utils');
var buildPromise = utils.buildPromise;
var guardUnset = utils.guardUnset;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var _ = require('../common')._;
var EverliveError = require('../EverliveError').EverliveError;
var EverliveErrors = require('../EverliveError').EverliveErrors;

module.exports.addUsersFunctions = function addUsersFunctions(ns, everlive) {

    /**
     * Registers a new user with username and password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param {object} userInfo Additional information for the user (ex. DisplayName, Email, etc.)
     * @returns {Promise} The promise for the request.
     */
    /**
     * Registers a new user using a username and a password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param attrs
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.register = function (username, password, attrs, success, error) {
        guardUnset(username, 'username');
        guardUnset(password, 'password');
        var user = {
            Username: username,
            Password: password
        };
        _.extend(user, attrs);
        return this.create(user, success, error);
    };

    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK. The success function is called with {@link Users.ResultTypes.curentUserResult}.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @returns {Promise} The promise for the request.
     */
    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK. The success function is called with {@link Users.ResultTypes.curentUserResult}.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.currentUser = function (success, error) {
        var self = this;
        var id = self.everlive._isOfflineStorageEnabled() && self.everlive.isOffline() ? self.everlive.setup.principalId : 'me';
        return buildPromise(function (success, error) {
            if (id === 'me' && !self.everlive.setup.token && !self.everlive.setup.masterKey || !id) {
                return success({result: null});
            }

            self.getById(id).then(function (res) {
                    if (typeof res.result !== 'undefined') {
                        success({result: res.result});
                    } else {
                        success({result: null});
                    }
                },
                function (err) {
                    if (self.everlive.authentication && self.everlive.authentication.isAuthenticationInProgress()) {
                        success({result: null});
                    } else if (err.code === 601) { // invalid request, i.e. the access token is missing
                        success({result: null});
                    } else if (err.code === 801) {
                        error(new EverliveError(EverliveErrors.invalidToken));
                    } else {
                        error(err);
                    }
                }
            );
        }, success, error);
    };

    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.changePassword = function (username, password, newPassword, keepTokens, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            success = _.wrap(success, function (success, data) {
                if (data && data.result) {
                    if (!keepTokens) {
                        ns.clearAuthorization();
                    }
                }
                return success(data);
            });

            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userChangePassword,
                collectionName: self.collectionName,
                data: {
                    Username: username,
                    Password: password,
                    NewPassword: newPassword
                },
                additionalOptions: {
                    keepTokens: keepTokens
                },
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(dataQuery)
        }, success, error)
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.login}
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.login}
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.login = function (username, password, success, error) {
        return everlive.authentication.login(username, password, success, error);

    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.logout}
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.logout}
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.logout = function (success, error) {
        return everlive.authentication.logout(success, error);

    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithFacebook}
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithFacebook}
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithFacebook = function (accessToken, success, error) {
        return everlive.authentication.loginWithFacebook(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a Backend Services user with a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.         * @param {Function} [success] a success callback.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithFacebook = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromFacebook = function (userId, success, error) {
        return ns._unlinkFromProvider('Facebook', userId, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithADFS}
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithADFS}
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithADFS = function (accessToken, success, error) {
        return everlive.authentication.loginWithADFS(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithADFS = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromADFS = function (userId, success, error) {
        return ns._unlinkFromProvider('ADFS', userId, success, error);
    };

    /**
     * Log in a user using a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithLiveID}
     * @param {string} accessToken Microsoft Account access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithLiveID}
     * @param {string} accessToken Microsoft Account access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithLiveID = function (accessToken, success, error) {
        return everlive.authentication.loginWithLiveID(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Microsoft Account access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Microsoft Account access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithLiveID = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Microsoft Account access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Microsoft Account access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromLiveID = function (userId, success, error) {
        return ns._unlinkFromProvider('LiveID', userId, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithGoogle}
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithGoogle}
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithGoogle = function (accessToken, success, error) {
        return everlive.authentication.loginWithGoogle(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithGoogle = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromGoogle = function (userId, success, error) {
        return ns._unlinkFromProvider('Google', userId, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithTwitter = function (token, tokenSecret, success, error) {
        return everlive.authentication.loginWithTwitter(token, tokenSecret, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.         * Links a Backend Services user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithTwitter = function (userId, token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromTwitter = function (userId, success, error) {
        return ns._unlinkFromProvider('Twitter', userId, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Users.prototype
     * @method setAuthorization
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.setAuthorization}
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */
    ns.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        everlive.authentication.setAuthorization(token, tokenType, principalId)
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the current authorization token is not invalidated.
     * @method clearAuthorization
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.clearAuthorization}
     * @memberOf Users.prototype
     */
    ns.clearAuthorization = function clearAuthorization() {
        everlive.authentication.setAuthorization(null, null, null);
    };

    /**
     * Sends a password reset email to a specified user.
     * @memberOf Users.prototype
     * @method resetPassword
     * @name resetPassword
     * @param {Object} user The user object, which must container either username or email address.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Sends a password reset email to a specified user.
     * @memberOf Users.prototype
     * @method resetPassword
     * @name resetPassword
     * @param {Object} user The user object, which must container either username or email address.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.resetPassword = function (user, success, error) {
        var self = this;

        return buildPromise(function (successCb, errorCb) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userResetPassword,
                collectionName: self.collectionName,
                data: user,
                onSuccess: successCb,
                onError: errorCb
            });

            return self.processDataQuery(dataQuery);
        }, success, error);
    };

    /**
     * Set a new password for a user using a password reset code.
     * @memberOf Users.prototype
     * @method setPassword
     * @name setPassword
     * @param {object} setPasswordObject The object, which contains information necessary for changing the user password.
     * @param {string} setPasswordObject.ResetCode The reset code obtained using a password reset email.
     * @param {string} setPasswordObject.NewPassword The new password for the user.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Set a new password for a user using a password reset code.
     * @memberOf Users.prototype
     * @method setPassword
     * @name setPassword
     * @param {object} setPasswordObject The object, which contains information necessary for changing the user password.
     * @param {string} setPasswordObject.ResetCode The reset code obtained using a password reset email.
     * @param {string} setPasswordObject.NewPassword The new password for the user.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    /**
     * Set a new password for a user using a password reset code.
     * @memberOf Users.prototype
     * @method setPassword
     * @name setPassword
     * @param {object} setPasswordObject The object, which contains information necessary for changing the user password.
     * @param {number} setPasswordObject.Username The username that the password will be changed.
     * @param {number} setPasswordObject.SecretQuestionId The id of the secret question.
     * @param {string} setPasswordObject.SecretAnswer The answer to the secret question.
     * @param {string} setPasswordObject.NewPassword The new password for the user.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Set a new password for a user using a password reset code.
     * @memberOf Users.prototype
     * @method setPassword
     * @name setPassword
     * @param {object} setPasswordObject The object, which contains information necessary for changing the user password.
     * @param {number} setPasswordObject.Username The username that the password will be changed.
     * @param {number} setPasswordObject.SecretQuestionId The id of the secret question.
     * @param {string} setPasswordObject.SecretAnswer The answer to the secret question.
     * @param {string} setPasswordObject.NewPassword The new password for the user.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.setPassword = function (setPasswordObject, success, error) {
        var self = this;

        return buildPromise(function (successCb, errorCb) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userSetPassword,
                collectionName: self.collectionName,
                data: setPasswordObject,
                onSuccess: successCb,
                onError: errorCb
            });

            return self.processDataQuery(dataQuery);
        }, success, error);
    };

    ns._linkWithProvider = function (identity, userId, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var query = new DataQuery({
                additionalOptions: {
                    id: userId
                },
                operation: DataQuery.operations.userLinkWithProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(query);
        }, success, error);
    };

    ns._unlinkFromProvider = function (providerName, userId, success, error) {
        var identity = {
            Provider: providerName
        };
        var self = this;
        return buildPromise(function (success, error) {
            var query = new DataQuery({
                additionalOptions: {
                    userId: userId
                },
                operation: DataQuery.operations.userUnlinkFromProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(query);
        }, success, error);
    };
};
},{"../EverliveError":42,"../Request":47,"../common":53,"../query/DataQuery":80,"../utils":94}],94:[function(require,module,exports){
var EverliveError = require('./EverliveError').EverliveError;
var common = require('./common');
var _ = common._;
var rsvp = common.rsvp;
var Everlive = require('./Everlive');
var platform = require('./everlive.platform');
var path = require('path');

var utils = {};

utils.guardUnset = function guardUnset(value, name, message) {
    if (!message) {
        message = 'The ' + name + ' is required';
    }
    if (typeof value === 'undefined' || value === null) {
        throw new EverliveError(message);
    }
};

utils.parseUtilities = {
    getReviver: function (parseOnlyCompleteDateTimeString) {
        var dateParser;
        if (parseOnlyCompleteDateTimeString) {
            dateParser = utils.parseUtilities.parseIsoDateString;
        } else {
            dateParser = utils.parseUtilities.parseOnlyCompleteDateTimeString;
        }

        return function (key, value) {
            if (typeof value === 'string') {
                var date = dateParser(value);
                if (date) {
                    value = date;
                }
            }

            return value;
        };
    },

    parseIsoDateString: function (string) {
        var match;
        if (match = string.match(/^(\d{4})(-(\d{2})(-(\d{2})(T(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2}))))?))$/)) {
            // DateTime
            var secondParts = match[12];
            if (secondParts) {
                if (secondParts.length > 3) {
                    secondParts = Math.round(Number(secondParts.substr(0, 3) + '.' + secondParts.substr(3)));
                }
                else if (secondParts.length < 3) {
                    // if the secondParts are one or two characters then two or one zeros should be appended
                    // in order to have the correct number for milliseconds ('.67' means 670ms not 67ms)
                    secondParts += secondParts.length === 2 ? '0' : '00';
                }
            }
            var date = new Date(
                Date.UTC(
                    Number(match[1]), // year
                    (Number(match[3]) - 1) || 0, // month
                    Number(match[5]) || 0, // day
                    Number(match[7]) || 0, // hour
                    Number(match[8]) || 0, // minute
                    Number(match[10]) || 0, // second
                    Number(secondParts) || 0
                )
            );

            if (match[13] && match[13] !== "Z") {
                var h = Number(match[16]) || 0,
                    m = Number(match[17]) || 0;

                h *= 3600000;
                m *= 60000;

                var offset = h + m;
                if (match[15] === "+")
                    offset = -offset;

                date = new Date(date.valueOf() + offset);
            }

            return date;
        } else {
            return null;
        }
    },

    parseOnlyCompleteDateTimeString: function (string) {
        if (/^\d{4}-\d{2}-\d{2}$/.test(string)) {
            // Date
            return null;
        }

        if (/^(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2})))?$/.test(string)) {
            // Time
            return null;
        }

        return utils.parseUtilities.parseIsoDateString(string);
    },

    traverse: function (obj, func) {
        var key, value, newValue;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                value = obj[key];
                newValue = func(key, value);
                obj[key] = newValue;
                if (value === newValue && typeof value === 'object') {
                    utils.parseUtilities.traverse(value, func);
                }
            }
        }
        return obj;
    },

    traverseAndRevive: function (data, reviver) {
        if (!reviver) {
            reviver = utils.parseUtilities.getReviver();
        }

        return utils.parseUtilities.traverse(data, reviver);
    },

    parseError: function (reviver, error) {
        if (typeof error === 'string' && error.length > 0) {
            try {
                error = JSON.parse(error);
                return {message: error.message, code: error.errorCode};
            } catch (e) {
                return error;
            }
        } else {
            return error;
        }
    },

    _parseInternal: function (reviver, data) {
        if (typeof data === 'string' && data.length > 0) {
            data = JSON.parse(data, reviver);
        } else if (typeof data === 'object') {
            utils.parseUtilities.traverseAndRevive(data, reviver);
        }

        return data;
    },

    _transformResult: function (data, additionalProperties) {
        if (data) {
            var result = {result: data.Result};
            _.extend(result, additionalProperties);
            return result;
        } else {
            return data;
        }
    },

    parseResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {count: data.Count});
    },

    parseSingleResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data);
    },

    parseUpdateResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {ModifiedAt: data.ModifiedAt});
    },

    parseJSON: function (json) {
        return JSON.parse(json, utils.parseUtilities.getReviver());
    }
};

utils.buildPromise = function buildPromise(operation, success, error) {
    var callbacks = utils.getCallbacks(success, error);
    operation(callbacks.success, callbacks.error);
    return callbacks.promise;
};

utils.getCallbacks = function (success, error) {
    var promise;
    var createPromise = function () {
        return new rsvp.Promise(function (resolve, reject) {
            success = function (data) {
                resolve(data);
            };
            error = function (error) {
                reject(error);
            };
        });
    };

    if (platform.isNodejs) {
        // node js style continuation
        if (typeof success === 'function' && typeof error !== 'function') {
            var callback = success;
            success = function (data, response) {
                callback(null, data, response);
            };
            error = function (error) {
                callback(error);
            };
        } else if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    } else {
        if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    }

    return {promise: promise, success: success, error: error};
};

utils.buildAuthHeader = function buildAuthHeader(setup, options) {
    var authHeaderValue = null;
    if (options && options.authHeaders === false) {
        return authHeaderValue;
    }
    if (setup.token) {
        authHeaderValue = (setup.tokenType || 'bearer') + ' ' + setup.token;
    }
    else if (setup.masterKey) {
        authHeaderValue = 'masterkey ' + setup.masterKey;
    }
    if (authHeaderValue) {
        return {Authorization: authHeaderValue};
    } else {
        return null;
    }
};

utils.DeviceRegistrationResult = function DeviceRegistrationResult(token) {
    this.token = token;
};

utils.cloneDate = function (date) {
    return new Date(date);
};

utils.buildUrl = function (setup) {
    var url = '';
    if (typeof setup.scheme === 'string') {
        url += setup.scheme + ':';
    }
    url += setup.url;
    if (setup.apiKey) {
        url += setup.apiKey + '/';
    }
    return url;
};

utils.getDbOperators = function (expression, shallow) {
    var dbOperators = [];

    if (typeof expression === 'string') {
        return dbOperators;
    }

    var modifierKeys = Object.keys(expression);
    _.each(modifierKeys, function (key) {
        if (key.indexOf('$') === 0) {
            dbOperators.push(key);
        } else if (typeof expression[key] === 'object' && !shallow) {
            dbOperators = dbOperators.concat(utils.getDbOperators(expression[key]));
        }
    });

    return dbOperators;
};

utils.disableRequestCache = function (url, method) {
    if (method === 'GET') {
        var timestamp = (new Date()).getTime();
        var separator = url.indexOf('?') > -1 ? '&' : '?';
        url += separator + '_el=' + timestamp;
    }

    return url;
};

var unsupportedDbOperators = [
    '$geoWithin',
    '$geoIntersects',
    '$near',
    '$within',
    '$nearSphere'
];

utils.getUnsupportedOperators = function (filter) {
    var dbOperators = utils.getDbOperators(filter);
    return _.intersection(dbOperators, unsupportedDbOperators);
};

// http://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid
utils.isGuid = function (str) {
    return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(str);
};

utils.isQuerySupportedOffline = function (query) {
    var queryParams = query.getQueryParameters();
    var hasExpandExpression = !_.isEmptyObject(queryParams.expand);
    var unsupportedOperators = utils.getUnsupportedOperators(queryParams.filter);
    var hasUnsupportedOperators = unsupportedOperators.length !== 0;
    var isUnsupportedInOffline = hasExpandExpression || hasUnsupportedOperators;
    return !isUnsupportedInOffline;
};

// http://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript/16245768#16245768
utils.b64toBlob = function (b64Data, contentType, sliceSize) {
    contentType = contentType || '';
    sliceSize = sliceSize || 512;

    var byteCharacters = atob(b64Data);
    var byteArrays = [];

    for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        var slice = byteCharacters.slice(offset, offset + sliceSize);

        var byteNumbers = new Array(slice.length);
        for (var i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
        }

        var byteArray = new Uint8Array(byteNumbers);

        byteArrays.push(byteArray);
    }

    var blob = new Blob(byteArrays, {type: contentType});
    return blob;
};

// http://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
utils.arrayBufferToBase64 = function (buffer) {
    var binary = '';
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }

    return btoa(binary);
};

utils.successfulPromise = function (data) {
    return new rsvp.Promise(function (resolve) {
        resolve(data);
    });
};

utils.rejectedPromise = function (err) {
    return new rsvp.Promise(function (resolve, reject) {
        reject(err);
    });
};

utils.transformPlatformPath = function transformPlatformPath(platformPath) {
    if (!platformPath) {
        return '';
    }

    if (platform.isWindowsPhone) {
        if (platformPath.charAt(0) === '/' && platformPath.charAt(1) !== '/') {
            platformPath = '/' + platformPath;
        }
    } else { //TODO: probably desktop too
        if (platformPath.indexOf('file:/') !== -1 && platformPath.indexOf('file:///') === -1) {
            platformPath = platformPath.replace('file:/', 'file:///');
        }
    }

    return platformPath;
};

utils._stringCompare = function (string, check) {
    return string.toLowerCase() === check;
};

utils.isContentType = {
    files: function (collectionName) {
        return utils._stringCompare(collectionName, 'files');
    },
    users: function (collectionName) {
        return utils._stringCompare(collectionName, 'users');
    }
};

utils.isElement = {
    _isElement: function (el, check) {
        var tag = el;

        if (typeof tag !== 'string') {
            if (el instanceof HTMLElement) {
                tag = el.tagName;
            }
        }

        return utils._stringCompare(tag, check);
    },
    image: function (el) {
        return utils.isElement._isElement(el, 'img');
    },
    anchor: function (el) {
        return utils.isElement._isElement(el, 'a');
    }
};

utils.joinPath = function joinPath() {
    var args = [].slice.apply(arguments).map(function (arg) {
        return arg || '';
    });

    var joinedPath = path.join.apply(path, args);
    return utils.transformPlatformPath(joinedPath);
};

utils.uuid = function () {
    //http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
    var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });

    return uuid;
};

utils.getId = function (obj) {
    return obj.Id || obj._id || obj.id;
};

module.exports = utils;

},{"./Everlive":41,"./EverliveError":42,"./common":53,"./everlive.platform":56,"path":4}]},{},[61])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvbm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvbm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbW9kcy5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9ub2RlX21vZHVsZXMvY29tcG9uZW50LXR5cGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2RlYnVnL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2RvdC1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2RvdC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL3R5cGUtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9tb25nby1lcWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL29iamVjdC1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvb3BzLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2NyeXB0b2pzLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9hZXMuanMiLCJub2RlX21vZHVsZXMvbm9kZS1jcnlwdG9qcy1hZXMvbGliL2NpcGhlci1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9lbmMtYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9ldnBrZGYuanMiLCJub2RlX21vZHVsZXMvbm9kZS1jcnlwdG9qcy1hZXMvbGliL2pzb25mb3JtYXR0ZXIuanMiLCJub2RlX21vZHVsZXMvbm9kZS1jcnlwdG9qcy1hZXMvbGliL21kNS5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9Db25zdGFudHMuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvRXhlY3V0aW9uVHJlZS5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9FeHBhbmRFcnJvci5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9Qcm9jZXNzb3IuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvUmVsYXRpb25Ob2RlLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL1JlbGF0aW9uVHJlZUJ1aWxkZXIuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3Ivbm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsInNyYy9BdXRvUXVldWUuanMiLCJzcmMvRXZlbnRFbWl0dGVyUHJveHkuanMiLCJzcmMvRXZlcmxpdmUuanMiLCJzcmMvRXZlcmxpdmVFcnJvci5qcyIsInNyYy9FeHBhbmRQcm9jZXNzb3IuanMiLCJzcmMvRXhwcmVzc2lvbi5qcyIsInNyYy9HZW9Qb2ludC5qcyIsInNyYy9QdXNoLmpzIiwic3JjL1JlcXVlc3QuanMiLCJzcmMvU2V0dXAuanMiLCJzcmMvYXV0aC9BdXRoZW50aWNhdGlvbi5qcyIsInNyYy9hdXRoL0F1dGhlbnRpY2F0aW9uU2V0dXAuanMiLCJzcmMvY2FjaGluZy9DYWNoZU1vZHVsZS5qcyIsInNyYy9jYWNoaW5nL2NhY2hpbmcuanMiLCJzcmMvY29tbW9uLmpzIiwic3JjL2NvbnN0YW50cy5qcyIsInNyYy9lbmNyeXB0aW9uL0NyeXB0b2dyYXBoaWNQcm92aWRlci5qcyIsInNyYy9ldmVybGl2ZS5wbGF0Zm9ybS5qcyIsInNyYy9oZWxwZXJzL2hlbHBlcnMuanMiLCJzcmMvaGVscGVycy9odG1sL2h0bWxIZWxwZXIuanMiLCJzcmMvaGVscGVycy9odG1sL2h0bWxIZWxwZXJPZmZsaW5lTW9kdWxlLmpzIiwic3JjL2hlbHBlcnMvaHRtbC9odG1sSGVscGVyUmVzcG9uc2l2ZU1vZHVsZS5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9rZW5kby9rZW5kby5ldmVybGl2ZS5qcyIsInNyYy9taXhpbnMvbWl4aW5zLmpzIiwic3JjL21peGlucy91bmRlcnNjb3JlQ29tcGFjdE9iamVjdC5qcyIsInNyYy9taXhpbnMvdW5kZXJzY29yZURlZXBFeHRlbmRzLmpzIiwic3JjL21peGlucy91bmRlcnNjb3JlSXNPYmplY3RFbXB0eS5qcyIsInNyYy9vZmZsaW5lL09mZmxpbmVGaWxlc01vZHVsZS5qcyIsInNyYy9vZmZsaW5lL09mZmxpbmVGaWxlc1Byb2Nlc3Nvci5qcyIsInNyYy9vZmZsaW5lL09mZmxpbmVRdWVyeVByb2Nlc3Nvci5qcyIsInNyYy9vZmZsaW5lL09mZmxpbmVTdG9yYWdlTW9kdWxlLmpzIiwic3JjL29mZmxpbmUvb2ZmbGluZS5qcyIsInNyYy9vZmZsaW5lL29mZmxpbmVQZXJzaXN0ZXJzLmpzIiwic3JjL29mZmxpbmUvb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5qcyIsInNyYy9vZmZsaW5lL3BlcnNpc3RlcnMvQmFzZVBlcnNpc3Rlci5qcyIsInNyYy9vZmZsaW5lL3BlcnNpc3RlcnMvRmlsZVN5c3RlbVBlcnNpc3Rlci5qcyIsInNyYy9vZmZsaW5lL3BlcnNpc3RlcnMvTG9jYWxTdG9yYWdlUGVyc2lzdGVyLmpzIiwic3JjL3B1c2gvQ29yZG92YUN1cnJlbnREZXZpY2UuanMiLCJzcmMvcHVzaC9DdXJyZW50RGV2aWNlLmpzIiwic3JjL3B1c2gvTmF0aXZlU2NyaXB0Q3VycmVudERldmljZS5qcyIsInNyYy9xdWVyeS9EYXRhUXVlcnkuanMiLCJzcmMvcXVlcnkvUXVlcnkuanMiLCJzcmMvcXVlcnkvUXVlcnlCdWlsZGVyLmpzIiwic3JjL3F1ZXJ5L1JlcXVlc3RPcHRpb25zQnVpbGRlci5qcyIsInNyYy9xdWVyeS9XaGVyZVF1ZXJ5LmpzIiwic3JjL3JlcXdlc3QubmF0aXZlc2NyaXB0LmpzIiwic3JjL3JlcXdlc3Qubm9kZWpzLmpzIiwic3JjL3N0b3JhZ2VzL0ZpbGVTdG9yZS5qcyIsInNyYy9zdG9yYWdlcy9Mb2NhbFN0b3JlLmpzIiwic3JjL3N0b3JhZ2VzL05hdGl2ZVNjcmlwdEZpbGVTdG9yZS5qcyIsInNyYy9zdG9yYWdlcy9XZWJGaWxlU3RvcmUuanMiLCJzcmMvdHlwZXMvRGF0YS5qcyIsInNyYy90eXBlcy9GaWxlcy5qcyIsInNyYy90eXBlcy9Vc2Vycy5qcyIsInNyYy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1MEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwidmFyIGpzb24gPSB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgPyBKU09OIDogcmVxdWlyZSgnanNvbmlmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBzcGFjZSA9IG9wdHMuc3BhY2UgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHNwYWNlID0gQXJyYXkoc3BhY2UrMSkuam9pbignICcpO1xuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcbiAgICB2YXIgcmVwbGFjZXIgPSBvcHRzLnJlcGxhY2VyIHx8IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XG4gICAgICAgICAgICAgICAgdmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkob3B0cy5jbXApO1xuXG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeSAocGFyZW50LCBrZXksIG5vZGUsIGxldmVsKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSBzcGFjZSA/ICgnXFxuJyArIG5ldyBBcnJheShsZXZlbCArIDEpLmpvaW4oc3BhY2UpKSA6ICcnO1xuICAgICAgICB2YXIgY29sb25TZXBhcmF0b3IgPSBzcGFjZSA/ICc6ICcgOiAnOic7XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSByZXBsYWNlci5jYWxsKHBhcmVudCwga2V5LCBub2RlKTtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbi5zdHJpbmdpZnkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RyaW5naWZ5KG5vZGUsIGksIG5vZGVbaV0sIGxldmVsKzEpIHx8IGpzb24uc3RyaW5naWZ5KG51bGwpO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICddJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIGpzb24uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHNlZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKG5vZGUpLnNvcnQoY21wICYmIGNtcChub2RlKSk7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZSwga2V5LCBub2RlW2tleV0sIGxldmVsKzEpO1xuXG4gICAgICAgICAgICAgICAgaWYoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGpzb24uc3RyaW5naWZ5KGtleSlcbiAgICAgICAgICAgICAgICAgICAgKyBjb2xvblNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICArIHZhbHVlO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGtleVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAneycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ30nO1xuICAgICAgICB9XG4gICAgfSkoeyAnJzogb2JqIH0sICcnLCBvYmosIDApO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH07XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG4iLCJleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9saWIvc3RyaW5naWZ5Jyk7XG4iLCJ2YXIgYXQsIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgZXNjYXBlZSA9IHtcbiAgICAgICAgJ1wiJzogICdcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgICAnLyc6ICAnLycsXG4gICAgICAgIGI6ICAgICdcXGInLFxuICAgICAgICBmOiAgICAnXFxmJyxcbiAgICAgICAgbjogICAgJ1xcbicsXG4gICAgICAgIHI6ICAgICdcXHInLFxuICAgICAgICB0OiAgICAnXFx0J1xuICAgIH0sXG4gICAgdGV4dCxcblxuICAgIGVycm9yID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gQ2FsbCBlcnJvciB3aGVuIHNvbWV0aGluZyBpcyB3cm9uZy5cbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgbmFtZTogICAgJ1N5bnRheEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG0sXG4gICAgICAgICAgICBhdDogICAgICBhdCxcbiAgICAgICAgICAgIHRleHQ6ICAgIHRleHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIFxuICAgIG5leHQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgIGVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgYyArIFwiJyBpbnN0ZWFkIG9mICdcIiArIGNoICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICBcbiAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgIGF0ICs9IDE7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuICAgIFxuICAgIG51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICBzdHJpbmcgPSAnJztcbiAgICAgICAgXG4gICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgIGVycm9yKFwiQmFkIG51bWJlclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgIHZhciBoZXgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICB1ZmZmZjtcbiAgICAgICAgXG4gICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBzdHJpbmdcIik7XG4gICAgfSxcblxuICAgIHdoaXRlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBTa2lwIHdoaXRlc3BhY2UuXG5cbiAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdvcmQgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJVbmV4cGVjdGVkICdcIiArIGNoICsgXCInXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZSwgIC8vIFBsYWNlIGhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuXG4gICAgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAgIC8vIGVtcHR5IGFycmF5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIGFycmF5XCIpO1xuICAgIH0sXG5cbiAgICBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAgIC8vIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBvYmplY3RcIik7XG4gICAgfTtcblxudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsIGEgbnVtYmVyLFxuLy8gb3IgYSB3b3JkLlxuXG4gICAgd2hpdGUoKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAneyc6XG4gICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICBjYXNlICdbJzpcbiAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgY2FzZSAnXCInOlxuICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgY2FzZSAnLSc6XG4gICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuICAgIH1cbn07XG5cbi8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlIGFib3ZlXG4vLyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBcbiAgICB0ZXh0ID0gc291cmNlO1xuICAgIGF0ID0gMDtcbiAgICBjaCA9ICcgJztcbiAgICByZXN1bHQgPSB2YWx1ZSgpO1xuICAgIHdoaXRlKCk7XG4gICAgaWYgKGNoKSB7XG4gICAgICAgIGVycm9yKFwiU3ludGF4IGVycm9yXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmV2aXZlciBmdW5jdGlvbiwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSxcbiAgICAvLyBwYXNzaW5nIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIHRoZSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLCBzdGFydGluZyB3aXRoIGEgdGVtcG9yYXJ5IHJvb3Qgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIHJlc3VsdFxuICAgIC8vIGluIGFuIGVtcHR5IGtleS4gSWYgdGhlcmUgaXMgbm90IGEgcmV2aXZlciBmdW5jdGlvbiwgd2Ugc2ltcGx5IHJldHVybiB0aGVcbiAgICAvLyByZXN1bHQuXG5cbiAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyAoZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9KHsnJzogcmVzdWx0fSwgJycpKSA6IHJlc3VsdDtcbn07XG4iLCJ2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGdhcCxcbiAgICBpbmRlbnQsXG4gICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgIH0sXG4gICAgcmVwO1xuXG5mdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcbiAgICAvLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4gICAgLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbiAgICAvLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbiAgICAvLyBzZXF1ZW5jZXMuXG4gICAgXG4gICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgPyAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcbiAgICAvLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG4gICAgdmFyIGksICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICB2LCAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgIHBhcnRpYWwsXG4gICAgICAgIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgXG4gICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4gICAgLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbiAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gICAgICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcnJheS5pc0FycmF5XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlbSBpbiBicmFja2V0cy5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAgICAgJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmVcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmaWVkLlxuICAgICAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6IGdhcCA/XG4gICAgICAgICAgICAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICd9JyA6XG4gICAgICAgICAgICAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgdmFyIGk7XG4gICAgZ2FwID0gJyc7XG4gICAgaW5kZW50ID0gJyc7XG4gICAgXG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuICAgIC8vIG1hbnkgc3BhY2VzLlxuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gJyAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cbiAgICBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbiAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09ICdmdW5jdGlvbidcbiAgICAmJiAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG4gICAgcmV0dXJuIHN0cignJywgeycnOiB2YWx1ZX0pO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBvcHMgPSByZXF1aXJlKCcuL29wcycpO1xudmFyIGVxbCA9IHJlcXVpcmUoJ21vbmdvLWVxbCcpO1xudmFyIGRvdCA9IHJlcXVpcmUoJ2RvdC1jb21wb25lbnQnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcbnZhciBvYmplY3QgPSByZXF1aXJlKCdvYmplY3QtY29tcG9uZW50Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb25nby1xdWVyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZpbHRlcjtcbmV4cG9ydHMub3BzID0gb3BzO1xuXG4vKipcbiAqIEZpbHRlcnMgYW4gYG9iamAgYnkgdGhlIGdpdmVuIGBxdWVyeWAgZm9yIHN1YmRvY3VtZW50cy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8Qm9vbGVhbn0gZmFsc2UgaWYgbm8gbWF0Y2gsIG9yIG1hdGNoZWQgc3ViZG9jc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXIob2JqLCBxdWVyeSl7XG4gIG9iaiA9IG9iaiB8fCB7fTtcbiAgdmFyIHJldCA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBxdWVyeSkge1xuICAgIGlmICghcXVlcnkuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG5cbiAgICAvLyBzZWFyY2ggdmFsdWVcbiAgICB2YXIgdmFsID0gcXVlcnlba2V5XTtcblxuICAgIC8vIHNwbGl0IHRoZSBrZXkgaW50byBwcmVmaXggYW5kIHN1ZmZpeFxuICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgdmFyIHRhcmdldCA9IG9iajtcbiAgICB2YXIgcHJlZml4LCBzZWFyY2g7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgIHdhbGtfa2V5czpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldFtrZXlzW2ldXTtcblxuICAgICAgc3dpdGNoICh0eXBlKHRhcmdldCkpIHtcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgIC8vIGlmIGl0J3MgYW4gYXJyYXkgc3ViZG9jdW1lbnQgc2VhcmNoIHdlIHN0b3AgaGVyZVxuICAgICAgICAgIHByZWZpeCA9IGtleXMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICBzZWFyY2ggPSBrZXlzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG5cbiAgICAgICAgICBkZWJ1Zygnc2VhcmNoaW5nIGFycmF5IFwiJXNcIicsIHByZWZpeCk7XG5cbiAgICAgICAgICAvLyB3ZSBzcGVjaWFsIGNhc2Ugb3BlcmF0b3JzIHRoYXQgZG9uJ3Qgd2FsayB0aGUgYXJyYXlcbiAgICAgICAgICBpZiAodmFsLiRzaXplICYmICFzZWFyY2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSh2YWwsIHRhcmdldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2FsayBzdWJkb2NzXG4gICAgICAgICAgdmFyIHN1YnNldCA9IHJldFtwcmVmaXhdIHx8IHRhcmdldDtcblxuICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBzdWJzZXQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgcSA9IHt9O1xuICAgICAgICAgICAgICBxW3NlYXJjaF0gPSB2YWw7XG4gICAgICAgICAgICAgIGlmICgnb2JqZWN0JyA9PSB0eXBlKHN1YnNldFtpaV0pKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgc3ViZG9jIHNlYXJjaCB3aXRoIHF1ZXJ5ICVqJywgcSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcihzdWJzZXRbaWldLCBxKSkge1xuICAgICAgICAgICAgICAgICAgLy8gd2UgaWdub3JlIHRoZSByZXQgdmFsdWUgb2YgZmlsdGVyXG4gICAgICAgICAgICAgICAgICBpZiAoIXJldFtwcmVmaXhdIHx8ICF+cmV0W3ByZWZpeF0uaW5kZXhPZihzdWJzZXRbaWldKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goc3Vic2V0W2lpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWJ1ZygncGVyZm9ybWluZyBzaW1wbGUgYXJyYXkgaXRlbSBzZWFyY2gnKTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsLCBzdWJzZXRbaWldKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmV0W3ByZWZpeF0gfHwgIX5yZXRbcHJlZml4XS5pbmRleE9mKHN1YnNldFtpaV0pKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goc3Vic2V0W2lpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXRbcHJlZml4XSA9IHJldFtwcmVmaXhdIHx8IFtdO1xuICAgICAgICAgICAgcmV0W3ByZWZpeF0ucHVzaC5hcHBseShyZXRbcHJlZml4XSwgbWF0Y2hlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgY29udGludWUgdGhlIGtleSBzZWFyY2hcbiAgICAgICAgICBicmVhayB3YWxrX2tleXM7XG5cbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBrZXlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBpZiAobnVsbCAhPSBrZXlzW2kgKyAxXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcGFyZSh2YWwsIHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWNvbXBhcmUodmFsLCB0YXJnZXQpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgZ2l2ZW4gbWF0Y2hlciB3aXRoIHRoZSBkb2N1bWVudCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBtYXRjaGVyXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZShtYXRjaGVyLCB2YWwpe1xuICBpZiAoJ29iamVjdCcgIT0gdHlwZShtYXRjaGVyKSkge1xuICAgIHJldHVybiBlcWwobWF0Y2hlciwgdmFsKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gb2JqZWN0LmtleXMobWF0Y2hlcik7XG4gIGlmICgnJCcgPT0ga2V5c1swXVswXSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBzdWItb2JqZWN0IG1hdGNoaW5nXG4gICAgICBpZiAoJyRlbGVtTWF0Y2gnID09IGtleXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlICE9PSBmaWx0ZXIodmFsLCBtYXRjaGVyLiRlbGVtTWF0Y2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFvcHNba2V5c1tpXV0obWF0Y2hlcltrZXlzW2ldXSwgdmFsKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXFsKG1hdGNoZXIsIHZhbCk7XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBtb2RzID0gcmVxdWlyZSgnLi9tb2RzJyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciBkb3QgPSByZXF1aXJlKCdkb3QtY29tcG9uZW50Jyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWNvbXBvbmVudCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9uZ28tcXVlcnknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBxdWVyeTtcblxuLyoqXG4gKiBFeHBvcnQgZmlsdGVyIGhlbHBlci5cbiAqL1xuXG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcblxuLyoqXG4gKiBFeHBvcnQgbW9kaWZpZXJzLlxuICovXG5cbmV4cG9ydHMubW9kcyA9IG1vZHM7XG5cbi8qKlxuICogRXhlY3V0ZSBhIHF1ZXJ5LlxuICpcbiAqIE9wdGlvbnM6XG4gKiAgLSBgc3RyaWN0YCBvbmx5IG1vZGlmeSBpZiBxdWVyeSBtYXRjaGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBhbHRlclxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5IHRvIGZpbHRlciBtb2RpZmljYXRpb25zIGJ5XG4gKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBxdWVyeShvYmosIHF1ZXJ5LCB1cGRhdGUsIG9wdHMpe1xuICBvYmogPSBvYmogfHwge307XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBxdWVyeSA9IHF1ZXJ5IHx8IHt9O1xuICB1cGRhdGUgPSB1cGRhdGUgfHwge307XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdmFyIHN0cmljdCA9ICEhb3B0cy5zdHJpY3Q7XG5cbiAgdmFyIG1hdGNoO1xuICB2YXIgbG9nID0gW107XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgocXVlcnkpKSB7XG4gICAgbWF0Y2ggPSBmaWx0ZXIob2JqLCBxdWVyeSk7XG4gIH1cblxuICBpZiAoIXN0cmljdCB8fCBmYWxzZSAhPT0gbWF0Y2gpIHtcbiAgICB2YXIga2V5cyA9IG9iamVjdC5rZXlzKHVwZGF0ZSk7XG4gICAgdmFyIHRyYW5zYWN0aW9ucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKG1vZHNba2V5c1tpXV0pIHtcbiAgICAgICAgZGVidWcoJ2ZvdW5kIG1vZGlmaWVyIFwiJXNcIicsIGtleXNbaV0pO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXBkYXRlW2tleXNbaV1dKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGtleS5pbmRleE9mKCcuJC4nKTtcblxuICAgICAgICAgIGlmICh+cG9zKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0ga2V5LnN1YnN0cigwLCBwb3MpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGtleS5zdWJzdHIocG9zICsgMyk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFtwcmVmaXhdKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdleGVjdXRpbmcgXCIlc1wiICVzIG9uIGZpcnN0IG1hdGNoIHdpdGhpbiBcIiVzXCInLCBrZXksIGtleXNbaV0sIHByZWZpeCk7XG4gICAgICAgICAgICAgIHZhciBmbiA9IG1vZHNba2V5c1tpXV0obWF0Y2hbcHJlZml4XVswXSwgc3VmZml4LCB1cGRhdGVba2V5c1tpXV1ba2V5XSk7XG4gICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIC8vIHByb2R1Y2UgYSBrZXkgbmFtZSByZXBsYWNpbmcgJCB3aXRoIHRoZSBhY3R1YWwgaW5kZXhcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHVubmVjZXNzYXJpbHkgZXhwZW5zaXZlXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZG90LmdldChvYmosIHByZWZpeCkuaW5kZXhPZihtYXRjaFtwcmVmaXhdWzBdKTtcbiAgICAgICAgICAgICAgICBmbi5rZXkgPSBwcmVmaXggKyAnLicgKyBpbmRleCArICcuJyArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICBmbi5vcCA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2goZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWJ1ZygnaWdub3JpbmcgXCIlc1wiICVzIC0gbm8gbWF0Y2hlcyB3aXRoaW4gXCIlc1wiJywga2V5LCBrZXlzW2ldLCBwcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBtb2RzW2tleXNbaV1dKG9iaiwga2V5LCB1cGRhdGVba2V5c1tpXV1ba2V5XSk7XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgZm4ua2V5ID0ga2V5O1xuICAgICAgICAgICAgICBmbi5vcCA9IGtleXNbaV07XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdza2lwcGluZyB1bmtub3duIG1vZGlmaWVyIFwiJXNcIicsIGtleXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFuc2FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAvLyBpZiB3ZSBnb3QgaGVyZSBlcnJvciBmcmVlIHdlIHByb2Nlc3MgYWxsIHRyYW5zYWN0aW9uc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZuID0gdHJhbnNhY3Rpb25zW2ldO1xuICAgICAgICB2YXIgdmFsID0gZm4oKTtcbiAgICAgICAgbG9nLnB1c2goeyBvcDogZm4ub3AsIGtleTogZm4ua2V5LCB2YWx1ZTogdmFsIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1Zygnbm8gbWF0Y2hlcyBmb3IgcXVlcnkgJWonLCBxdWVyeSk7XG4gIH1cblxuICByZXR1cm4gbG9nO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVxbCA9IHJlcXVpcmUoJ21vbmdvLWVxbCcpO1xudmFyIGRvdCA9IHJlcXVpcmUoJ2RvdC1jb21wb25lbnQnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWNvbXBvbmVudCcpLmtleXM7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb25nby1xdWVyeScpO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRzZXRgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRzZXQgPSBmdW5jdGlvbiAkc2V0KG9iaiwgcGF0aCwgdmFsKXtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmICghZXFsKG9ialtrZXldLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChudW1lcmljKGtleSkpIHtcbiAgICAgICAgaWYgKCFlcWwob2JqW2tleV0sIHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgYXBwZW5kIHRvIGFycmF5IHVzaW5nIHN0cmluZyBmaWVsZCBuYW1lIFsnICsga2V5ICsgJ10nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignJHNldCBvbmx5IHN1cHBvcnRzIG9iamVjdCBub3QgJyArIHR5cGUob2JqKSk7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYW4gYCR1bnNldGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHVuc2V0ID0gZnVuY3Rpb24gJHVuc2V0KG9iaiwgcGF0aCl7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIHJlbWluZGVyOiBgZGVsZXRlIGFyclsxXWAgPT09IGBkZWxldGUgYXJyWycxJ11gIFshXVxuICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGZhaWwgc2lsZW50bHlcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHVuc2V0IG9mIGluZXhpc3Rpbmcga2V5Jyk7XG4gICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHJlbmFtZWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHJlbmFtZSA9IGZ1bmN0aW9uICRyZW5hbWUob2JqLCBwYXRoLCBuZXdLZXkpe1xuICAvLyB0YXJnZXQgPSBzb3VyY2VcbiAgaWYgKHBhdGggPT0gbmV3S2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCckcmVuYW1lIHNvdXJjZSBtdXN0IGRpZmZlciBmcm9tIHRhcmdldCcpO1xuICB9XG5cbiAgLy8gdGFyZ2V0IGlzIHBhcmVudCBvZiBzb3VyY2VcbiAgaWYgKDAgPT09IHBhdGguaW5kZXhPZihuZXdLZXkgKyAnLicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCckcmVuYW1lIHRhcmdldCBtYXkgbm90IGJlIGEgcGFyZW50IG9mIHNvdXJjZScpO1xuICB9XG5cbiAgdmFyIHAgPSBkb3QucGFyZW50KG9iaiwgcGF0aCk7XG4gIHZhciB0ID0gdHlwZShwKTtcblxuICBpZiAoJ29iamVjdCcgPT0gdCkge1xuICAgIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgICBpZiAocC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHZhbCA9IHBba2V5XTtcbiAgICAgICAgZGVsZXRlIHBba2V5XTtcblxuICAgICAgICAvLyB0YXJnZXQgZG9lcyBpbml0aWFsaXplIHRoZSBwYXRoXG4gICAgICAgIHZhciBuZXdwID0gZG90LnBhcmVudChvYmosIG5ld0tleSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gYW5kIGFsc28gZmFpbHMgc2lsZW50bHkgdXBvbiB0eXBlIG1pc21hdGNoXG4gICAgICAgIGlmICgnb2JqZWN0JyA9PSB0eXBlKG5ld3ApKSB7XG4gICAgICAgICAgbmV3cFtuZXdLZXkuc3BsaXQoJy4nKS5wb3AoKV0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2ludmFsaWQgJHJlbmFtZSB0YXJnZXQgcGF0aCB0eXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBuZXcga2V5XG4gICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcmVuYW1lIGZyb20gaW5leGlzdGluZyBzb3VyY2UnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJ3VuZGVmaW5lZCcgIT0gdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignJHJlbmFtZSBzb3VyY2UgZmllbGQgaW52YWxpZCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGFuIGAkaW5jYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kaW5jID0gZnVuY3Rpb24gJGluYyhvYmosIHBhdGgsIGluYyl7XG4gIGlmICgnbnVtYmVyJyAhPSB0eXBlKGluYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGlmaWVyICRpbmMgYWxsb3dlZCBmb3IgbnVtYmVycyBvbmx5Jyk7XG4gIH1cblxuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ251bWJlcicgIT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkaW5jIG1vZGlmaWVyIHRvIG5vbi1udW1iZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldICs9IGluYztcbiAgICAgICAgICByZXR1cm4gaW5jO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmKCdvYmplY3QnID09IHR5cGUob2JqKSB8fCBudW1lcmljKGtleSkpe1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IGluYztcbiAgICAgICAgICByZXR1cm4gaW5jO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkaW5jIG1vZGlmaWVyIHRvIG5vbi1udW1iZXInKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhbiBgJHBvcGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHBvcCA9IGZ1bmN0aW9uICRwb3Aob2JqLCBwYXRoLCB2YWwpe1xuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgLy8gd2UgbWFrZSBzdXJlIHRoZSBhcnJheSBpcyBub3QganVzdCB0aGUgcGFyZW50IG9mIHRoZSBtYWluIGtleVxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICBpZiAob2JqW2tleV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmICgtMSA9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpba2V5XS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBtb25nb2RiIGFsbG93cyBhbnkgdmFsdWUgdG8gcG9wXG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2tleV0ucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvcCB0byBpbmV4aXN0aW5nIGtleScpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHBvcCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvcCB0byBpbmV4aXN0aW5nIGtleScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvcCB0byBpbmV4aXN0aW5nIGtleScpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHB1c2hgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRvIHB1c2hcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kcHVzaCA9IGZ1bmN0aW9uICRwdXNoKG9iaiwgcGF0aCwgdmFsKXtcbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdXNoLyRwdXNoQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IFt2YWxdO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdXNoLyRwdXNoQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG51bWVyaWMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IFt2YWxdO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgYXBwZW5kIHRvIGFycmF5IHVzaW5nIHN0cmluZyBmaWVsZCBuYW1lIFsnICsga2V5ICsgJ10nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRwdXNoQWxsYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyB0byBwdXNoXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHB1c2hBbGwgPSBmdW5jdGlvbiAkcHVzaEFsbChvYmosIHBhdGgsIHZhbCl7XG4gIGlmICgnYXJyYXknICE9IHR5cGUodmFsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTW9kaWZpZXIgJHB1c2hBbGwvcHVsbEFsbCBhbGxvd2VkIGZvciBhcnJheXMgb25seScpO1xuICB9XG5cbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgb2JqW2tleV0ucHVzaC5hcHBseShvYmpba2V5XSwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVzaC8kcHVzaEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBvYmpba2V5XS5wdXNoLmFwcGx5KG9ialtrZXldLCB2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdXNoLyRwdXNoQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG51bWVyaWMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkcHVsbGAuXG4gKi9cblxuZXhwb3J0cy4kcHVsbCA9IGZ1bmN0aW9uICRwdWxsKG9iaiwgcGF0aCwgdmFsKXtcbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICB2YXIgdCA9IHR5cGUob2JqKTtcblxuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdmFyIHB1bGxlZCA9IFtdO1xuICAgICAgICAgIHZhciBzcGxpY2UgPSBwdWxsKG9ialtrZXldLCBbdmFsXSwgcHVsbGVkKTtcbiAgICAgICAgICBpZiAocHVsbGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHNwbGljZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gcHVsbGVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1bGwvJHB1bGxBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdmFyIHB1bGxlZCA9IFtdO1xuICAgICAgICAgIHZhciBzcGxpY2UgPSBwdWxsKG9ialtrZXldLCBbdmFsXSwgcHVsbGVkKTtcbiAgICAgICAgICBpZiAocHVsbGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHNwbGljZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gcHVsbGVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1bGwvJHB1bGxBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdpZ25vcmluZyBwdWxsIHRvIG5vbiBhcnJheScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMRUZUX1NVQkZJRUxEIG9ubHkgc3VwcG9ydHMgT2JqZWN0OiBoZWxsbyBub3Q6ICcgKyB0KTtcbiAgICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkcHVsbEFsbGAuXG4gKi9cblxuZXhwb3J0cy4kcHVsbEFsbCA9IGZ1bmN0aW9uICRwdWxsQWxsKG9iaiwgcGF0aCwgdmFsKXtcbiAgaWYgKCdhcnJheScgIT0gdHlwZSh2YWwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNb2RpZmllciAkcHVzaEFsbC9wdWxsQWxsIGFsbG93ZWQgZm9yIGFycmF5cyBvbmx5Jyk7XG4gIH1cblxuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gIHZhciB0ID0gdHlwZShvYmopO1xuXG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICB2YXIgcHVsbGVkID0gW107XG4gICAgICAgICAgdmFyIHNwbGljZSA9IHB1bGwob2JqW2tleV0sIHZhbCwgcHVsbGVkKTtcbiAgICAgICAgICBpZiAocHVsbGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHNwbGljZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gcHVsbGVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1bGwvJHB1bGxBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdmFyIHB1bGxlZCA9IFtdO1xuICAgICAgICAgIHZhciBzcGxpY2UgPSBwdWxsKG9ialtrZXldLCB2YWwsIHB1bGxlZCk7XG4gICAgICAgICAgaWYgKHB1bGxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBzcGxpY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1bGxlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdWxsLyRwdWxsQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnaWdub3JpbmcgcHVsbCB0byBub24gYXJyYXknKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTEVGVF9TVUJGSUVMRCBvbmx5IHN1cHBvcnRzIE9iamVjdDogaGVsbG8gbm90OiAnICsgdCk7XG4gICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJGFkZFRvU2V0YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBwdXNoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGludGVybmFsLCB0cnVlIGlmIHJlY3Vyc2luZ1xuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRhZGRUb1NldCA9IGZ1bmN0aW9uICRhZGRUb1NldChvYmosIHBhdGgsIHZhbCwgcmVjdXJzaW5nKXtcbiAgaWYgKCFyZWN1cnNpbmcgJiYgJ2FycmF5JyA9PSB0eXBlKHZhbC4kZWFjaCkpIHtcbiAgICB2YXIgZm5zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWwuJGVhY2gubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgZm4gPSAkYWRkVG9TZXQob2JqLCBwYXRoLCB2YWwuJGVhY2hbaV0sIHRydWUpO1xuICAgICAgaWYgKGZuKSBmbnMucHVzaChmbik7XG4gICAgfVxuICAgIGlmIChmbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykgdmFsdWVzLnB1c2goZm5zW2ldKCkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICBpZiAoIWhhcyhvYmpba2V5XSwgdmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRhZGRUb1NldCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICBpZiAoIWhhcyhvYmpba2V5XSwgdmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRhZGRUb1NldCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChudW1lcmljKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGRldGVybWluaW5nIGlmIGFuIGFycmF5IGhhcyB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXMoYXJyYXksIHZhbCl7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGVxbCh2YWwsIGFycmF5W2ldKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEFycmF5I2ZpbHRlciBmdW5jdGlvbiBnZW5lcmF0b3IgZm9yIGAkcHVsbGAvYCRwdWxsQWxsYCBvcGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHZhbHVlcyB0byBtYXRjaFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgdG8gcG9wdWxhdGUgd2l0aCByZXN1bHRzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhhdCBzcGxpY2VzIHRoZSBhcnJheVxuICovXG5cbmZ1bmN0aW9uIHB1bGwoYXJyLCB2YWxzLCBwdWxsZWQpe1xuICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gIGZvciAodmFyIGEgPSAwOyBhIDwgYXJyLmxlbmd0aDsgYSsrKSB7XG4gICAgdmFyIHZhbCA9IGFyclthXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hdGNoZXIgPSB2YWxzW2ldO1xuICAgICAgaWYgKCdvYmplY3QnID09IHR5cGUobWF0Y2hlcikpIHtcbiAgICAgICAgLy8gd2Ugb25seSBhcmUgb25seSBpbnRlcmVzdGVkIGluIG9iaiA8LT4gb2JqIGNvbXBhcmlzb25zXG4gICAgICAgIGlmICgnb2JqZWN0JyA9PSB0eXBlKHZhbCkpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChrZXlzKG1hdGNoZXIpLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtYXRjaGVyKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaGVyLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBhdCBsZWFzdCBvbmUgbWF0Y2hpbmcga2V5IHRvIHB1bGxcbiAgICAgICAgICAgICAgICBpZiAoZXFsKG1hdGNoZXJbaV0sIHZhbFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgYSBzaW5nbGUga2V5IGRvZXNuJ3QgbWF0Y2ggd2UgbW92ZSBvblxuICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWtleXModmFsKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHB1bGwgYHt9YCBtYXRjaGVzIFt7fV1cbiAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaChhKTtcbiAgICAgICAgICAgIHB1bGxlZC5wdXNoKHZhbCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHB1bGwgbWF0Y2ggYWdhaW5zdCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVxbChtYXRjaGVyLCB2YWwpKSB7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGEpO1xuICAgICAgICAgIHB1bGxlZC5wdXNoKHZhbCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbaV07XG4gICAgICBhcnIuc3BsaWNlKGluZGV4IC0gaSwgMSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBkZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBudW1lcmljLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgbnVtZXJpY1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbnVtZXJpYyh2YWwpe1xuICByZXR1cm4gJ251bWJlcicgPT0gdHlwZSh2YWwpIHx8IE51bWJlcih2YWwpID09IHZhbDtcbn1cbiIsIi8qKlxuICogdG9TdHJpbmcgcmVmLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0eXBlIG9mIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCl7XG4gIHN3aXRjaCAodG9TdHJpbmcuY2FsbCh2YWwpKSB7XG4gICAgY2FzZSAnW29iamVjdCBEYXRlXSc6IHJldHVybiAnZGF0ZSc7XG4gICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzogcmV0dXJuICdyZWdleHAnO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJndW1lbnRzXSc6IHJldHVybiAnYXJndW1lbnRzJztcbiAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHJldHVybiAnYXJyYXknO1xuICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzogcmV0dXJuICdlcnJvcic7XG4gIH1cblxuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKHZhbCAhPT0gdmFsKSByZXR1cm4gJ25hbic7XG4gIGlmICh2YWwgJiYgdmFsLm5vZGVUeXBlID09PSAxKSByZXR1cm4gJ2VsZW1lbnQnO1xuXG4gIHZhbCA9IHZhbC52YWx1ZU9mXG4gICAgPyB2YWwudmFsdWVPZigpXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YuYXBwbHkodmFsKVxuXG4gIHJldHVybiB0eXBlb2YgdmFsO1xufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cbi8qKlxuICogVXNlIGNocm9tZS5zdG9yYWdlLmxvY2FsIGlmIHdlIGFyZSBpbiBhbiBhcHBcbiAqL1xuXG52YXIgc3RvcmFnZTtcblxuaWYgKHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjaHJvbWUuc3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpXG4gIHN0b3JhZ2UgPSBjaHJvbWUuc3RvcmFnZS5sb2NhbDtcbmVsc2VcbiAgc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1jb21wb25lbnQnKTtcblxuLyoqXG4gKiBHZXRzIGEgY2VydGFpbiBgcGF0aGAgZnJvbSB0aGUgYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7T2JqZWN0fSBmb3VuZCBvYmplY3QsIG9yIGB1bmRlZmluZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihvYmosIHBhdGgpe1xuICBpZiAofnBhdGguaW5kZXhPZignLicpKSB7XG4gICAgdmFyIHBhciA9IHBhcmVudChvYmosIHBhdGgpO1xuICAgIHZhciBtYWluS2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICAgIHZhciB0ID0gdHlwZShwYXIpO1xuICAgIGlmICgnb2JqZWN0JyA9PSB0IHx8ICdhcnJheScgPT0gdCkgcmV0dXJuIHBhclttYWluS2V5XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqW3BhdGhdO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGdpdmVuIGBwYXRoYCB0byBgdmFsYCBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAUGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbihvYmosIHBhdGgsIHZhbCl7XG4gIGlmICh+cGF0aC5pbmRleE9mKCcuJykpIHtcbiAgICB2YXIgcGFyID0gcGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gICAgdmFyIG1haW5LZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gICAgaWYgKHBhciAmJiAnb2JqZWN0JyA9PSB0eXBlKHBhcikpIHBhclttYWluS2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBvYmpbcGF0aF0gPSB2YWw7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IG9iamVjdCBmb3IgYSBnaXZlbiBrZXkgKGRvdCBub3RhdGlvbiBhd2FyZSkuXG4gKlxuICogLSBJZiBhIHBhcmVudCBvYmplY3QgZG9lc24ndCBleGlzdCwgaXQncyBpbml0aWFsaXplZC5cbiAqIC0gQXJyYXkgaW5kZXggbG9va3VwIGlzIHN1cHBvcnRlZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUgaWYgaXQgc2hvdWxkIGluaXRpYWxpemUgdGhlIHBhdGhcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJlbnQgPSBwYXJlbnQ7XG5cbmZ1bmN0aW9uIHBhcmVudChvYmosIGtleSwgaW5pdCl7XG4gIGlmICh+a2V5LmluZGV4T2YoJy4nKSkge1xuICAgIHZhciBwaWVjZXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICB2YXIgcmV0ID0gb2JqO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAvLyBpZiB0aGUga2V5IGlzIGEgbnVtYmVyIHN0cmluZyBhbmQgcGFyZW50IGlzIGFuIGFycmF5XG4gICAgICBpZiAoTnVtYmVyKHBpZWNlc1tpXSkgPT0gcGllY2VzW2ldICYmICdhcnJheScgPT0gdHlwZShyZXQpKSB7XG4gICAgICAgIHJldCA9IHJldFtwaWVjZXNbaV1dO1xuICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlKHJldCkpIHtcbiAgICAgICAgaWYgKGluaXQgJiYgIXJldC5oYXNPd25Qcm9wZXJ0eShwaWVjZXNbaV0pKSB7XG4gICAgICAgICAgcmV0W3BpZWNlc1tpXV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0KSByZXQgPSByZXRbcGllY2VzW2ldXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiB0b1N0cmluZyByZWYuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKXtcbiAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZ1bmN0aW9uXSc6IHJldHVybiAnZnVuY3Rpb24nO1xuICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnO1xuICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6IHJldHVybiAncmVnZXhwJztcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOiByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5JztcbiAgfVxuXG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBPYmplY3QodmFsKSkgcmV0dXJuICdvYmplY3QnO1xuXG4gIHJldHVybiB0eXBlb2YgdmFsO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVxbDtcblxuLyoqXG4gKiBNb25nb0RCIHN0eWxlIHZhbHVlIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhleSBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIGVxbChtYXRjaGVyLCB2YWwpe1xuICBzd2l0Y2ggKHR5cGUobWF0Y2hlcikpIHtcbiAgICBjYXNlICdudWxsJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgLy8gd2UgdHJlYXQgbnVsbCBhcyB1bmRlZmluZWRcbiAgICAgIHJldHVybiBudWxsID09IHZhbDtcblxuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICByZXR1cm4gbWF0Y2hlci50ZXN0KHZhbCk7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKHZhbCkgJiYgbWF0Y2hlci5sZW5ndGggPT0gdmFsLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWVxbCh2YWxbaV0sIG1hdGNoZXJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBvYmplY3QgY2FuIG1hdGNoIGtleXMgaW4gYW55IG9yZGVyXG4gICAgICB2YXIga2V5cyA9IHt9O1xuXG4gICAgICAvLyB3ZSBtYXRjaCBhbGwgdmFsdWVzIG9mIGBtYXRjaGVyYCBpbiBgdmFsYFxuICAgICAgZm9yICh2YXIgaSBpbiBtYXRjaGVyKSB7XG4gICAgICAgIGlmIChtYXRjaGVyLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgaWYgKCF2YWwuaGFzT3duUHJvcGVydHkoaSkgfHwgIWVxbChtYXRjaGVyW2ldLCB2YWxbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXNbaV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBtYWtlIHN1cmUgYHZhbGAgZG9lc24ndCBoYXZlIGV4dHJhIGtleXNcbiAgICAgIGZvciAodmFyIGkgaW4gdmFsKSB7XG4gICAgICAgIGlmICh2YWwuaGFzT3duUHJvcGVydHkoaSkgJiYgIWtleXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG1hdGNoZXIgPT09IHZhbDtcbiAgfVxufVxuIiwiXG4vKipcbiAqIEhPUCByZWYuXG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUmV0dXJuIG93biBrZXlzIGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmope1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gb3duIHZhbHVlcyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbihvYmope1xuICB2YXIgdmFscyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFscy5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG4vKipcbiAqIE1lcmdlIGBiYCBpbnRvIGBhYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24oYSwgYil7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhcy5jYWxsKGIsIGtleSkpIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIFJldHVybiBsZW5ndGggb2YgYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmxlbmd0aCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBleHBvcnRzLmtleXMob2JqKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiAwID09IGV4cG9ydHMubGVuZ3RoKG9iaik7XG59OyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlcWwgPSByZXF1aXJlKCdtb25nby1lcWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcblxuLyoqXG4gKiAkbmU6IG5vdCBlcXVhbC5cbiAqL1xuXG5leHBvcnRzLiRuZSA9IGZ1bmN0aW9uICRuZShtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gIWVxbChtYXRjaGVyLCB2YWwpO1xufTtcblxuLyoqXG4gKiAkZ3Q6IGdyZWF0ZXIgdGhhbi5cbiAqL1xuXG5leHBvcnRzLiRndCA9IGZ1bmN0aW9uICRndChtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gdHlwZShtYXRjaGVyKSA9PT0gJ251bWJlcicgJiYgdmFsID4gbWF0Y2hlcjtcbn07XG5cbi8qKlxuICogJGd0ZTogZ3JlYXRlciB0aGFuIGVxdWFsLlxuICovXG5cbmV4cG9ydHMuJGd0ZSA9IGZ1bmN0aW9uICRndGUobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuIHR5cGUobWF0Y2hlcikgPT09ICdudW1iZXInICYmIHZhbCA+PSBtYXRjaGVyO1xufTtcblxuLyoqXG4gKiAkbHQ6IGxlc3MgdGhhbi5cbiAqL1xuXG5leHBvcnRzLiRsdCA9IGZ1bmN0aW9uICRsdChtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gdHlwZShtYXRjaGVyKSA9PT0gJ251bWJlcicgJiYgdmFsIDwgbWF0Y2hlcjtcbn07XG5cbi8qKlxuICogJGx0ZTogbGVzcyB0aGFuIGVxdWFsLlxuICovXG5cbmV4cG9ydHMuJGx0ZSA9IGZ1bmN0aW9uICRsdGUobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuIHR5cGUobWF0Y2hlcikgPT09ICdudW1iZXInICYmIHZhbCA8PSBtYXRjaGVyO1xufTtcblxuLyoqXG4gKiAkcmVnZXg6IHN1cHBseSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyBhIHN0cmluZy5cbiAqL1xuXG5leHBvcnRzLiRyZWdleCA9IGZ1bmN0aW9uICRyZWdleChtYXRjaGVyLCB2YWwpe1xuICAvLyBUT0RPOiBhZGQgJG9wdGlvbnMgc3VwcG9ydFxuICBpZiAoJ3JlZ2V4cCcgIT0gdHlwZSgnbWF0Y2hlcicpKSBtYXRjaGVyID0gbmV3IFJlZ0V4cChtYXRjaGVyKTtcbiAgcmV0dXJuIG1hdGNoZXIudGVzdCh2YWwpO1xufTtcblxuLyoqXG4gKiAkZXhpc3RzOiBrZXkgZXhpc3RzLlxuICovXG5cbmV4cG9ydHMuJGV4aXN0cyA9IGZ1bmN0aW9uICRleGlzdHMobWF0Y2hlciwgdmFsKXtcbiAgaWYgKG1hdGNoZXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkICE9PSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCA9PT0gdmFsO1xuICB9XG59O1xuXG4vKipcbiAqICRpbjogdmFsdWUgaW4gYXJyYXkuXG4gKi9cblxuZXhwb3J0cy4kaW4gPSBmdW5jdGlvbiAkaW4obWF0Y2hlciwgdmFsKXtcbiAgaWYgKCdhcnJheScgIT0gdHlwZShtYXRjaGVyKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZXFsKG1hdGNoZXJbaV0sIHZhbCkpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogJG5pbjogdmFsdWUgbm90IGluIGFycmF5LlxuICovXG5cbmV4cG9ydHMuJG5pbiA9IGZ1bmN0aW9uICRuaW4obWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuICFleHBvcnRzLiRpbihtYXRjaGVyLCB2YWwpO1xufTtcblxuLyoqXG4gKiBAc2l6ZTogYXJyYXkgbGVuZ3RoXG4gKi9cblxuZXhwb3J0cy4kc2l6ZSA9IGZ1bmN0aW9uKG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgJiYgbWF0Y2hlciA9PSB2YWwubGVuZ3RoO1xufTtcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vbGliL2NvcmUnKS5DcnlwdG9KUztcbnJlcXVpcmUoJy4vbGliL2VuYy1iYXNlNjQnKTtcbnJlcXVpcmUoJy4vbGliL21kNScpO1xucmVxdWlyZSgnLi9saWIvZXZwa2RmJyk7XG5yZXF1aXJlKCcuL2xpYi9jaXBoZXItY29yZScpO1xucmVxdWlyZSgnLi9saWIvYWVzJyk7XG52YXIgSnNvbkZvcm1hdHRlciA9IHJlcXVpcmUoJy4vbGliL2pzb25mb3JtYXR0ZXInKS5Kc29uRm9ybWF0dGVyO1xuXG5leHBvcnRzLkNyeXB0b0pTID0gQ3J5cHRvSlM7XG5leHBvcnRzLkpzb25Gb3JtYXR0ZXIgPSBKc29uRm9ybWF0dGVyOyIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vY29yZScpLkNyeXB0b0pTO1xyXG5cclxuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU2hvcnRjdXRzXHJcbiAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG4gICAgdmFyIENfbGliID0gQy5saWI7XHJcbiAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcclxuICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XHJcblxyXG4gICAgLy8gTG9va3VwIHRhYmxlc1xyXG4gICAgdmFyIFNCT1ggPSBbXTtcclxuICAgIHZhciBJTlZfU0JPWCA9IFtdO1xyXG4gICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xyXG4gICAgdmFyIFNVQl9NSVhfMSA9IFtdO1xyXG4gICAgdmFyIFNVQl9NSVhfMiA9IFtdO1xyXG4gICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xyXG4gICAgdmFyIElOVl9TVUJfTUlYXzAgPSBbXTtcclxuICAgIHZhciBJTlZfU1VCX01JWF8xID0gW107XHJcbiAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xyXG4gICAgdmFyIElOVl9TVUJfTUlYXzMgPSBbXTtcclxuXHJcbiAgICAvLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcclxuICAgICAgICB2YXIgZCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPCAxMjgpIHtcclxuICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2FsayBHRigyXjgpXHJcbiAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgIHZhciB4aSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHNib3hcclxuICAgICAgICAgICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XHJcbiAgICAgICAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2MztcclxuICAgICAgICAgICAgU0JPWFt4XSA9IHN4O1xyXG4gICAgICAgICAgICBJTlZfU0JPWFtzeF0gPSB4O1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgICAgICB2YXIgeDIgPSBkW3hdO1xyXG4gICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcclxuICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXHJcbiAgICAgICAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcclxuICAgICAgICAgICAgU1VCX01JWF8wW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xyXG4gICAgICAgICAgICBTVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xyXG4gICAgICAgICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xyXG4gICAgICAgICAgICBTVUJfTUlYXzNbeF0gPSB0O1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXHJcbiAgICAgICAgICAgIHZhciB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xyXG4gICAgICAgICAgICBJTlZfU1VCX01JWF8wW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcclxuICAgICAgICAgICAgSU5WX1NVQl9NSVhfMVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xyXG4gICAgICAgICAgICBJTlZfU1VCX01JWF8yW3N4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XHJcbiAgICAgICAgICAgIElOVl9TVUJfTUlYXzNbc3hdID0gdDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXHJcbiAgICAgICAgICAgIGlmICgheCkge1xyXG4gICAgICAgICAgICAgICAgeCA9IHhpID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XHJcbiAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0oKSk7XHJcblxyXG4gICAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcclxuICAgIHZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQUVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXHJcbiAgICAgKi9cclxuICAgIHZhciBBRVMgPSBDX2FsZ28uQUVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcclxuICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleTtcclxuICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xyXG4gICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcclxuICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDZcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIGtleSBzY2hlZHVsZSByb3dzXHJcbiAgICAgICAgICAgIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXHJcbiAgICAgICAgICAgIHZhciBrZXlTY2hlZHVsZSA9IHRoaXMuX2tleVNjaGVkdWxlID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlXb3Jkc1trc1Jvd107XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCBSY29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgXj0gUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcclxuICAgICAgICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGludktzUm93ICUgNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtTQk9YW3QgPj4+IDI0XV0gXiBJTlZfU1VCX01JWF8xW1NCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xyXG4gICAgICAgICAgICAvLyBTd2FwIDJuZCBhbmQgNHRoIHJvd3NcclxuICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcclxuICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xyXG5cclxuICAgICAgICAgICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xyXG4gICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcztcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxyXG4gICAgICAgICAgICB2YXIgczAgPSBNW29mZnNldF0gICAgIF4ga2V5U2NoZWR1bGVbMF07XHJcbiAgICAgICAgICAgIHZhciBzMSA9IE1bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcclxuICAgICAgICAgICAgdmFyIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xyXG4gICAgICAgICAgICB2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XHJcblxyXG4gICAgICAgICAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcclxuICAgICAgICAgICAgdmFyIGtzUm93ID0gNDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kc1xyXG4gICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBtaXggY29sdW1ucywgYWRkIHJvdW5kIGtleVxyXG4gICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQyID0gU1VCX01JWF8wW3MyID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgczAgPSB0MDtcclxuICAgICAgICAgICAgICAgIHMxID0gdDE7XHJcbiAgICAgICAgICAgICAgICBzMiA9IHQyO1xyXG4gICAgICAgICAgICAgICAgczMgPSB0MztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XHJcbiAgICAgICAgICAgIHZhciB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICB2YXIgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuICAgICAgICAgICAgdmFyIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcbiAgICAgICAgICAgIHZhciB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxyXG4gICAgICAgICAgICBNW29mZnNldF0gICAgID0gdDA7XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0MTtcclxuICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAga2V5U2l6ZTogMjU2LzMyXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcclxuICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcclxuICAgICAqL1xyXG4gICAgQy5BRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyk7XHJcbn0oKSk7XHJcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vY29yZScpLkNyeXB0b0pTO1xyXG5cclxuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4vKipcclxuICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cclxuICovXHJcbkNyeXB0b0pTLmxpYi5DaXBoZXIgfHwgKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcclxuICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcclxuICAgIHZhciBDX2xpYiA9IEMubGliO1xyXG4gICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xyXG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcclxuICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTtcclxuICAgIHZhciBDX2VuYyA9IEMuZW5jO1xyXG4gICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xyXG4gICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NDtcclxuICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XHJcbiAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENpcGhlciA9IENfbGliLkNpcGhlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4Zm9ybU1vZGUgRWl0aGVyIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gdHJhbnNvcm1hdGlvbiBtb2RlIGNvbnN0YW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlKENyeXB0b0pTLmFsZ28uQUVTLl9FTkNfWEZPUk1fTU9ERSwga2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcclxuICAgICAgICAgICAgdGhpcy5feGZvcm1Nb2RlID0geGZvcm1Nb2RlO1xyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGlzIGNpcGhlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcclxuICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcclxuICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XHJcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGVuZFxyXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3NcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxyXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XHJcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcclxuICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxyXG4gICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xyXG4gICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWREYXRhID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBrZXlTaXplOiAxMjgvMzIsXHJcblxyXG4gICAgICAgIGl2U2l6ZTogMTI4LzMyLFxyXG5cclxuICAgICAgICBfRU5DX1hGT1JNX01PREU6IDEsXHJcblxyXG4gICAgICAgIF9ERUNfWEZPUk1fTU9ERTogMixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2lwaGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXksIGNmZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSgpKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcclxuICAgICAqL1xyXG4gICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xyXG4gICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3NcclxuICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJsb2NrU2l6ZTogMVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RlIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cclxuICAgICAqL1xyXG4gICAgdmFyIEJsb2NrQ2lwaGVyTW9kZSA9IENfbGliLkJsb2NrQ2lwaGVyTW9kZSA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xyXG4gICAgICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX2l2ID0gaXY7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENCQyA9IENfbW9kZS5DQkMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFic3RyYWN0IGJhc2UgQ0JDIG1vZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIENCQyA9IEJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ0JDIGVuY3J5cHRvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcclxuICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcclxuICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ0JDIGRlY3J5cHRvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDQkMuRGVjcnlwdG9yID0gQ0JDLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcclxuICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVjcnlwdCBhbmQgWE9SXHJcbiAgICAgICAgICAgICAgICBjaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XHJcblxyXG4gICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXHJcbiAgICAgICAgICAgIGlmIChpdikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaXY7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLl9wcmV2QmxvY2s7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFhPUiBibG9ja3NcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBDQkM7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFkZGluZyBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX3BhZCA9IEMucGFkID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cclxuICAgICAqL1xyXG4gICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXHJcbiAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZCA9IChuUGFkZGluZ0J5dGVzIDw8IDI0KSB8IChuUGFkZGluZ0J5dGVzIDw8IDE2KSB8IChuUGFkZGluZ0J5dGVzIDw8IDgpIHwgblBhZGRpbmdCeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nXHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXHJcbiAgICAgICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnVucGFkKHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxyXG4gICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcclxuICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcclxuICAgICAqL1xyXG4gICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcclxuICAgICAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNmZzogQ2lwaGVyLmNmZy5leHRlbmQoe1xyXG4gICAgICAgICAgICBtb2RlOiBDQkMsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IFBrY3M3XHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGNpcGhlclxyXG4gICAgICAgICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XHJcbiAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcclxuICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGJsb2NrIG1vZGVcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XHJcbiAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmFsaXplXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhZCBkYXRhXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3NcclxuICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcclxuICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcclxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXHJcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxyXG4gICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2NrcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBibG9ja1NpemU6IDEyOC8zMlxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxyXG4gICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cclxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxyXG4gICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcyA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XHJcbiAgICAgICAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxyXG4gICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXHJcbiAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXHJcbiAgICAgICAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxyXG4gICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcclxuICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxyXG4gICAgICAgICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxyXG4gICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxyXG4gICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIGNpcGhlciBwYXJhbXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdGhyb3dzIEVycm9yIElmIG5laXRoZXIgdGhlIGZvcm1hdHRlciBub3IgdGhlIGRlZmF1bHQgZm9ybWF0dGVyIGlzIHNldC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcyArICcnO1xyXG4gICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZm9ybWF0dGVyIHx8IHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXQgbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdCA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxyXG4gICAgICovXHJcbiAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcclxuICAgICAgICAgICAgdmFyIHNhbHQgPSBjaXBoZXJQYXJhbXMuc2FsdDtcclxuXHJcbiAgICAgICAgICAgIC8vIEZvcm1hdFxyXG4gICAgICAgICAgICBpZiAoc2FsdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wucGFyc2Uob3BlblNTTFN0cmluZyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XHJcbiAgICAgICAgICAgIC8vIFBhcnNlIGJhc2U2NFxyXG4gICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzO1xyXG5cclxuICAgICAgICAgICAgLy8gVGVzdCBmb3Igc2FsdFxyXG4gICAgICAgICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2FsdFxyXG4gICAgICAgICAgICAgICAgdmFyIHNhbHQgPSBXb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgyLCA0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XHJcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xyXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LCBzYWx0OiBzYWx0IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNpcGhlciB3cmFwcGVyIHRoYXQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB2YXIgU2VyaWFsaXphYmxlQ2lwaGVyID0gQ19saWIuU2VyaWFsaXphYmxlQ2lwaGVyID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCBjaXBoZXIgcGFyYW0gb2JqZWN0cyB0byBhbmQgZnJvbSBhIHN0cmluZy4gRGVmYXVsdDogT3BlblNTTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xyXG4gICAgICAgICAgICBmb3JtYXQ6IE9wZW5TU0xGb3JtYXR0ZXJcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5jcnlwdFxyXG4gICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XHJcbiAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xyXG4gICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XHJcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxyXG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXHJcbiAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xyXG4gICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xyXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyeXB0XHJcbiAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdG8gQ2lwaGVyUGFyYW1zLFxyXG4gICAgICAgICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSB1bnNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3BhcnNlOiBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5wYXJzZShjaXBoZXJ0ZXh0LCB0aGlzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX2tkZiA9IEMua2RmID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVuU1NMIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XHJcbiAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcclxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcclxuICAgICAgICAgICAgaWYgKCFzYWx0KSB7XHJcbiAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcclxuICAgICAgICAgICAgdmFyIGtleSA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxyXG4gICAgICAgICAgICB2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XHJcbiAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHBhcmFtc1xyXG4gICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGtleToga2V5LCBpdjogaXYsIHNhbHQ6IHNhbHQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcclxuICAgICAqIGFuZCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHZhciBQYXNzd29yZEJhc2VkQ2lwaGVyID0gQ19saWIuUGFzc3dvcmRCYXNlZENpcGhlciA9IFNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7S0RGfSBrZGYgVGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0byBnZW5lcmF0ZSBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLiBEZWZhdWx0OiBPcGVuU1NMXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2ZnOiBTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGtkZjogT3BlblNTTEtkZlxyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcclxuICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcclxuICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuY3J5cHRcclxuICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XHJcblxyXG4gICAgICAgICAgICAvLyBNaXggaW4gZGVyaXZlZCBwYXJhbXNcclxuICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXHJcbiAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xyXG4gICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIGNpcGhlcnRleHQuc2FsdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXHJcbiAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyeXB0XHJcbiAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KCkpO1xyXG4iLCIvKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbi8qKlxyXG4gKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXHJcbiAqL1xyXG52YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICogICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICAgICAgLy8gU3Bhd25cclxuICAgICAgICAgICAgICAgIEYucHJvdG90eXBlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gbmV3IEYoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBdWdtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXHJcbiAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXHJcbiAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cclxuICAgICAgICAgICAgICogICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xyXG4gICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXHJcbiAgICAgICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XHJcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xyXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XHJcbiAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XHJcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcclxuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XHJcbiAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XHJcbiAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xyXG4gICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcclxuICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29uY2F0XHJcbiAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXRXb3Jkcy5sZW5ndGggPiAweGZmZmYpIHtcclxuICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IGFsbCB3b3JkcyBhdCBvbmNlXHJcbiAgICAgICAgICAgICAgICB0aGlzV29yZHMucHVzaC5hcHBseSh0aGlzV29yZHMsIHRoYXRXb3Jkcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGFpbmFibGVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xyXG4gICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xhbXBcclxuICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcclxuICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCkgfCAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxyXG4gICAgICovXHJcbiAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XHJcbiAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnRcclxuICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydFxyXG4gICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cclxuICAgICAqL1xyXG4gICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xyXG4gICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0XHJcbiAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0XHJcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxyXG4gICAgICovXHJcbiAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXHJcbiAgICAgKi9cclxuICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcclxuICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XHJcbiAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kXHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcclxuICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcbiAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xyXG4gICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcclxuICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xyXG5cclxuICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XHJcbiAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcclxuICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3NcclxuICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXHJcbiAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XHJcbiAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XHJcbiAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXHJcbiAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcclxuICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9taW5CdWZmZXJTaXplOiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXHJcbiAgICAgKi9cclxuICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxyXG4gICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xyXG4gICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XHJcbiAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGVuZFxyXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cclxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XHJcbiAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XHJcbiAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcclxuXHJcbiAgICByZXR1cm4gQztcclxufShNYXRoKSk7XHJcblxyXG5leHBvcnRzLkNyeXB0b0pTID0gQ3J5cHRvSlM7XHJcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vY29yZScpLkNyeXB0b0pTO1xuXG4vKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG4gICAgLyoqXG4gICAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxuICAgICAqL1xuICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICAgICAgICovXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG4gICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnRcbiAgICAgICAgICAgIHZhciBiYXNlNjRDaGFycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSAod29yZHNbKGkgKyAxKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDEpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgICAgICAgICAgIHZhciBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcbiAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NFN0cmluZyk7XG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgICAgIC8vIElnbm9yZSBwYWRkaW5nXG4gICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcbiAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nSW5kZXggPSBiYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7XG4gICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0XG4gICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBuQnl0ZXMgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpICUgNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYml0czEgPSBtYXAuaW5kZXhPZihiYXNlNjRTdHIuY2hhckF0KGkgLSAxKSkgPDwgKChpICUgNCkgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdHMyID0gbWFwLmluZGV4T2YoYmFzZTY0U3RyLmNoYXJBdChpKSkgPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IChiaXRzMSB8IGJpdHMyKSA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcbiAgICAgICAgICAgICAgICAgICAgbkJ5dGVzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG4gICAgfTtcbn0oKSk7XG4iLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2NvcmUnKS5DcnlwdG9KUztcclxuXHJcbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcclxuICAgIHZhciBDX2xpYiA9IEMubGliO1xyXG4gICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xyXG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcclxuICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XHJcbiAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxyXG4gICAgICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcclxuICAgICAqL1xyXG4gICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREYgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcclxuICAgICAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQ6IE1ENVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGtleVNpemU6IDEyOC8zMixcclxuICAgICAgICAgICAgaGFzaGVyOiBNRDUsXHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDFcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xyXG4gICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcclxuICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xyXG4gICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0IGhhc2hlclxyXG4gICAgICAgICAgICB2YXIgaGFzaGVyID0gY2ZnLmhhc2hlci5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xyXG4gICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xyXG4gICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGNmZy5pdGVyYXRpb25zO1xyXG5cclxuICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5XHJcbiAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShibG9jayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBoYXNoZXIudXBkYXRlKHBhc3N3b3JkKS5maW5hbGl6ZShzYWx0KTtcclxuICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCk7XHJcbiAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xyXG4gICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcclxuICAgICAqL1xyXG4gICAgQy5FdnBLREYgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xyXG4gICAgICAgIHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XHJcbiAgICB9O1xyXG59KCkpO1xyXG4iLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2NvcmUnKS5DcnlwdG9KUztcblxuLy8gY3JlYXRlIGN1c3RvbSBqc29uIHNlcmlhbGl6YXRpb24gZm9ybWF0XG52YXIgSnNvbkZvcm1hdHRlciA9IHtcblx0c3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdFx0Ly8gY3JlYXRlIGpzb24gb2JqZWN0IHdpdGggY2lwaGVydGV4dFxuXHRcdHZhciBqc29uT2JqID0ge1xuXHRcdFx0Y3Q6IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5CYXNlNjQpXG5cdFx0fTtcblx0XHRcblx0XHQvLyBvcHRpb25hbGx5IGFkZCBpdiBhbmQgc2FsdFxuXHRcdGlmIChjaXBoZXJQYXJhbXMuaXYpIHtcblx0XHRcdGpzb25PYmouaXYgPSBjaXBoZXJQYXJhbXMuaXYudG9TdHJpbmcoKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNpcGhlclBhcmFtcy5zYWx0KSB7XG5cdFx0XHRqc29uT2JqLnMgPSBjaXBoZXJQYXJhbXMuc2FsdC50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdC8vIHN0cmluZ2lmeSBqc29uIG9iamVjdFxuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShqc29uT2JqKVxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoanNvblN0cikge1xuXHRcdC8vIHBhcnNlIGpzb24gc3RyaW5nXG5cdFx0dmFyIGpzb25PYmogPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuXHRcdFxuXHRcdC8vIGV4dHJhY3QgY2lwaGVydGV4dCBmcm9tIGpzb24gb2JqZWN0LCBhbmQgY3JlYXRlIGNpcGhlciBwYXJhbXMgb2JqZWN0XG5cdFx0dmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0XHRcdGNpcGhlcnRleHQ6IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoanNvbk9iai5jdClcblx0XHR9KTtcblx0XHRcblx0XHQvLyBvcHRpb25hbGx5IGV4dHJhY3QgaXYgYW5kIHNhbHRcblx0XHRpZiAoanNvbk9iai5pdikge1xuXHRcdFx0Y2lwaGVyUGFyYW1zLml2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShqc29uT2JqLml2KTtcblx0XHR9XG4gICAgICAgICAgICBcblx0XHRpZiAoanNvbk9iai5zKSB7XG5cdFx0XHRjaXBoZXJQYXJhbXMuc2FsdCA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoanNvbk9iai5zKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGNpcGhlclBhcmFtcztcblx0fVxufTtcblxuZXhwb3J0cy5Kc29uRm9ybWF0dGVyID0gSnNvbkZvcm1hdHRlcjsiLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2NvcmUnKS5DcnlwdG9KUztcclxuXHJcbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuKGZ1bmN0aW9uIChNYXRoKSB7XHJcbiAgICAvLyBTaG9ydGN1dHNcclxuICAgIHZhciBDID0gQ3J5cHRvSlM7XHJcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XHJcbiAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xyXG4gICAgdmFyIENfYWxnbyA9IEMuYWxnbztcclxuXHJcbiAgICAvLyBDb25zdGFudHMgdGFibGVcclxuICAgIHZhciBUID0gW107XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XHJcbiAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ENSBoYXNoIGFsZ29yaXRobS5cclxuICAgICAqL1xyXG4gICAgdmFyIE1ENSA9IENfYWxnby5NRDUgPSBIYXNoZXIuZXh0ZW5kKHtcclxuICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcclxuICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXHJcbiAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2XHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xyXG4gICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcclxuICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XHJcblxyXG4gICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXHJcbiAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XHJcblxyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMCAgPSBNW29mZnNldCArIDBdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMSAgPSBNW29mZnNldCArIDFdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMiAgPSBNW29mZnNldCArIDJdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMyAgPSBNW29mZnNldCArIDNdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfNCAgPSBNW29mZnNldCArIDRdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfNSAgPSBNW29mZnNldCArIDVdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfNiAgPSBNW29mZnNldCArIDZdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfNyAgPSBNW29mZnNldCArIDddO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfOCAgPSBNW29mZnNldCArIDhdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfOSAgPSBNW29mZnNldCArIDldO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzExID0gTVtvZmZzZXQgKyAxMV07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8xMiA9IE1bb2Zmc2V0ICsgMTJdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE0ID0gTVtvZmZzZXQgKyAxNF07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8xNSA9IE1bb2Zmc2V0ICsgMTVdO1xyXG5cclxuICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcclxuICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xyXG4gICAgICAgICAgICB2YXIgYiA9IEhbMV07XHJcbiAgICAgICAgICAgIHZhciBjID0gSFsyXTtcclxuICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cclxuICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA3LCAgVFswXSk7XHJcbiAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xLCAgMTIsIFRbMV0pO1xyXG4gICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE3LCBUWzJdKTtcclxuICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzMsICAyMiwgVFszXSk7XHJcbiAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNywgIFRbNF0pO1xyXG4gICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfNSwgIDEyLCBUWzVdKTtcclxuICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNywgVFs2XSk7XHJcbiAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAgMjIsIFRbN10pO1xyXG4gICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDcsICBUWzhdKTtcclxuICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzksICAxMiwgVFs5XSk7XHJcbiAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcclxuICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzExLCAyMiwgVFsxMV0pO1xyXG4gICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDcsICBUWzEyXSk7XHJcbiAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xMywgMTIsIFRbMTNdKTtcclxuICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNywgVFsxNF0pO1xyXG4gICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XHJcblxyXG4gICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDUsICBUWzE2XSk7XHJcbiAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCAgOSwgIFRbMTddKTtcclxuICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xyXG4gICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgIDIwLCBUWzE5XSk7XHJcbiAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNSwgIFRbMjBdKTtcclxuICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCAgVFsyMV0pO1xyXG4gICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE0LCBUWzIyXSk7XHJcbiAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAgMjAsIFRbMjNdKTtcclxuICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA1LCAgVFsyNF0pO1xyXG4gICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTQsIDksICBUWzI1XSk7XHJcbiAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTQsIFRbMjZdKTtcclxuICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsICAyMCwgVFsyN10pO1xyXG4gICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDUsICBUWzI4XSk7XHJcbiAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCAgOSwgIFRbMjldKTtcclxuICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNCwgVFszMF0pO1xyXG4gICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XHJcblxyXG4gICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XHJcbiAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcclxuICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xyXG4gICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XHJcbiAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcclxuICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xyXG4gICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XHJcbiAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcclxuICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xyXG4gICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XHJcbiAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcclxuICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xyXG4gICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XHJcbiAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcclxuICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xyXG4gICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XHJcblxyXG4gICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDYsICBUWzQ4XSk7XHJcbiAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAgMTAsIFRbNDldKTtcclxuICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNSwgVFs1MF0pO1xyXG4gICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfNSwgIDIxLCBUWzUxXSk7XHJcbiAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNiwgIFRbNTJdKTtcclxuICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsICAxMCwgVFs1M10pO1xyXG4gICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE1LCBUWzU0XSk7XHJcbiAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAgMjEsIFRbNTVdKTtcclxuICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA2LCAgVFs1Nl0pO1xyXG4gICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTUsIDEwLCBUWzU3XSk7XHJcbiAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTUsIFRbNThdKTtcclxuICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEzLCAyMSwgVFs1OV0pO1xyXG4gICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDYsICBUWzYwXSk7XHJcbiAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcclxuICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNSwgVFs2Ml0pO1xyXG4gICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgIDIxLCBUWzYzXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxyXG4gICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XHJcbiAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcclxuICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xyXG4gICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XHJcblxyXG4gICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xyXG4gICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xyXG4gICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcclxuICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcclxuICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXHJcbiAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XHJcbiAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcclxuICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xyXG4gICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XHJcblxyXG4gICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgICAgIHZhciBIX2kgPSBIW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxyXG4gICAgICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XHJcbiAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBHRyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICAgICAgdmFyIG4gPSBhICsgKChiICYgZCkgfCAoYyAmIH5kKSkgKyB4ICsgdDtcclxuICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgICAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xyXG4gICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XHJcbiAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KCdtZXNzYWdlJyk7XHJcbiAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUod29yZEFycmF5KTtcclxuICAgICAqL1xyXG4gICAgQy5NRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxyXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XHJcbiAgICAgKi9cclxuICAgIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xyXG59KE1hdGgpKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgQ29uc3RhbnRzID0ge307XHJcbkNvbnN0YW50cy5EZWZhdWx0VGFrZUl0ZW1zQ291bnQgPSA1MDtcclxuQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lID0gJ0V4cGFuZCc7XHJcbkNvbnN0YW50cy5SZXR1cm5Bc0ZpZWxkTmFtZSA9ICdSZXR1cm5Bcyc7XHJcbkNvbnN0YW50cy5GaWVsZHNFeHByZXNzaW9uTmFtZSA9ICdGaWVsZHMnO1xyXG5Db25zdGFudHMuU2luZ2xlRmllbGRFeHByZXNzaW9uTmFtZSA9ICdTaW5nbGVGaWVsZCc7XHJcbkNvbnN0YW50cy5Tb3J0RXhwcmVzc2lvbk5hbWUgPSAnU29ydCc7XHJcbkNvbnN0YW50cy5GaWx0ZXJFeHByZXNzaW9uTmFtZSA9ICdGaWx0ZXInO1xyXG5Db25zdGFudHMuU2tpcEV4cHJlc3Npb25OYW1lID0gJ1NraXAnO1xyXG5Db25zdGFudHMuVGFrZUV4cHJlc3Npb25OYW1lID0gJ1Rha2UnO1xyXG5Db25zdGFudHMuUGFyZW50UmVsYXRpb25GaWVsZE5hbWUgPSAnUGFyZW50UmVsYXRpb25GaWVsZCc7XHJcbkNvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudCA9ICdJZCc7XHJcbkNvbnN0YW50cy5UYXJnZXRUeXBlTmFtZUZpZWxkTmFtZSA9ICdUYXJnZXRUeXBlTmFtZSc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0YW50czsiLCIndXNlIHN0cmljdCc7XHJcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpO1xyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCBpcyB1c2VkIHRvIGdldCBhbGwgcmVxdWlyZWQgaW5mb3JtYXRpb24gaW4gb3JkZXIgdG8gcHJvY2VzcyBhIHNldCBvZiByZWxhdGlvbnMuXHJcbiAqIEBwYXJhbSBwYXJlbnQgLSBBbiBFeGVjdXRpb25Ob2RlIGluc3RhbmNlIHVzZWQgdG8gc3VwcGx5IHRoZSB0cmVlIGxpa2UgZGF0YSBzdHJ1Y3R1cmUuXHJcbiAqIEBwYXJhbSByZWxhdGlvbk5vZGUgLSBUaGUgcmVsYXRpb24gbm9kZSB1c2VkIHRvIGNyZWF0ZWQgdGhlIEV4ZWN1dGlvbk5vZGUgaW5zdGFuY2UgKEV4ZWN1dGlvbk5vZGUgaW5zdGFuY2Ugc2hvdWxkIGNvbnRhaW4gb25lIG9yIG1hbnkgcmVsYXRpb25zXHJcbiAqIGlmIHRoZXkgY2FuIGJlIGNvbWJpbmVkIGZvciBiYXRjaCBleGVjdXRpb24pLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBFeGVjdXRpb25Ob2RlID0gZnVuY3Rpb24gKHBhcmVudCwgcmVsYXRpb25Ob2RlKSB7XHJcbiAgICB2YXIgcGFyZW50UGF0aCA9ICcnO1xyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudFBhdGggPSBwYXJlbnQucGF0aDtcclxuICAgIH1cclxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50UGF0aDtcclxuICAgIHRoaXMucmVsYXRpb25zID0gW3JlbGF0aW9uTm9kZS5wYXRoXTtcclxuICAgIHRoaXMubmFtZSA9IHJlbGF0aW9uTm9kZS5wYXRoO1xyXG4gICAgdGhpcy50YXJnZXRUeXBlTmFtZSA9IHJlbGF0aW9uTm9kZS50YXJnZXRUeXBlTmFtZTtcclxuICAgIHRoaXMuY2FuQWRkT3RoZXJSZWxhdGlvbnMgPSAhcmVsYXRpb25Ob2RlLmZpbHRlckV4cHJlc3Npb24gJiYgIXJlbGF0aW9uTm9kZS5zb3J0RXhwcmVzc2lvbiAmJiAhcmVsYXRpb25Ob2RlLnRha2UgJiYgIXJlbGF0aW9uTm9kZS5za2lwO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgdmFyIHBhdGggPSAnJztcclxuICAgIGlmIChwYXJlbnRQYXRoKSB7XHJcbiAgICAgICAgcGF0aCArPSBwYXJlbnRQYXRoICsgJy4nO1xyXG4gICAgfVxyXG4gICAgcGF0aCArPSByZWxhdGlvbk5vZGUudGFyZ2V0VHlwZU5hbWU7XHJcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc2VydHMgYSBSZWxhdGlvbk5vZGUgdG8gYW4gRXhlY3V0aW9uTm9kZS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gQSBSZWxhdGlvbiBpbnN0YW5jZS5cclxuICovXHJcbkV4ZWN1dGlvbk5vZGUucHJvdG90eXBlLmluc2VydFJlbGF0aW9uTm9kZSA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgdGhpcy5yZWxhdGlvbnMucHVzaChyZWxhdGlvbi5wYXRoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnNlcnRzIGEgY2hpbGQgbm9kZSAod2hpY2ggcmVsYXRpb25zKSBkZXBlbmRzIGZyb20gcGFyZW50IG5vZGUgcmVzdWx0LlxyXG4gKiBAcGFyYW0gY2hpbGQgLSBFeGVjdXRpb25Ob2RlIGluc3RhbmNlIHJlcHJlc2VudGluZyBjaGlsZCBub2RlLlxyXG4gKi9cclxuRXhlY3V0aW9uTm9kZS5wcm90b3R5cGUuaW5zZXJ0Q2hpbGRyZW5Ob2RlID0gZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQubmFtZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSGVscGVyIG1ldGhvZCB0aGF0IGNoZWNrcyBpZiBzb21lIHJlbGF0aW9ucyBjb3VsZCBiZSBjb21iaW5lZCAoZm9yIGV4YW1wbGUgaGF2ZSBzYW1lIFRhcmdldFR5cGUpLlxyXG4gKiBAcGFyYW0gcmVsYXRpb25cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5FeGVjdXRpb25Ob2RlLnByb3RvdHlwZS5jYW5Db21iaW5lV2l0aFJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICBpZiAoIXRoaXMuY2FuQWRkT3RoZXJSZWxhdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0VHlwZU5hbWUgPT09IHJlbGF0aW9uLnRhcmdldFR5cGVOYW1lICYmICFyZWxhdGlvbi5maWx0ZXJFeHByZXNzaW9uICYmICFyZWxhdGlvbi5zb3J0RXhwcmVzc2lvbiAmJiAhcmVsYXRpb24udGFrZSAmJiAhcmVsYXRpb24uc2tpcDtcclxufTtcclxuXHJcbi8qKiBFeGVjdXRpb25UcmVlXHJcbiAqIENsYXNzIHRoYXQgYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBhbiBleGVjdXRpb24gdHJlZSBmcm9tIGEgcmVsYXRpb25UcmVlLiBVc2VkIHRvIHByb2Nlc3MgYWxsIHF1ZXJpZXMgKG1hc3RlciBhbmQgY2hpbGQpIGluIGEgY29ycmVjdCBvcmRlci5cclxuICogQHBhcmFtIHJlbGF0aW9uVHJlZSAtIEFuIGluc3RhbmNlIG9mIHJlbGF0aW9uIHRyZWUuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEV4ZWN1dGlvblRyZWUgPSBmdW5jdGlvbiAocmVsYXRpb25UcmVlKSB7XHJcbiAgICB0aGlzLl9yZWxhdGlvblRyZWUgPSByZWxhdGlvblRyZWU7XHJcbiAgICB0aGlzLl9tYXAgPSB7fTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGV4ZWN1dGlvbiBub2RlIHRvIHRoZSBFeGVjdXRpb25UcmVlLlxyXG4gKiBAcGFyYW0gZXhlY3V0aW9uTm9kZVxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuYWRkRXhlY3V0aW9uTm9kZSA9IGZ1bmN0aW9uIChleGVjdXRpb25Ob2RlKSB7XHJcbiAgICB0aGlzLl9tYXBbZXhlY3V0aW9uTm9kZS5uYW1lXSA9IGV4ZWN1dGlvbk5vZGU7XHJcbn07XHJcblxyXG4vKipcclxuICogRmluZHMgdGhlIEV4ZWN1dGlvbk5vZGUgd2hpY2ggY29udGFpbnMgdGhlIHJlcXVlc3RlZCByZWxhdGlvbi5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gQSBSZWxhdGlvbiBpbnN0YW5jZS5cclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5nZXRFeGVjdXRpb25Ob2RlT2ZSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgZm9yICh2YXIgZXhlY05vZGUgaW4gdGhpcy5fbWFwKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hcC5oYXNPd25Qcm9wZXJ0eShleGVjTm9kZSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21hcFtleGVjTm9kZV0ucmVsYXRpb25zLmluZGV4T2YocmVsYXRpb24pID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXBbZXhlY05vZGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogRmluZHMgYSBSZWxhdGlvbk5vZGUgd2l0aGluIHRoZSBSZWxhdGlvblRyZWUuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIHJlbGF0aW9uIHdpdGhpbiB0aGUgUmVsYXRpb25UcmVlIChmb3IgZXhhbXBsZTogQWN0aXZpdGllcy5MaWtlcy5Sb2xlKS5cclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5nZXRSZWxhdGlvbk5vZGUgPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIGlmIChyZWxhdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWxhdGlvblRyZWVbcmVsYXRpb25dIHx8IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0Um9vdFJlbGF0aW9uTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZWxhdGlvblRyZWVbdGhpcy5fcmVsYXRpb25UcmVlLiRyb290XSB8fCBudWxsO1xyXG59O1xyXG4vKipcclxuICogQnVpbGRzIHRoZSBFeGVjdXRpb25UcmVlIGZyb20gYSBSZWxhdGlvblRyZWUuXHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vYnVpbGQgYmVnaW5uaW5nIGZyb20gdGhlIHJvb3RcclxuICAgIHZhciByZWxhdGlvblJvb3QgPSB0aGlzLmdldFJlbGF0aW9uTm9kZSh0aGlzLl9yZWxhdGlvblRyZWUuJHJvb3QpO1xyXG4gICAgLy9TZXR1cCB0aGUgcm9vdCBvZiB0aGUgZXhlY3V0aW9uIHRyZWUuXHJcbiAgICB2YXIgcm9vdEV4ZWN1dGlvbk5vZGUgPSBuZXcgRXhlY3V0aW9uTm9kZShudWxsLCByZWxhdGlvblJvb3QpOy8vbm8gcGFyZW50IG5vZGVcclxuICAgIHRoaXMuYWRkRXhlY3V0aW9uTm9kZShyb290RXhlY3V0aW9uTm9kZSk7XHJcbiAgICB0aGlzLmJ1aWxkSW50ZXJuYWwocmVsYXRpb25Sb290KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmF2ZXJzZSB0aGUgcmVsYXRpb24gdHJlZSBhbmQgYnVpbGQgdGhlIGV4ZWN1dGlvbiB0cmVlLlxyXG4gKiBAcGFyYW0gcmVsYXRpb25Sb290IC0gVGhlIHJvb3Qgbm9kZSBvZiB0aGUgUmVsYXRpb25UcmVlLlxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuYnVpbGRJbnRlcm5hbCA9IGZ1bmN0aW9uIChyZWxhdGlvblJvb3QpIHtcclxuICAgIHJlbGF0aW9uUm9vdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIHZhciBjaGlsZFJlbGF0aW9uTm9kZSA9IHRoaXMuZ2V0UmVsYXRpb25Ob2RlKGNoaWxkKTtcclxuICAgICAgICB0aGlzLmluc2VydFJlbGF0aW9uTm9kZUluRXhlY3V0aW9uVHJlZShjaGlsZFJlbGF0aW9uTm9kZSk7XHJcbiAgICAgICAgdGhpcy5idWlsZEludGVybmFsKGNoaWxkUmVsYXRpb25Ob2RlKTtcclxuICAgIH0sIHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc2VydHMgYSByZWxhdGlvbiBub2RlIHdpdGhpbiB0aGUgZXhlY3V0aW9uIHRyZWUgKGJhc2VkIG9uIGl0cyBkZXBlbmRlbmNpZXMpLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgcmVsYXRpb24gdGhhdCB3aWxsIGJlIGluc2VydGVkLlxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuaW5zZXJ0UmVsYXRpb25Ob2RlSW5FeGVjdXRpb25UcmVlID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICB2YXIgcm9vdEV4ZWN1dGlvbk5vZGUgPSB0aGlzLmdldEV4ZWN1dGlvbk5vZGVPZlJlbGF0aW9uKHJlbGF0aW9uLnBhcmVudCk7XHJcbiAgICB2YXIgY2hpbGRUb0NvbWJpbmUgPSB0aGlzLnRyeUdldENoaWxkTm9kZVRvQ29tYmluZShyb290RXhlY3V0aW9uTm9kZSwgcmVsYXRpb24pO1xyXG4gICAgaWYgKGNoaWxkVG9Db21iaW5lKSB7Ly9pZiB0aGVyZSBpcyBhIGNoaWxkIHRoYXQgd2UgY29tYmluZSB0aGUgcmVsYXRpb25cclxuICAgICAgICBjaGlsZFRvQ29tYmluZS5pbnNlcnRSZWxhdGlvbk5vZGUocmVsYXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgbmV3RXhlY3V0aW9uTm9kZSA9IG5ldyBFeGVjdXRpb25Ob2RlKHJvb3RFeGVjdXRpb25Ob2RlLCByZWxhdGlvbik7Ly9jcmVhdGUgYSBzZXBhcmF0ZSBleGVjdXRpb24gbm9kZSB0aGF0IHdpbGwgaG9zdCB0aGUgcmVsYXRpb25cclxuICAgICAgICByb290RXhlY3V0aW9uTm9kZS5pbnNlcnRDaGlsZHJlbk5vZGUobmV3RXhlY3V0aW9uTm9kZSk7XHJcbiAgICAgICAgdGhpcy5hZGRFeGVjdXRpb25Ob2RlKG5ld0V4ZWN1dGlvbk5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyaWVzIHRvIGZpbmQgYW4gRXhlY3V0aW9uTm9kZSB3aGljaCBjb3VsZCBiZSBjb21iaW5lZCB3aXRoIGEgcmVsYXRpb24uXHJcbiAqIEBwYXJhbSByb290RXhlY3V0aW9uTm9kZSAtIFRoZSByb290IG5vZGUgb2YgdGhlIEV4ZWN1dGlvblRyZWUuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIFJlbGF0aW9uIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgRXhlY3V0aW9uVHJlZS5cclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS50cnlHZXRDaGlsZE5vZGVUb0NvbWJpbmUgPSBmdW5jdGlvbiAocm9vdEV4ZWN1dGlvbk5vZGUsIHJlbGF0aW9uKSB7XHJcbiAgICBpZiAocm9vdEV4ZWN1dGlvbk5vZGUuY2FuQ29tYmluZVdpdGhSZWxhdGlvbihyZWxhdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gcm9vdEV4ZWN1dGlvbk5vZGU7XHJcbiAgICB9XHJcbiAgICB2YXIgY2hpbGRyZW4gPSByb290RXhlY3V0aW9uTm9kZS5jaGlsZHJlbjtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9tYXBbY2hpbGRyZW5baV1dO1xyXG4gICAgICAgIHZhciBjaGlsZFRvQ29tYmluZSA9IHRoaXMudHJ5R2V0Q2hpbGROb2RlVG9Db21iaW5lKGNoaWxkLCByZWxhdGlvbik7XHJcbiAgICAgICAgaWYgKGNoaWxkVG9Db21iaW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFRvQ29tYmluZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbiBmcm9tIGFsbCByZWxhdGlvbnMgaW5zaWRlIGFuIEV4ZWN1dGlvbk5vZGUuXHJcbiAqIEBwYXJhbSBleGVjdXRpb25Ob2RlIC0gVGhlIEV4ZWN1dGlvbk5vZGUgaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIHt7fX1cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldEZpbHRlckZyb21FeGVjdXRpb25Ob2RlID0gZnVuY3Rpb24gKGV4ZWN1dGlvbk5vZGUsIGluY2x1ZGVBcnJheXMpIHtcclxuICAgIHZhciBmaWx0ZXIgPSB7fTtcclxuICAgIHZhciBzdWJSZWxhdGlvbnNGaWx0ZXIgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhlY3V0aW9uTm9kZS5yZWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgaW5uZXJGaWx0ZXIgPSB0aGlzLmdldEZpbHRlckZyb21TaW5nbGVSZWxhdGlvbih0aGlzLl9yZWxhdGlvblRyZWVbZXhlY3V0aW9uTm9kZS5yZWxhdGlvbnNbaV1dLCBpbmNsdWRlQXJyYXlzKTtcclxuICAgICAgICBpZiAoaW5uZXJGaWx0ZXIpIHtcclxuICAgICAgICAgICAgc3ViUmVsYXRpb25zRmlsdGVyLnB1c2goaW5uZXJGaWx0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3ViUmVsYXRpb25zRmlsdGVyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBmaWx0ZXIuJG9yID0gc3ViUmVsYXRpb25zRmlsdGVyO1xyXG4gICAgfSBlbHNlIGlmIChzdWJSZWxhdGlvbnNGaWx0ZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZpbHRlciA9IHN1YlJlbGF0aW9uc0ZpbHRlclswXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmlsdGVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBmaWx0ZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyBmaWx0ZXIgZXhwcmVzc2lvbiBmcm9tIGEgc2luZ2xlIHJlbGF0aW9uLiBUcmF2ZXJzZSB0aGUgcmVsYXRpb24gdHJlZSBpbiBvcmRlciB0byBnZXQgdGhlIFwiSWRcInMgZnJvbSB0aGUgcmVzdWx0IG9mIHBhcmVudCByZWxhdGlvblxyXG4gKiBhbG9uZyB3aXRoIHVzZXIgZGVmaW5lZCBmaWx0ZXJzLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIFJlbGF0aW9uIGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldEZpbHRlckZyb21TaW5nbGVSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbiwgaW5jbHVkZUFycmF5cykge1xyXG4gICAgdmFyIHVzZXJEZWZpbmVkRmlsdGVyID0gcmVsYXRpb24uZmlsdGVyRXhwcmVzc2lvbjtcclxuICAgIHZhciBwYXJlbnRSZWxhdGlvbkZpbHRlciA9IHt9O1xyXG4gICAgdmFyIHBhcmVudFJlbGF0aW9uSWRzID0gdGhpcy5nZXRSZWxhdGlvbkZpZWxkVmFsdWVzKHJlbGF0aW9uLCBpbmNsdWRlQXJyYXlzKTtcclxuICAgIHZhciBwYXJlbnRSZWxhdGlvbkZpZWxkTmFtZSA9IChyZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24gPyByZWxhdGlvbi5yZWxhdGlvbkZpZWxkIDogQ29uc3RhbnRzLklkRmllbGROYW1lQ2xpZW50KTtcclxuXHJcbiAgICBpZiAocGFyZW50UmVsYXRpb25JZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHBhcmVudFJlbGF0aW9uRmlsdGVyW3BhcmVudFJlbGF0aW9uRmllbGROYW1lXSA9IHsnJGluJzogcGFyZW50UmVsYXRpb25JZHN9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodXNlckRlZmluZWRGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gW107XHJcbiAgICAgICAgZmlsdGVycy5wdXNoKHBhcmVudFJlbGF0aW9uRmlsdGVyKTtcclxuICAgICAgICBmaWx0ZXJzLnB1c2godXNlckRlZmluZWRGaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiB7JyRhbmQnOiBmaWx0ZXJzfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFJlbGF0aW9uRmlsdGVyO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCByZWxhdGlvbiBmaWVsZCB2YWx1ZXMgb2YgcGFyZW50IHJlbGF0aW9uIGluIG9yZGVyIHRvIGNvbnN0cnVjdCBhIHByb3BlciBmaWx0ZXIgKHRvIGNyZWF0ZSBhIHJlbGF0aW9uKS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gQSByZWxhdGlvbiBpbnN0YW5jZSB3aGljaCB3aWxsIGdldCB0aGUgZmlsdGVyLlxyXG4gKiBAcGFyYW0gaW5jbHVkZUFycmF5cyAtIFdoZXRoZXIgdG8gaW5jbHVkZSBhcnJheSB2YWx1cyBvZiB0aGUgcGFyZW50IGl0ZW1zIHdoZW4gY2FsY3VsYXRpbmcgdGhlIGl0ZW1zIHRoYXQgd2lsbCBiZSBleHBhbmRlZCBvbiB0aGUgY3VycmVudCBsZXZlbC5cclxuICogQHJldHVybnMge0FycmF5fSAtIEFuIGFycmF5IG9mIHJlbGF0aW9uIGZpZWxkIHZhbHVlcy5cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldFJlbGF0aW9uRmllbGRWYWx1ZXMgPSBmdW5jdGlvbiAocmVsYXRpb24sIGluY2x1ZGVBcnJheXMpIHtcclxuICAgIHZhciBwYXJlbnRSZWxhdGlvbklkcyA9IFtdO1xyXG4gICAgdmFyIHBhcmVudFJlbGF0aW9uID0gdGhpcy5fcmVsYXRpb25UcmVlW3JlbGF0aW9uLnBhcmVudF07XHJcbiAgICAvLyBwYXJlbnRSZWxhdGlvblJlc3VsdCBhY3R1YWxseSBpcyBhbiBBY3Rpdml0eSBvciBBcnJheSBvZiBBY3Rpdml0aWVzXHJcbiAgICB2YXIgcGFyZW50UmVsYXRpb25SZXN1bHQgPSBBcnJheS5pc0FycmF5KHBhcmVudFJlbGF0aW9uLnJlc3VsdCkgPyBwYXJlbnRSZWxhdGlvbi5yZXN1bHQgOiBbcGFyZW50UmVsYXRpb24ucmVzdWx0XTtcclxuICAgIGlmIChyZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcclxuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhcmVudFJlbGF0aW9uUmVzdWx0Lmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgICAgIHBhcmVudFJlbGF0aW9uSWRzLnB1c2gocGFyZW50UmVsYXRpb25SZXN1bHRbcF1bcmVsYXRpb24ucGFyZW50UmVsYXRpb25GaWVsZF0pO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gYWxsIGNvbW1lbnRzIGFyZSByZWxhdGVkIHRvIGV4cGFuZCBvZiB0eXBlIGNvbnRlbnQgdHlwZSBBY3Rpdml0aWVzIGV4cGFuZDoge1wiTGlrZXNcIjogdHJ1ZX1cclxuICAgICAgICBpZiAocGFyZW50UmVsYXRpb24gJiYgcGFyZW50UmVsYXRpb24ucmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzID0gcmVsYXRpb24ucGFyZW50UmVsYXRpb25JZHMgfHwge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50UmVsYXRpb25SZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIGl0ZW1Gcm9tUGFyZW50UmVsYXRpb24gaXMgc2luZ2xlIEFjdGl2aXR5XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUZyb21QYXJlbnRSZWxhdGlvbiA9IHBhcmVudFJlbGF0aW9uUmVzdWx0W2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSBpcyBBY3Rpdml0eS5MaWtlc1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSA9IGl0ZW1Gcm9tUGFyZW50UmVsYXRpb25bcmVsYXRpb24ucmVsYXRpb25GaWVsZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb24uaGFzQXJyYXlWYWx1ZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlQXJyYXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtVG9FeHBhbmRJZCBpcyBjdXJyZW50IHZhbHVlIGluIEFjdGl2aXR5Lkxpa2VzIGFycmF5IG9yIGp1c3QgYSBzaW5nbGUgXCJJZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVRvRXhwYW5kSWQgPSBwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWVbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtVG9FeHBhbmRJZCAhPT0gdW5kZWZpbmVkICYmIGl0ZW1Ub0V4cGFuZElkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVsYXRpb25JZHMucHVzaChpdGVtVG9FeHBhbmRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2V0IGFueSB2YWx1ZSBqdXN0IHRvIGNyZWF0ZSBhIG1hcCBvZiBJZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkc1tpdGVtVG9FeHBhbmRJZF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVsYXRpb25JZHMucHVzaChwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkc1twYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWVdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcmVudFJlbGF0aW9uSWRzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25UcmVlO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIEV4cGFuZEVycm9yKG1lc3NhZ2UpIHtcclxuICAgIHRoaXMubmFtZSA9ICdFeHBhbmRFcnJvcic7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XHJcbn1cclxuRXhwYW5kRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV4cGFuZEVycm9yOyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcclxudmFyIFJlbGF0aW9uVHJlZUJ1aWxkZXIgPSByZXF1aXJlKCcuL1JlbGF0aW9uVHJlZUJ1aWxkZXInKTtcclxudmFyIEV4ZWN1dGlvblRyZWUgPSByZXF1aXJlKCcuL0V4ZWN1dGlvblRyZWUnKTtcclxudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XHJcbnZhciBFeHBhbmRFcnJvciA9IHJlcXVpcmUoJy4vRXhwYW5kRXJyb3InKTtcclxuXHJcbmZ1bmN0aW9uIFByb2Nlc3NvcihvcHRpb25zKSB7XHJcbiAgICB0aGlzLl9leGVjdXRpb25Ob2RlRnVuY3Rpb24gPSBvcHRpb25zLmV4ZWN1dGlvbk5vZGVGdW5jdGlvbjtcclxuICAgIHRoaXMuX21ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbiA9IG9wdGlvbnMubWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uO1xyXG59XHJcblxyXG5Qcm9jZXNzb3IucHJvdG90eXBlLl9nZXRFeGVjdXRpb25UcmVlUm9vdCA9IGZ1bmN0aW9uIChleGVjdXRpb25UcmVlKSB7XHJcbiAgICB2YXIgZXhlY3V0aW9uVHJlZVJvb3QgPSBudWxsO1xyXG4gICAgZm9yICh2YXIgZXhOb2RlIGluIGV4ZWN1dGlvblRyZWUpIHtcclxuICAgICAgICBpZiAoZXhlY3V0aW9uVHJlZS5oYXNPd25Qcm9wZXJ0eShleE5vZGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChleGVjdXRpb25UcmVlW2V4Tm9kZV0ucGFyZW50ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uVHJlZVJvb3QgPSBleGVjdXRpb25UcmVlW2V4Tm9kZV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBleGVjdXRpb25UcmVlUm9vdDtcclxufTtcclxuXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuX2NyZWF0ZUV4ZWN1dGVOb2RlRXhlY3V0b3IgPSBmdW5jdGlvbiAocmVsYXRpb25zVHJlZSwgZXhlY3V0aW9uVHJlZSwgZXhlY3V0aW9uTm9kZSwgZXhwYW5kQ29udGV4dCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIHJlbGF0aW9uc1RyZWVNYXAgPSByZWxhdGlvbnNUcmVlLm1hcDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xyXG4gICAgICAgIHZhciByZWxhdGlvbk5vZGUgPSBleGVjdXRpb25UcmVlLmdldFJlbGF0aW9uTm9kZShleGVjdXRpb25Ob2RlLnJlbGF0aW9uc1swXSk7Ly9nZXQgdGhlIHJlbGF0aW9uIG5vZGUgZm9yIHRoZSBvbmx5IHJlbGF0aW9uIG9mIHRoZSBleGVjdXRpb24gbm9kZS5cclxuICAgICAgICB2YXIgcGFyZW50UmVsYXRpb25Ob2RlID0gZXhlY3V0aW9uVHJlZS5nZXRSZWxhdGlvbk5vZGUocmVsYXRpb25Ob2RlLnBhcmVudCk7XHJcbiAgICAgICAgdmFyIGluY2x1ZGVBcnJheXMgPSAhKHBhcmVudFJlbGF0aW9uTm9kZS5wYXJlbnQgJiYgcGFyZW50UmVsYXRpb25Ob2RlLmhhc0FycmF5VmFsdWVzKTsgLy9vbmx5IGV4cGFuZCBhcnJheSBmaWVsZHMgaWYgdGhlIHBhcmVudCByZWxhdGlvbiBpcyBub3QgYW4gYXJyYXkuIFRoaXMgbWVhbnMgdGhhdCBpZiB3ZSBoYXZlIGV4cGFuZGVkIGEgTGlrZXMgKG11bHRpcGxlIHRvIFVzZXJzKSwgd2Ugd29uJ3QgZXhwYW5kIGFueSBhcnJheSByZWxhdGlvbnMgdGhhdCBhcmUgbmVzdGVkIGluIGl0IHN1Y2ggYXMgdGhlIFVzZXJDb21tZW50cyAobXVsdGlwbGUgcmVsYXRpb24gdG8gQ29tbWVudHMpLlxyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBleGVjdXRpb25UcmVlLmdldEZpbHRlckZyb21FeGVjdXRpb25Ob2RlKGV4ZWN1dGlvbk5vZGUsIGluY2x1ZGVBcnJheXMpO1xyXG5cclxuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gcmVsYXRpb25zVHJlZS52YWxpZGF0ZVNpbmdsZVJlbGF0aW9uKHJlbGF0aW9uTm9kZSk7XHJcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9uZShuZXcgRXhwYW5kRXJyb3IoZXJyb3JNZXNzYWdlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiB3ZSBoYXZlIHN1Y2ggb3B0aW9ucyBleGVjdXRpb25Ob2RlIHNob3VsZCBoYXZlIG9ubHkgb25lIHJlbGF0aW9uLlxyXG4gICAgICAgIHZhciBub2RlID0ge307XHJcbiAgICAgICAgbm9kZS5zZWxlY3QgPSByZWxhdGlvbk5vZGUuZmllbGRzRXhwcmVzc2lvbjtcclxuICAgICAgICBub2RlLnNvcnQgPSByZWxhdGlvbk5vZGUuc29ydEV4cHJlc3Npb247XHJcbiAgICAgICAgbm9kZS5za2lwID0gcmVsYXRpb25Ob2RlLnNraXA7XHJcbiAgICAgICAgbm9kZS50YWtlID0gcmVsYXRpb25Ob2RlLnRha2U7XHJcbiAgICAgICAgbm9kZS5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAgICAgbm9kZS50YXJnZXRUeXBlTmFtZSA9IHJlbGF0aW9uTm9kZS50YXJnZXRUeXBlTmFtZTtcclxuXHJcbiAgICAgICAgc2VsZi5fZXhlY3V0aW9uTm9kZUZ1bmN0aW9uLmNhbGwobnVsbCwgbm9kZSwgZXhwYW5kQ29udGV4dCwgZnVuY3Rpb24gb25Qcm9jZXNzRXhlY3V0aW9uTm9kZShlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4ZWN1dGlvbk5vZGUucmVsYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRSZWxhdGlvbiA9IHJlbGF0aW9uc1RyZWVNYXBbZXhlY3V0aW9uTm9kZS5yZWxhdGlvbnNbaV1dO1xyXG4gICAgICAgICAgICAgICAgY2hpbGRSZWxhdGlvbi5yZXN1bHQgPSBzZWxmLl9leHRyYWN0UmVzdWx0Rm9yUmVsYXRpb24ocmVsYXRpb25zVHJlZU1hcFtleGVjdXRpb25Ob2RlLnJlbGF0aW9uc1tpXV0sIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhlY3V0aW9uTm9kZS5yZXN1bHQgPSBjaGlsZFJlbGF0aW9uLnJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGV4ZWN1dGlvbk5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBleGVjdXRpb25UcmVlTWFwID0gZXhlY3V0aW9uVHJlZS5fbWFwO1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goc2VsZi5fY3JlYXRlRXhlY3V0ZU5vZGVFeGVjdXRvcihyZWxhdGlvbnNUcmVlLCBleGVjdXRpb25UcmVlLCBleGVjdXRpb25UcmVlTWFwW2V4ZWN1dGlvbk5vZGUuY2hpbGRyZW5bal1dLCBleHBhbmRDb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXN5bmMucGFyYWxsZWwoYXJyLCBkb25lKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn07XHJcblxyXG5Qcm9jZXNzb3IucHJvdG90eXBlLl9nZXRTaW5nbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVsYXRpb25zVHJlZSwgcmVsYXRpb24sIHNpbmdsZU9iamVjdCkge1xyXG4gICAgaWYgKCFzaW5nbGVPYmplY3QpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2hpbGRSZWxhdGlvbjtcclxuICAgIHZhciBjaGlsZEl0ZW07XHJcblxyXG4gICAgLy8gaWYgcmVsYXRpb24gaGFzIHNpbmdsZUZpZWxkTmFtZSBvcHRpb24gd2UganVzdCByZXBsYWNlIHRoZSBwYXJlbnQgaWQgd2l0aCBhIHNpbmdsZSB2YWx1ZVxyXG4gICAgaWYgKHJlbGF0aW9uLnNpbmdsZUZpZWxkTmFtZSkge1xyXG4gICAgICAgIGlmIChyZWxhdGlvbi5jaGlsZHJlbiAmJiByZWxhdGlvbi5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNoaWxkUmVsYXRpb24gPSByZWxhdGlvbnNUcmVlW3JlbGF0aW9uLmNoaWxkcmVuWzBdXTtcclxuICAgICAgICAgICAgY2hpbGRJdGVtID0gdGhpcy5fZ2V0T2JqZWN0QnlJZEZyb21BcnJheShjaGlsZFJlbGF0aW9uLnJlc3VsdCwgc2luZ2xlT2JqZWN0W3JlbGF0aW9uLnNpbmdsZUZpZWxkTmFtZV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2luZ2xlUmVzdWx0KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaW5nbGVPYmplY3RbcmVsYXRpb24uc2luZ2xlRmllbGROYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICB2YXIgcGFzc2VkUHJvcGVydGllcyA9IHt9O1xyXG5cclxuICAgIGlmIChyZWxhdGlvbi5jaGlsZHJlbiAmJiByZWxhdGlvbi5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWxhdGlvbi5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBjaGlsZFJlbGF0aW9uID0gcmVsYXRpb25zVHJlZVtyZWxhdGlvbi5jaGlsZHJlbltqXV07XHJcbiAgICAgICAgICAgIHZhciBjaGlsZFJlbGF0aW9uRmllbGQgPSBjaGlsZFJlbGF0aW9uLnJlbGF0aW9uRmllbGQ7XHJcbiAgICAgICAgICAgIHZhciB1c2VyRGVmaW5lZFJlbE5hbWUgPSBjaGlsZFJlbGF0aW9uLnVzZXJEZWZpbmVkTmFtZTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZFJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcGFzc2VkUHJvcGVydGllc1tjaGlsZFJlbGF0aW9uRmllbGRdID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGlubmVyUmVsYXRpb25SZXN1bHQgPSBjaGlsZFJlbGF0aW9uLnJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZFJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbm5lclJlbGF0aW9uUmVzdWx0Lmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkU2luZ2xlUmVzdWx0VG9QYXJlbnRBcnJheShyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBpbm5lclJlbGF0aW9uUmVzdWx0W2tdLCByZXN1bHQsIHVzZXJEZWZpbmVkUmVsTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbdXNlckRlZmluZWRSZWxOYW1lXSA9IGNoaWxkUmVsYXRpb24uaXNBcnJheSgpID8gW10gOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVPYmplY3RbY2hpbGRSZWxhdGlvbkZpZWxkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRSZWxhdGlvbi5zb3J0RXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzb3J0aW5nIHdlIHJlcGxhY2UgaXRlbXMgdXNpbmcgb3JkZXIgb2YgdGhlIHF1ZXJ5IHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBpbm5lclJlbGF0aW9uUmVzdWx0Lmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdLmluZGV4T2YoaW5uZXJSZWxhdGlvblJlc3VsdFtwXS5JZCkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEl0ZW0gPSBpbm5lclJlbGF0aW9uUmVzdWx0W3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRTaW5nbGVSZXN1bHRUb1BhcmVudEFycmF5KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSwgcmVzdWx0LCB1c2VyRGVmaW5lZFJlbE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgcmVwbGFjZSBpdGVtcyBnZXR0aW5nIHRoZW0gYnkgaWQgd2hpY2ggd2UgaGF2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaW5nbGVPYmplY3RbY2hpbGRSZWxhdGlvbkZpZWxkXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IHRoaXMuX2dldE9iamVjdEJ5SWRGcm9tQXJyYXkoaW5uZXJSZWxhdGlvblJlc3VsdCwgc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF1baV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFNpbmdsZVJlc3VsdFRvUGFyZW50QXJyYXkocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtLCByZXN1bHQsIHVzZXJEZWZpbmVkUmVsTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEl0ZW0gPSB0aGlzLl9nZXRPYmplY3RCeUlkRnJvbUFycmF5KGlubmVyUmVsYXRpb25SZXN1bHQsIHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3VzZXJEZWZpbmVkUmVsTmFtZV0gPSB0aGlzLl9nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIGFsbCBvdGhlciBmaWVsZHMgdG8gdGhlIHJlc3VsdCAoZXhjZXB0IHRoZSByZWxhdGlvbiBmaWVsZHMgd2hpY2ggd2UgaGF2ZSBhbHJlYWR5IHJlcGxhY2VkKS5cclxuICAgIGZvciAodmFyIHByb3AgaW4gc2luZ2xlT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIHByb3BlcnR5U2hvdWxkQmVBZGRlZFRvUmVzdWx0ID0gc2luZ2xlT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApICYmICFwYXNzZWRQcm9wZXJ0aWVzW3Byb3BdICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkRXhpc3RJbkZpZWxkc0V4cHJlc3Npb24ocHJvcCwgcmVsYXRpb24ub3JpZ2luYWxGaWVsZHNFeHByZXNzaW9uKTtcclxuICAgICAgICBpZiAocHJvcGVydHlTaG91bGRCZUFkZGVkVG9SZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gc2luZ2xlT2JqZWN0W3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5fYWRkU2luZ2xlUmVzdWx0VG9QYXJlbnRBcnJheSA9IGZ1bmN0aW9uIChyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBjaGlsZEl0ZW0sIHJlc3VsdCwgdXNlckRlZmluZWRSZWxOYW1lKSB7XHJcbiAgICB2YXIgc2luZ2xlUmVzdWx0ID0gdGhpcy5fZ2V0U2luZ2xlUmVzdWx0KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSk7XHJcbiAgICByZXN1bHRbdXNlckRlZmluZWRSZWxOYW1lXSA9IHJlc3VsdFt1c2VyRGVmaW5lZFJlbE5hbWVdIHx8IFtdO1xyXG4gICAgaWYgKHNpbmdsZVJlc3VsdCkge1xyXG4gICAgICAgIHJlc3VsdFt1c2VyRGVmaW5lZFJlbE5hbWVdLnB1c2goc2luZ2xlUmVzdWx0KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBmaWVsZCB3aWxsIGJlIHJldHVybmVkIHZpYSBnaXZlbiBmaWVsZHMgZXhwcmVzc2lvbi5cclxuICogQHBhcmFtIGZpZWxkIC0gVGhlIG5hbWUgb2YgdGhlIGZpZWxkLlxyXG4gKiBAcGFyYW0gZmllbGRzRXhwcmVzc2lvbiAtIFRoZSBGaWVsZHMgZXhwcmVzc2lvbiB3aGljaCBpcyBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuX2ZpZWxkRXhpc3RJbkZpZWxkc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoZmllbGQsIGZpZWxkc0V4cHJlc3Npb24pIHtcclxuICAgIGlmIChmaWVsZHNFeHByZXNzaW9uID09PSB1bmRlZmluZWQgfHwgT2JqZWN0LmtleXMoZmllbGRzRXhwcmVzc2lvbikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpZWxkID09PSBDb25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQpIHtcclxuICAgICAgICBpZiAoZmllbGRzRXhwcmVzc2lvbltmaWVsZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkc0V4cHJlc3Npb25bZmllbGRdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc0V4Y2x1c2l2ZSA9IFJlbGF0aW9uVHJlZUJ1aWxkZXIuZ2V0SXNGaWVsZHNFeHByZXNzaW9uRXhjbHVzaXZlKGZpZWxkc0V4cHJlc3Npb24pO1xyXG5cclxuICAgIGlmIChpc0V4Y2x1c2l2ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgcmV0dXJuICFmaWVsZHNFeHByZXNzaW9uLmhhc093blByb3BlcnR5KGZpZWxkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkc0V4cHJlc3Npb24uaGFzT3duUHJvcGVydHkoZmllbGQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHRoZSByZXN1bHQgZm9yIGEgc2luZ2xlIHJlbGF0aW9uIChpbiBjYXNlcyB3aGVuIEV4ZWN1dGlvbk5vZGUgY29udGFpbnMgbW9yZSB0aGFuIG9uZSByZWxhdGlvbnMpLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgcmVsYXRpb24gb2JqZWN0LlxyXG4gKiBAcGFyYW0gcXVlcnlSZXN1bHQgLSBSZXN1bHQgb2YgdGhlIGNvbWJpbmVkIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5Qcm9jZXNzb3IucHJvdG90eXBlLl9leHRyYWN0UmVzdWx0Rm9yUmVsYXRpb24gPSBmdW5jdGlvbiAocmVsYXRpb24sIHF1ZXJ5UmVzdWx0KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5UmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkcy5oYXNPd25Qcm9wZXJ0eShxdWVyeVJlc3VsdFtpXS5JZCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHF1ZXJ5UmVzdWx0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHF1ZXJ5UmVzdWx0W2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgYW4gb2JqZWN0IHdpdGggYSBnaXZlbiBJZCBmcm9tIEFycmF5LlxyXG4gKiBAcGFyYW0gYXJyYXlcclxuICogQHBhcmFtIGlkXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5fZ2V0T2JqZWN0QnlJZEZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgaWQpIHtcclxuICAgIGlmIChhcnJheSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5W2ldLklkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gZXhwYW5kRXhwcmVzc2lvblxyXG4gKiBAcGFyYW0gbWFpblR5cGVOYW1lXHJcbiAqIEBwYXJhbSBpc0FycmF5XHJcbiAqIEBwYXJhbSBmaWVsZHNFeHByZXNzaW9uXHJcbiAqIEBwYXJhbSBtYXhUYWtlVmFsdWVcclxuICogQHBhcmFtIHByZXBhcmVDb250ZXh0XHJcbiAqIEBwYXJhbSBkb25lXHJcbiAqL1xyXG5Qcm9jZXNzb3IucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbiwgbWFpblR5cGVOYW1lLCBpc0FycmF5LCBmaWVsZHNFeHByZXNzaW9uLCBtYXhUYWtlVmFsdWUsIHByZXBhcmVDb250ZXh0LCBkb25lKSB7XHJcbiAgICB2YXIgcnRiID0gbmV3IFJlbGF0aW9uVHJlZUJ1aWxkZXIoZXhwYW5kRXhwcmVzc2lvbiwgbWFpblR5cGVOYW1lLCBpc0FycmF5LCBmaWVsZHNFeHByZXNzaW9uLCBtYXhUYWtlVmFsdWUsIHRoaXMuX21ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbiwgcHJlcGFyZUNvbnRleHQpO1xyXG4gICAgcnRiLmJ1aWxkKGZ1bmN0aW9uIChlcnIsIG1hcCkge1xyXG4gICAgICAgIHZhciBtYWluUXVlcnlGaWVsZHNFeHByZXNzaW9uO1xyXG4gICAgICAgIGlmIChtYXApIHtcclxuICAgICAgICAgICAgbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvbiA9IG1hcFttYXAuJHJvb3RdLmZpZWxkc0V4cHJlc3Npb247XHJcbiAgICAgICAgICAgIHZhciBwcmVwYXJlUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgcmVsYXRpb25zVHJlZTogcnRiLFxyXG4gICAgICAgICAgICAgICAgbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvbjogbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvbmUoZXJyLCBwcmVwYXJlUmVzdWx0KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlbGF0aW9uc1RyZWVcclxuICogQHBhcmFtIG1haW5RdWVyeVJlc3VsdFxyXG4gKiBAcGFyYW0gZXhwYW5kQ29udGV4dFxyXG4gKiBAcGFyYW0gZG9uZVxyXG4gKi9cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAocmVsYXRpb25zVHJlZSwgbWFpblF1ZXJ5UmVzdWx0LCBleHBhbmRDb250ZXh0LCBkb25lKSB7XHJcbiAgICB2YXIgcmVsYXRpb25zVHJlZU1hcCA9IHJlbGF0aW9uc1RyZWUubWFwO1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIGV4ZWN1dGlvblRyZWUgPSBuZXcgRXhlY3V0aW9uVHJlZShyZWxhdGlvbnNUcmVlTWFwKTtcclxuICAgIGV4ZWN1dGlvblRyZWUuYnVpbGQoKTtcclxuICAgIHJlbGF0aW9uc1RyZWVNYXBbcmVsYXRpb25zVHJlZU1hcC4kcm9vdF0ucmVzdWx0ID0gbWFpblF1ZXJ5UmVzdWx0O1xyXG4gICAgdmFyIGV4ZWN1dGlvblRyZWVNYXAgPSBleGVjdXRpb25UcmVlLl9tYXA7XHJcblxyXG4gICAgdmFyIGV4ZWN1dGlvblRyZWVSb290ID0gdGhpcy5fZ2V0RXhlY3V0aW9uVHJlZVJvb3QoZXhlY3V0aW9uVHJlZU1hcCk7XHJcblxyXG4gICAgdmFyIG1heFF1ZXJpZXNDb3VudCA9IDIwO1xyXG4gICAgaWYgKE9iamVjdC5rZXlzKGV4ZWN1dGlvblRyZWVNYXApLmxlbmd0aCA+IG1heFF1ZXJpZXNDb3VudCkge1xyXG4gICAgICAgIGRvbmUobmV3IEV4cGFuZEVycm9yKCdFeHBhbmQgZXhwcmVzc2lvbiByZXN1bHRzIGluIG1vcmUgdGhhbiAnICsgbWF4UXVlcmllc0NvdW50ICsgJyBpbm5lciBxdWVyaWVzIScpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXhlY3V0aW9uVHJlZVJvb3QpIHtcclxuICAgICAgICB2YXIgZXhlY0Z1bmNzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGVjdXRpb25UcmVlUm9vdC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBleGVjRnVuY3MucHVzaCh0aGlzLl9jcmVhdGVFeGVjdXRlTm9kZUV4ZWN1dG9yKHJlbGF0aW9uc1RyZWUsIGV4ZWN1dGlvblRyZWUsIGV4ZWN1dGlvblRyZWVNYXBbZXhlY3V0aW9uVHJlZVJvb3QuY2hpbGRyZW5baV1dLCBleHBhbmRDb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV4ZWNGdW5jcyBhcmUgZnVuY3Rpb25zIGNyZWF0ZWQgZm9yIGV2ZXJ5IHNpbmdsZSBleGVjdXRpb24gbm90ZVxyXG4gICAgICAgIC8vIHdlIGV4ZWN1dGUgdGhlbSBpbiBhc3luYywgc2luY2UgdGhlIHJlc3VsdCBvZiB0aGUgcGFyZW50IHJlbGF0aW9uIGlzIHVzZWQgdG8gZ2V0IGNvcnJlY3QgZmlsdGVyLlxyXG4gICAgICAgIGFzeW5jLnNlcmllcyhleGVjRnVuY3MsIGZ1bmN0aW9uIG9uUHJvY2Vzc0V4ZWN1dGlvblRyZWUoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdFJlbGF0aW9uID0gcmVsYXRpb25zVHJlZU1hcFtyZWxhdGlvbnNUcmVlTWFwLiRyb290XTtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1haW5RdWVyeVJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1haW5RdWVyeVJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUmVzdWx0ID0gc2VsZi5fZ2V0U2luZ2xlUmVzdWx0KHJlbGF0aW9uc1RyZWVNYXAsIHJvb3RSZWxhdGlvbiwgbWFpblF1ZXJ5UmVzdWx0W2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2luZ2xlUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gc2VsZi5fZ2V0U2luZ2xlUmVzdWx0KHJlbGF0aW9uc1RyZWVNYXAsIHJvb3RSZWxhdGlvbiwgbWFpblF1ZXJ5UmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUHJvY2Vzc29yLkNvbnN0YW50cyA9IENvbnN0YW50cztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc29yO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEV4cGFuZEVycm9yID0gcmVxdWlyZSgnLi9FeHBhbmRFcnJvcicpO1xyXG5cclxuZnVuY3Rpb24gUmVsYXRpb25Ob2RlKG9wdGlvbnMpIHtcclxuICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgICB0aGlzLnJlbGF0aW9uRmllbGQgPSBvcHRpb25zLnJlbGF0aW9uRmllbGQ7XHJcbiAgICB0aGlzLnBhdGggPSBvcHRpb25zLnBhdGggfHwgb3B0aW9ucy5wYXJlbnQgKyAnLicgKyBvcHRpb25zLnJlbGF0aW9uRmllbGQ7XHJcbiAgICB0aGlzLmZpZWxkc0V4cHJlc3Npb24gPSBvcHRpb25zLmZpZWxkc0V4cHJlc3Npb24gfHwge307XHJcbiAgICB0aGlzLnRhcmdldFR5cGVOYW1lID0gb3B0aW9ucy50YXJnZXRUeXBlTmFtZTtcclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgIHRoaXMuaXNJbnZlcnRlZFJlbGF0aW9uID0gb3B0aW9ucy5pc0ludmVydGVkUmVsYXRpb247XHJcbiAgICB0aGlzLmlzQXJyYXlSb290ID0gb3B0aW9ucy5pc0FycmF5Um9vdDsgLy91c2VkIGZvciB2YWxpZGF0aW9uIG9mIGNhc2VzIHdoZXJlIHZhcmlvdXMgZXhwYW5kIGZlYXR1cmVzIGFyZSBkaXNhYmxlZCBmb3IgYSBHZXRBbGwgc2NlbmFyaW8uXHJcbiAgICB0aGlzLmhhc0FycmF5VmFsdWVzID0gZmFsc2U7Ly9zZXQgd2hlbiB3ZSBoYXZlIGV4ZWN1dGVkIHRoZSBxdWVyeS4gVXNlZCBpbiB2YWxpZGF0aW9uIHNjZW5hcmlvcyB3aGVyZSB3ZSBkbyBub3QgaGF2ZSBtZXRhZGF0YSBhYm91dCB3aGV0aGVyIHRoZSByZWxhdGlvbiBpcyBhbiBhcnJheSBvciBub3QuXHJcblxyXG4gICAgdmFyIGV4cGFuZEV4cHJlc3Npb24gPSBvcHRpb25zLmV4cGFuZEV4cHJlc3Npb24gfHwge307XHJcblxyXG4gICAgdGhpcy5wYXJlbnRSZWxhdGlvbkZpZWxkID0gZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuUGFyZW50UmVsYXRpb25GaWVsZE5hbWVdIHx8IENvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudDtcclxuICAgIHZhciByZWxhdGlvbkZpZWxkID0gdGhpcy5pc0ludmVydGVkUmVsYXRpb24gPyB0aGlzLnBhdGggOiB0aGlzLnJlbGF0aW9uRmllbGQ7IC8vaW52ZXJ0ZWQgcmVsYXRpb25zIGFwcGVhciB3aXRoIHRoZSBmdWxsIHBhdGggLSBDb250ZW50VHlwZS5GaWVsZCAtIGluIHRoZSByZXN1bHQgd2hlbiBleHBhbmRpbmcuXHJcbiAgICB0aGlzLnVzZXJEZWZpbmVkTmFtZSA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lXSB8fCByZWxhdGlvbkZpZWxkO1xyXG4gICAgXy5leHRlbmQodGhpcy5maWVsZHNFeHByZXNzaW9uLCBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5GaWVsZHNFeHByZXNzaW9uTmFtZV0pO1xyXG4gICAgdGhpcy5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24gPSB7fTtcclxuICAgIF8uZXh0ZW5kKHRoaXMub3JpZ2luYWxGaWVsZHNFeHByZXNzaW9uLCB0aGlzLmZpZWxkc0V4cHJlc3Npb24pO1xyXG4gICAgdGhpcy5zaW5nbGVGaWVsZE5hbWUgPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5TaW5nbGVGaWVsZEV4cHJlc3Npb25OYW1lXTtcclxuICAgIHRoaXMuZmlsdGVyRXhwcmVzc2lvbiA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLkZpbHRlckV4cHJlc3Npb25OYW1lXTtcclxuICAgIHRoaXMuc29ydEV4cHJlc3Npb24gPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5Tb3J0RXhwcmVzc2lvbk5hbWVdO1xyXG4gICAgdGhpcy5za2lwID0gZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuU2tpcEV4cHJlc3Npb25OYW1lXTtcclxuICAgIHRoaXMudGFrZSA9IHRoaXMuX2dldFRha2VMaW1pdChleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5UYWtlRXhwcmVzc2lvbk5hbWVdLCBvcHRpb25zLm1heFRha2VWYWx1ZSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgdGFrZSBsaW1pdCBkZXBlbmRpbmcgb24gdGhlIGFwcGxpY2F0aW9uIGFuZCB0aGUgdGFrZSB2YWx1ZSB0aGF0IHRoZSB1c2VyIGhhcyBwcm92aWRlZC5cclxuICogQHBhcmFtIGNsaWVudFRha2VWYWx1ZVxyXG4gKiBAcGFyYW0gbWF4VGFrZVZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5SZWxhdGlvbk5vZGUucHJvdG90eXBlLl9nZXRUYWtlTGltaXQgPSBmdW5jdGlvbiAoY2xpZW50VGFrZVZhbHVlLCBtYXhUYWtlVmFsdWUpIHtcclxuICAgIG1heFRha2VWYWx1ZSA9IG1heFRha2VWYWx1ZSB8fCBDb25zdGFudHMuRGVmYXVsdFRha2VJdGVtc0NvdW50O1xyXG4gICAgaWYgKGNsaWVudFRha2VWYWx1ZSkge1xyXG4gICAgICAgIGlmIChjbGllbnRUYWtlVmFsdWUgPiBtYXhUYWtlVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4cGFuZEVycm9yKCdUaGUgbWF4aW11bSBhbGxvd2VkIHRha2UgdmFsdWUgd2hlbiBleHBhbmRpbmcgcmVsYXRpb25zIGlzICcgKyBtYXhUYWtlVmFsdWUgKyAnIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xpZW50VGFrZVZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbWF4VGFrZVZhbHVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFueW9uZSB1c2luZyB0aGUgYnMtZXhwYW5kLXByb2Nlc3NvciBtb2R1bGUgY2FuIHNldCB3aGV0aGVyIHRoZSByZWxhdGlvbiBpcyBhIG11bHRpcGxlIHJlbGF0aW9uIGluIHRoZSBwcmVwYXJlIHBoYXNlLlxyXG4gKiBUaGlzIHdpbGwgYWxsb3cgZm9yIGNlcnRhaW4gcmVzdHJpY3Rpb25zIHRvIGJlIGVuZm9yY2VkIGRpcmVjdGx5IG9uIHRoZSBwcmVwYXJlIHBoYXNlIGluc3RlYWQgb2YgdGhlIGV4ZWN1dGlvbiBwaGFzZS5cclxuICovXHJcblJlbGF0aW9uTm9kZS5wcm90b3R5cGUuc2V0SXNBcnJheUZyb21NZXRhZGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuaXNBcnJheUZyb21NZXRhZGF0YSA9IHRydWU7XHJcbn07XHJcblxyXG5SZWxhdGlvbk5vZGUucHJvdG90eXBlLmlzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBXZSBjYW4gZmluZCBvdXQgaWYgYSByZWxhdGlvbiBpcyBhbiBhcnJheSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxyXG4gICAgLy8gRnJvbSBtZXRhZGF0YSBpbiB0aGUgQVBJIFNlcnZlci5cclxuICAgIC8vIEFsbCBpbnZlcnRlZCByZWxhdGlvbnMgYXJlIGFycmF5LlxyXG4gICAgLy8gT25jZSB2YWx1ZXMgaGF2ZSBiZWVuIHJlY2VpdmVkIHdlIGNhbiBmaW5kIG91dC4gVGhpcyBpcyB1c2VkIGZvciBzY2VuYXJpb3Mgd2hlcmUgd2UgZG8gbm90IGhhdmUgbWV0YWRhdGEgYWJvdXQgdGhlIHJlbGF0aW9uIChvZmZsaW5lIHN0b3JhZ2UgaW4gU0RLKS5cclxuICAgIHJldHVybiB0aGlzLmlzQXJyYXlGcm9tTWV0YWRhdGEgfHwgdGhpcy5pc0ludmVydGVkUmVsYXRpb24gfHwgdGhpcy5oYXNBcnJheVZhbHVlcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVsYXRpb25Ob2RlO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBSZWxhdGlvbk5vZGUgPSByZXF1aXJlKCcuL1JlbGF0aW9uTm9kZScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XHJcbnZhciBFeHBhbmRFcnJvciA9IHJlcXVpcmUoJy4vRXhwYW5kRXJyb3InKTtcclxuXHJcbi8vdmFyIHJlbGF0aW9uRmllbGRQcm9wZXJ0eU5hbWUgPSBDb25zdGFudHMuUmVsYXRpb25FeHByZXNzaW9uTmFtZTtcclxuXHJcbnZhciBwb3NzaWJsZUV4cGFuZE9wdGlvbnMgPSBbXHJcbiAgICBDb25zdGFudHMuRXhwYW5kRXhwcmVzc2lvbk5hbWUsXHJcbiAgICBDb25zdGFudHMuUmV0dXJuQXNGaWVsZE5hbWUsXHJcbiAgICBDb25zdGFudHMuRmllbGRzRXhwcmVzc2lvbk5hbWUsXHJcbiAgICBDb25zdGFudHMuU2luZ2xlRmllbGRFeHByZXNzaW9uTmFtZSxcclxuICAgIENvbnN0YW50cy5Tb3J0RXhwcmVzc2lvbk5hbWUsXHJcbiAgICBDb25zdGFudHMuRmlsdGVyRXhwcmVzc2lvbk5hbWUsXHJcbiAgICBDb25zdGFudHMuU2tpcEV4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLlRha2VFeHByZXNzaW9uTmFtZSxcclxuICAgIENvbnN0YW50cy5QYXJlbnRSZWxhdGlvbkZpZWxkTmFtZSxcclxuICAgIENvbnN0YW50cy5UYXJnZXRUeXBlTmFtZUZpZWxkTmFtZVxyXG5dO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHVzZWQgdG8gcGFyc2UgRXhwYW5kIGV4cHJlc3Npb24gYW5kIGJ1aWxkIGEgY29ycmVzcG9uZGluZyByZWxhdGlvbiB0cmVlLlxyXG4gKiBJbiBhIHByb2Nlc3Mgb2YgY3JlYXRpbmcgdGhlIHJlbGF0aW9uIHRyZWUgYXJlIHBlcmZvcm1lZCBzZXZlcmFsIGNoZWNrcyBpbiBvcmRlciB0byBmb3JjZSBzb21lIGxpbWl0YXRpb25zIC1cclxuICogNTAgaXRlbXMgYm90aCBmb3IgbWFzdGVyIGFuZCBjaGlsZCBxdWVyaWVzIGFuZCBlbnRpcmUgYW1vdW50IG9mIGFsbCBxdWVyaWVzIGxpbWl0ZWQgdG8gMjAuXHJcbiAqIENoZWNrcyBpZiB0aGUgcmVsYXRpb24gZmllbGQgZ2l2ZW4gYnkgdGhlIGN1c3RvbWVyIGlzIHZhbGlkIChmb3IgZXhhbXBsZTogdXNlciBnaXZlcyBcIkxpa2VcIiB3aGlsZSB0aGUgcmVsYXRpb24gZmllbGQgaXMgXCJMaWtlc1wiKS5cclxuICogQ2hlY2tzIGZvciBwb3NzaWJsZSBleHBhbmQgb3B0aW9ucy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgUmVsYXRpb25UcmVlQnVpbGRlciA9IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uLCBtYWluVHlwZU5hbWUsIGlzQXJyYXksIGZpZWxkc0V4cHJlc3Npb24sIG1heFRha2VWYWx1ZSwgbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICB0aGlzLm1heFRha2VWYWx1ZSA9IG1heFRha2VWYWx1ZTtcclxuICAgIHRoaXMuX21ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbiA9IG1ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbjtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLmV4cGFuZEV4cHJlc3Npb24gPSB0aGlzLnByb2Nlc3NFeHBhbmRFeHByZXNzaW9uKGV4cGFuZEV4cHJlc3Npb24pO1xyXG4gICAgLy8gbWFyayB0aGUgbWFpbiBxdWVyeSBpbiBvcmRlciB0byBhdm9pZCBzb21lIGR1cGxpY2F0aW9uIGlzc3Vlcy5cclxuICAgIHRoaXMubWFwID0ge307XHJcbiAgICB0aGlzLm1hcFttYWluVHlwZU5hbWVdID0gbmV3IFJlbGF0aW9uTm9kZSh7XHJcbiAgICAgICAgdGFyZ2V0VHlwZU5hbWU6IG1haW5UeXBlTmFtZSxcclxuICAgICAgICBpc0FycmF5Um9vdDogaXNBcnJheSxcclxuICAgICAgICBmaWVsZHNFeHByZXNzaW9uOiBmaWVsZHNFeHByZXNzaW9uLFxyXG4gICAgICAgIHZhbGlkYXRlZDogdHJ1ZSxcclxuICAgICAgICBwYXRoOiBtYWluVHlwZU5hbWUsXHJcbiAgICAgICAgbWF4VGFrZVZhbHVlOiBtYXhUYWtlVmFsdWVcclxuICAgIH0pO1xyXG4gICAgdGhpcy5tYXBbbWFpblR5cGVOYW1lXS5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24gPSB7fTtcclxuICAgIF8uZXh0ZW5kKHRoaXMubWFwW21haW5UeXBlTmFtZV0ub3JpZ2luYWxGaWVsZHNFeHByZXNzaW9uLCBmaWVsZHNFeHByZXNzaW9uKTtcclxuICAgIHRoaXMubWFwLiRyb290ID0gbWFpblR5cGVOYW1lO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgZnVsbHkgcXVhbGlmaWVkIGV4cGFuZCBleHByZXNzaW9uIGZyb20gc2hvcnRoYW5kIHVzYWdlczpcclxuICoge1wiTGlrZXNcIjogdHJ1ZX0gLT4ge1wiTGlrZXNcIjoge1wiUmV0dXJuQXNcIjogXCJMaWtlc1wifX1cclxuICoge1wiTGlrZXNcIjogXCJMaWtlc0V4cGFuZGVkXCJ9IC0+IHtcIkxpa2VzXCI6IHtcIlJldHVybkFzXCI6IFwiTGlrZXNFeHBhbmRlZFwifX1cclxuICogQHBhcmFtIGV4cGFuZEV4cHJlc3Npb25cclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBleHBhbmRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgaWYgKGV4cGFuZEV4cHJlc3Npb24uaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV0gPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV0gPSB7fTtcclxuICAgICAgICAgICAgICAgIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldW0NvbnN0YW50cy5SZXR1cm5Bc0ZpZWxkTmFtZV0gPSBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uRmllbGQgPSBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldID0ge307XHJcbiAgICAgICAgICAgICAgICBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XVtDb25zdGFudHMuUmV0dXJuQXNGaWVsZE5hbWVdID0gcmVsYXRpb25GaWVsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBleHBhbmRFeHByZXNzaW9uO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyB0aGUgcmVsYXRpb24gdHJlZS5cclxuICogQHBhcmFtIGRvbmVcclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGRvbmUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5idWlsZE1hcEludGVybmFsKHRoaXMuZXhwYW5kRXhwcmVzc2lvbiwgdGhpcy5tYXAuJHJvb3QpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBkb25lKGUpO1xyXG4gICAgfVxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgcmVxdWlyZSgnYXN5bmMnKS5zZXJpZXMoW1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJlUmVsYXRpb25UcmVlLmJpbmQodGhpcyksXHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlbGF0aW9uVHJlZS5iaW5kKHRoaXMpXHJcbiAgICBdLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgZG9uZShlcnIsIHNlbGYubWFwKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSByZWxhdGlvbk5hbWUgLSBBIHBhdGggdG8gdGhlIGV4dGVybmFsIHJlbGF0aW9uIGNvbGxlY3Rpb24gKENvbW1lbnRzLkFjdGl2aXR5SWQpXHJcbiAqIEBwYXJhbSBleHBhbmRFeHByZXNzaW9uIC0gVGhlIGV4cGFuZCBleHByZXNzaW9uIHRoYXQgY29udGFpbnMgYWxsIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWxhdGlvblxyXG4gKiBAcGFyYW0gcm9vdE5hbWUgLSBOYW1lIG9mIHRoZSBwYXJlbnQgcmVsYXRpb24uXHJcbiAqIEByZXR1cm5zIHtSZWxhdGlvbk5vZGV9XHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVJbnZlcnRlZFJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uTmFtZSwgZXhwYW5kRXhwcmVzc2lvbiwgcm9vdE5hbWUpIHtcclxuICAgIHZhciBvcHRpb25zID0ge307XHJcbiAgICB2YXIgcmVsYXRpb25OYW1lUGFydHMgPSByZWxhdGlvbk5hbWUuc3BsaXQoJy4nKTtcclxuICAgIG9wdGlvbnMucGFyZW50ID0gcm9vdE5hbWU7XHJcbiAgICBvcHRpb25zLnJlbGF0aW9uRmllbGQgPSByZWxhdGlvbk5hbWVQYXJ0c1sxXTtcclxuICAgIG9wdGlvbnMuaXNJbnZlcnRlZFJlbGF0aW9uID0gdHJ1ZTtcclxuICAgIG9wdGlvbnMudGFyZ2V0VHlwZU5hbWUgPSByZWxhdGlvbk5hbWVQYXJ0c1swXTtcclxuICAgIG9wdGlvbnMuZXhwYW5kRXhwcmVzc2lvbiA9IGV4cGFuZEV4cHJlc3Npb247XHJcbiAgICBvcHRpb25zLnBhdGggPSByZWxhdGlvbk5hbWU7XHJcbiAgICBvcHRpb25zLm1heFRha2VWYWx1ZSA9IHRoaXMubWF4VGFrZVZhbHVlO1xyXG4gICAgb3B0aW9ucy52YWxpZGF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFJlbGF0aW9uTm9kZShvcHRpb25zKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbnRlcm5hbCBtZXRob2Qgd2hpY2ggcGFyc2VzIHRoZSBleHBhbmQgZXhwcmVzc2lvbiBhbmQgcHJvZHVjZXMgYSBiYXNpYyByZWxhdGlvbiB0cmVlIChvbmx5IG5hbWVzIGFuZCBwYXJlbnQgcmVsYXRpb25zKS5cclxuICogQHBhcmFtIGV4cGFuZEV4cHJlc3Npb24gLSBUaGUgZXhwYW5kIGV4cHJlc3Npb24gd2hpY2ggd2lsbCBiZSBwcm9jZXNzZWQuXHJcbiAqIEBwYXJhbSByb290TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByb290IHJlbGF0aW9uIChtYXN0ZXIgcXVlcnkpIHVzdWFsbHkgdGhlIG5hbWUgb2YgdGhlIHJlcXVlc3RlZCBjb250ZW50IHR5cGUgKEFjdGl2aXRpZXMpLlxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuYnVpbGRNYXBJbnRlcm5hbCA9IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uLCByb290TmFtZSkge1xyXG4gICAgZm9yICh2YXIgcmVsYXRpb25OYW1lIGluIGV4cGFuZEV4cHJlc3Npb24pIHtcclxuICAgICAgICBpZiAoZXhwYW5kRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShyZWxhdGlvbk5hbWUpKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RXhwcmVzc2lvbiA9IGV4cGFuZEV4cHJlc3Npb25bcmVsYXRpb25OYW1lXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIG9wdGlvbiBpbiBjdXJyZW50RXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFeHByZXNzaW9uLmhhc093blByb3BlcnR5KG9wdGlvbikgJiYgcG9zc2libGVFeHBhbmRPcHRpb25zLmluZGV4T2Yob3B0aW9uKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhwYW5kRXJyb3IoJ1xcXCInICsgb3B0aW9uICsgJ1xcXCInICsgJyBpcyBub3QgYSB2YWxpZCBvcHRpb24gZm9yIEV4cGFuZCBleHByZXNzaW9uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZWxhdGlvbk5hbWUuaW5kZXhPZignLicpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnZlcnRlZFJlbGF0aW9uID0gdGhpcy5jcmVhdGVJbnZlcnRlZFJlbGF0aW9uKHJlbGF0aW9uTmFtZSwgY3VycmVudEV4cHJlc3Npb24sIHJvb3ROYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwW2ludmVydGVkUmVsYXRpb24ucGF0aF0gPSBpbnZlcnRlZFJlbGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBbaW52ZXJ0ZWRSZWxhdGlvbi5wYXJlbnRdLmNoaWxkcmVuLnB1c2goaW52ZXJ0ZWRSZWxhdGlvbi5wYXRoKTtcclxuICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBmaWVsZCBleHByZXNzaW9uIGluIHRoZSBvcmlnaW5hbCBmaWVsZHMgZXhwcmVzc2lvbiBpbiBvcmRlciB0byBnZXQgdGhlIHJlc3VsdCBmb3IgdGhhdCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgUmVsYXRpb25UcmVlQnVpbGRlci5hZGRGaWVsZFRvRmllbGRzRXhwcmVzc2lvbih0aGlzLm1hcFtpbnZlcnRlZFJlbGF0aW9uLnBhcmVudF0ub3JpZ2luYWxGaWVsZHNFeHByZXNzaW9uLCBpbnZlcnRlZFJlbGF0aW9uLnVzZXJEZWZpbmVkTmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZEV4cHJlc3Npb25bcmVsYXRpb25OYW1lXVtDb25zdGFudHMuRXhwYW5kRXhwcmVzc2lvbk5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZEV4cGFuZEV4cHJlc3Npb24gPSB0aGlzLnByb2Nlc3NFeHBhbmRFeHByZXNzaW9uKGV4cGFuZEV4cHJlc3Npb25bcmVsYXRpb25OYW1lXVtDb25zdGFudHMuRXhwYW5kRXhwcmVzc2lvbk5hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkTWFwSW50ZXJuYWwocHJvY2Vzc2VkRXhwYW5kRXhwcmVzc2lvbiwgaW52ZXJ0ZWRSZWxhdGlvbi5wYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJlbGF0aW9uRmllbGQgPSByZWxhdGlvbk5hbWU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudCA9IHJvb3ROYW1lO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5leHBhbmRFeHByZXNzaW9uID0gY3VycmVudEV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1heFRha2VWYWx1ZSA9IHRoaXMubWF4VGFrZVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50YXJnZXRUeXBlTmFtZSA9IGN1cnJlbnRFeHByZXNzaW9uW0NvbnN0YW50cy5UYXJnZXRUeXBlTmFtZUZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb25Ob2RlID0gbmV3IFJlbGF0aW9uTm9kZShvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5tYXBbb3B0aW9ucy5wYXJlbnRdO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKHJlbGF0aW9uTm9kZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwW3JlbGF0aW9uTm9kZS5wYXRoXSA9IHJlbGF0aW9uTm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEV4cHJlc3Npb24uaGFzT3duUHJvcGVydHkoQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY3VycmVudEV4cHJlc3Npb25bQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lXSkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRNYXBJbnRlcm5hbCh0aGlzLnByb2Nlc3NFeHBhbmRFeHByZXNzaW9uKGN1cnJlbnRFeHByZXNzaW9uLkV4cGFuZCksIHJlbGF0aW9uTm9kZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhwYW5kRXJyb3IocmVsYXRpb25Ob2RlLnBhdGggKyAnLkV4cGFuZCBtdXN0IGJlIGEgdmFsaWQgZXhwYW5kIGV4cHJlc3Npb24hJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYWRkaXRpb25hbCBtZXRhZGF0YSB3aGljaCBpcyBuZWNlc3NhcnkgdG8gZXhlY3V0ZSBhIHF1ZXJ5LlxyXG4gKiBOYW1lIG9mIHRoZSBjb250ZW50IHR5cGUgb2YgdGhlIGNoaWxkIHJlbGF0aW9uIGdldCB2aWEgcmVsYXRpb24gZmllbGQuXHJcbiAqIEBwYXJhbSBkb25lXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5jb25maWd1cmVSZWxhdGlvblRyZWUgPSBmdW5jdGlvbiAoZG9uZSkge1xyXG4gICAgaWYgKHRoaXMuX21ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbikge1xyXG4gICAgICAgIHZhciByZWxhdGlvbk5hbWVzID0gW107XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciByZWwgaW4gdGhpcy5tYXApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KHJlbCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcFtyZWxdLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uTmFtZXMucHVzaCh0aGlzLm1hcFtyZWxdLnJlbGF0aW9uRmllbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24ocmVsYXRpb25OYW1lcywgdGhpcy5tYXAsIHRoaXMuY29udGV4dCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGRvbmUoZXJyKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBzZXZlcmFsIGNoZWNrcyBsaWtlOlxyXG4gKiBWYWxpZGl0eSBvZiB0aGUgcmVsYXRpb24gZmllbGQuXHJcbiAqIFRvIG5vdCB1c2UgZmlsdGVyIG9yIHNvcnRpbmcgZXhwcmVzc2lvbiB3aXRoaW4gYSBcIkdldEJ5RmlsdGVyXCIgc2NlbmFyaW8uXHJcbiAqIERvZXMgbm90IGFsbG93IHRvIG5lc3QgKGV4cGFuZCBtdWx0aXBsZSByZWxhdGlvbiBmaWVsZCkgYWZ0ZXIgYSBtdWx0aXBsZSByZWxhdGlvbi5cclxuICogRG9lcyBub3QgYWxsb3cgdG8gdXNlIGJvdGggXCJGaWVsZHNcIiBhbmQgXCJTaW5nbGVGaWVsZFwiIG9wdGlvbnMuXHJcbiAqIEBwYXJhbSBkb25lXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUudmFsaWRhdGVSZWxhdGlvblRyZWUgPSBmdW5jdGlvbiAoZG9uZSkge1xyXG4gICAgdmFyIGVycm9yTWVzc2FnZSA9ICcnO1xyXG4gICAgdmFyIEVPTCA9ICdcXHJcXG4nO1xyXG4gICAgZm9yICh2YXIgcmVsYXRpb25QYXRoIGluIHRoaXMubWFwKSB7XHJcbiAgICAgICAgaWYgKHJlbGF0aW9uUGF0aCAhPT0gJyRyb290JyAmJiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShyZWxhdGlvblBhdGgpKSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGlvbiA9IHRoaXMubWFwW3JlbGF0aW9uUGF0aF07XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSB0aGlzLnZhbGlkYXRlU2luZ2xlUmVsYXRpb24ocmVsYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZUZpZWxkc0V4cHJlc3Npb25zRm9yUmVsYXRpb24ocmVsYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChlcnJvck1lc3NhZ2UgIT09ICcnKSB7XHJcbiAgICAgICAgdmFyIGZpbmFsRXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlLnN1YnN0cigwLCBlcnJvck1lc3NhZ2UubGFzdEluZGV4T2YoRU9MKSk7XHJcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEV4cGFuZEVycm9yKGZpbmFsRXJyb3JNZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gZG9uZShlcnJvcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvbmUoKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgcmVsYXRpb24gZmllbGRzIHRvIHBhcmVudCByZWxhdGlvbiBmaWVsZHMgZXhwcmVzc2lvbiBpZiBuZWVkZWQgKG90aGVyd2lzZSByZWxhdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWQpLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIHJlbGF0aW9uIHdoaWNoIHdpbGwgYmUgY29uZmlndXJlZC5cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNvbmZpZ3VyZUZpZWxkc0V4cHJlc3Npb25zRm9yUmVsYXRpb24gPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIGlmIChyZWxhdGlvbi5wYXJlbnQpIHtcclxuICAgICAgICB2YXIgcGFyZW50UmVsYXRpb25GaWVsZHNFeHByZXNzaW9uID0gdGhpcy5tYXBbcmVsYXRpb24ucGFyZW50XS5maWVsZHNFeHByZXNzaW9uO1xyXG4gICAgICAgIGlmIChyZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcclxuICAgICAgICAgICAgUmVsYXRpb25UcmVlQnVpbGRlci5hZGRGaWVsZFRvRmllbGRzRXhwcmVzc2lvbihwYXJlbnRSZWxhdGlvbkZpZWxkc0V4cHJlc3Npb24sIHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uRmllbGQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24ocGFyZW50UmVsYXRpb25GaWVsZHNFeHByZXNzaW9uLCByZWxhdGlvbi5yZWxhdGlvbkZpZWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgUmVsYXRpb25UcmVlQnVpbGRlci5hZGRGaWVsZFRvRmllbGRzRXhwcmVzc2lvbihyZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uLCByZWxhdGlvbi5yZWxhdGlvbkZpZWxkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgUmVsYXRpb25UcmVlQnVpbGRlci5hZGRGaWVsZFRvRmllbGRzRXhwcmVzc2lvbihyZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uLCBDb25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQpO1xyXG4gICAgfVxyXG4gICAgUmVsYXRpb25UcmVlQnVpbGRlci5hZGp1c3RQYXJlbnRSZWxhdGlvbkZpZWxkc0V4cHJlc3Npb24odGhpcy5tYXBbcmVsYXRpb24ucGFyZW50XSwgcmVsYXRpb24pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSByZWxhdGlvbiBmb3IgYWxsIGJ1aWxkLWluIGxpbWl0YXRpb25zLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIHJlbGF0aW9uIHdoaWNoIHdpbGwgYmUgdmFsaWRhdGVkLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFJldHVybnMgYW4gZXJyb3IgbWVzc2FnZSB3aXRoIGFsbCBlcnJvcnMgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZXJlIGlzIG5vIGVycm9ycy5cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLnZhbGlkYXRlU2luZ2xlUmVsYXRpb24gPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnJztcclxuICAgIHZhciBFT0wgPSAnXFxyXFxuJztcclxuICAgIHZhciBpc0dldEJ5RmlsdGVyUXVlcnkgPSB0aGlzLm1hcFt0aGlzLm1hcC4kcm9vdF0uaXNBcnJheVJvb3Q7XHJcblxyXG4gICAgaWYgKHJlbGF0aW9uLnBhdGggPT09IHJlbGF0aW9uLnBhcmVudCkge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSByZWxhdGlvbi5wYXRoICsgJyBoYXMgc2FtZSBwYXJlbnQgd2hpY2ggd2lsbCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wLicgKyBFT0w7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVsYXRpb24uaXNBcnJheSgpKSB7XHJcbiAgICAgICAgdmFyIG11bHRpcGxlUXVlcmllc0NvdW50ID0gdGhpcy5nZXRQYXJlbnRNdWx0aXBsZVJlbGF0aW9uc0NvdW50KHJlbGF0aW9uKTtcclxuICAgICAgICBpZiAobXVsdGlwbGVRdWVyaWVzQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnRXhwYW5kIGV4cHJlc3Npb24gaGFzIG11bHRpcGxlIHJlbGF0aW9uIFxcXCInICsgcmVsYXRpb24ucGF0aCArICdcXFwiIGluc2lkZSBhIG11bHRpcGxlIHJlbGF0aW9uLic7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBFT0w7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5tYXBbcmVsYXRpb24ucGFyZW50XSA9PT0gdGhpcy5tYXBbdGhpcy5tYXAuJHJvb3RdICYmXHJcbiAgICAgICAgICAgIGlzR2V0QnlGaWx0ZXJRdWVyeSAmJlxyXG4gICAgICAgICAgICAocmVsYXRpb24uZmlsdGVyRXhwcmVzc2lvbiB8fCByZWxhdGlvbi5zb3J0RXhwcmVzc2lvbikpIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICdGaWx0ZXIgYW5kIFNvcnQgZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIHdpdGggR2V0QnlGaWx0ZXIgc2NlbmFyaW8uJztcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0dldEJ5RmlsdGVyUXVlcnkgJiYgcmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnRXhwYW5kaW5nIGFuIGV4dGVybmFsIGNvbnRlbnQgdHlwZSBpcyBub3QgYWxsb3dlZCB3aXRoIEdldEJ5RmlsdGVyIHNjZW5hcmlvLic7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBFT0w7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyZWxhdGlvbi50YXJnZXRUeXBlTmFtZSkge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSAnRXhwYW5kaW5nIHJlbGF0aW9uIFxcXCInICsgcmVsYXRpb24ucmVsYXRpb25GaWVsZCArICdcXFwiIGhhcyBubyB0YXJnZXQgdHlwZSBuYW1lIHNwZWNpZmllZC4gWW91IHNob3VsZCB1c2UgXFxcIlRhcmdldFR5cGVOYW1lXFxcIiB0byBzcGVjaWZ5IGl0Lic7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcclxuICAgIH1cclxuICAgIGlmIChyZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uICYmIE9iamVjdC5rZXlzKHJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb24pLmxlbmd0aCAmJiByZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWUpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gcmVsYXRpb24ucGF0aCArICcgJztcclxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ2V4cGFuZCBleHByZXNzaW9uIGNvbnRhaW5zIGJvdGggXFxcIkZpZWxkc1xcXCIgYW5kIFxcXCJTaW5nbGVGaWVsZFxcXCIgZXhwcmVzc2lvbnMuJztcclxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlbGF0aW9uLnNpbmdsZUZpZWxkTmFtZSkge1xyXG4gICAgICAgIGlmIChyZWxhdGlvbi5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpb24uY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IHJlbGF0aW9uLnBhdGggKyAnIGhhcyBtdWx0aXBsZSBleHBhbmQgZXhwcmVzc2lvbnMgd2l0aCBhIHNpbmdsZSBmaWVsZCBvcHRpb24uJyArIEVPTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVsYXRpb24uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHRoaXMubWFwW3JlbGF0aW9uLmNoaWxkcmVuWzBdXS5yZWxhdGlvbkZpZWxkICE9PSByZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnRXhwYW5kIGV4cHJlc3Npb24gJyArIHJlbGF0aW9uLnBhdGg7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJyBzaW5nbGUgZmllbGQgXFxcIicgKyByZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWUgKyAnXFxcIic7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJyBkb2VzIG5vdCBtYXRjaCBjaGlsZCByZWxhdGlvbiBmaWVsZCBcXFwiJyArIHRoaXMubWFwW3JlbGF0aW9uLmNoaWxkcmVuWzBdXS5yZWxhdGlvbkZpZWxkICsgJ1xcXCIuJztcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBFT0w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBjb3VudCBvZiBwYXJlbnQgbXVsdGlwbGUgcmVsYXRpb25zLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBTdGFydGluZyByZWxhdGlvbi5cclxuICogQHJldHVybnMge251bWJlcn0gLSBjb3VudCBvZiBhbGwgcGFyZW50IG11bHRpcGxlIHJlbGF0aW9uc1xyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0UGFyZW50TXVsdGlwbGVSZWxhdGlvbnNDb3VudCA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgdmFyIHJlc3VsdCA9IDA7XHJcbiAgICB2YXIgcmVsYXRpb25Gb3JMb29wID0gcmVsYXRpb247XHJcbiAgICB3aGlsZSAocmVsYXRpb25Gb3JMb29wLnBhcmVudCkge1xyXG4gICAgICAgIHZhciBwYXJlbnRSZWxhdGlvbiA9IHRoaXMubWFwW3JlbGF0aW9uRm9yTG9vcC5wYXJlbnRdO1xyXG4gICAgICAgIGlmIChwYXJlbnRSZWxhdGlvbi5pc0FycmF5KCkgJiYgcGFyZW50UmVsYXRpb24ucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWxhdGlvbkZvckxvb3AgPSBwYXJlbnRSZWxhdGlvbjtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFkanVzdHMgZmllbGRzIGV4cHJlc3Npb24gb2YgdGhlIHBhcmVudCByZWxhdGlvbiBiYXNlZCBvbiBwYWdpbmcgc2V0dGluZyBvZiBhIHJlbGF0aW9uIChza2lwLCB0YWtlKS5cclxuICogSW4gdGhhdCBjYXNlIHdlIHB1dCBhIFwiJHNsaWNlXCIgb3B0aW9uIHdpdGhpbiB0aGUgcGFyZW50IHJlbGF0aW9uIGZpZWxkcyBleHByZXNzaW9uLlxyXG4gKiBAcGFyYW0gcGFyZW50UmVsYXRpb25cclxuICogQHBhcmFtIHJlbGF0aW9uXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLmFkanVzdFBhcmVudFJlbGF0aW9uRmllbGRzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChwYXJlbnRSZWxhdGlvbiwgcmVsYXRpb24pIHtcclxuICAgIGlmICghcmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uICYmIHJlbGF0aW9uLnRha2UgJiYgdHlwZW9mIHJlbGF0aW9uLnRha2UgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgLy8gd2hlbiByZWxhdGlvbiBoYXMgZmlsdGVyIG9yIHNvcnRpbmcgc2tpcCBhbmQgdGFrZSBzaG91bGQgbm90IGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwYXJlbnQgcmVsYXRpb24gYXMgJHNsaWNlLlxyXG4gICAgICAgIHZhciBzaG91bGRUcmFuc2ZlclBhZ2luZ1RvUGFyZW50UmVsYXRpb24gPSByZWxhdGlvbi5pc0FycmF5KCkgJiYgIXJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb24gJiYgIXJlbGF0aW9uLnNvcnRFeHByZXNzaW9uICYmIHBhcmVudFJlbGF0aW9uO1xyXG4gICAgICAgIGlmIChzaG91bGRUcmFuc2ZlclBhZ2luZ1RvUGFyZW50UmVsYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudFJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50UmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbiA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVsYXRpb24uc2tpcCAmJiB0eXBlb2YgcmVsYXRpb24uc2tpcCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb24ucmVsYXRpb25GaWVsZF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJyRzbGljZSc6IFtyZWxhdGlvbi5za2lwLCByZWxhdGlvbi50YWtlXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb24ucmVsYXRpb25GaWVsZF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJyRzbGljZSc6IHJlbGF0aW9uLnRha2VcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVsYXRpb24udGFrZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJlbGF0aW9uLnNraXAgPSBudWxsO1xyXG4gICAgICAgICAgICByZWxhdGlvbi5tb3ZlZFNraXBUYWtlQXNTbGljZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgZmllbGQgdG8gcGFyZW50IHJlbGF0aW9uIGZpZWxkcyBleHByZXNzaW9uLiBGb3IgZXhhbXBsZSBpZiB0aGUgcmVsYXRpb24gZmllbGQgaXMgZXhjbHVkZWQgZnJvbSB0aGUgbWFzdGVyIHJlcXVlc3QuXHJcbiAqIEBwYXJhbSBmaWVsZHNFeHByZXNzaW9uIC0gRmllbGRzIGV4cHJlc3Npb24gb2YgdGhlIHBhcmVudCByZWxhdGlvbi5cclxuICogQHBhcmFtIHJlbGF0aW9uRmllbGQgLSBOYW1lIG9mIHRoZSBmaWVsZCB3aGljaCBzaG91bGQgYmUgcmV0dXJuZWQuXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLmFkZEZpZWxkVG9GaWVsZHNFeHByZXNzaW9uID0gZnVuY3Rpb24gKGZpZWxkc0V4cHJlc3Npb24sIHJlbGF0aW9uRmllbGQpIHtcclxuICAgIGlmIChmaWVsZHNFeHByZXNzaW9uID09PSB1bmRlZmluZWQgfHwgT2JqZWN0LmtleXMoZmllbGRzRXhwcmVzc2lvbikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGlzRXhjbHVzaXZlID0gUmVsYXRpb25UcmVlQnVpbGRlci5nZXRJc0ZpZWxkc0V4cHJlc3Npb25FeGNsdXNpdmUoZmllbGRzRXhwcmVzc2lvbik7XHJcblxyXG4gICAgaWYgKGlzRXhjbHVzaXZlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgZGVsZXRlIGZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb25GaWVsZF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb25GaWVsZF0gPSAxO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgaWYgdGhlIGZpZWxkcyBleHByZXNzaW9uIGlzIGV4Y2x1c2l2ZSAoXCJGaWVsZE5hbWVcIiA6IDApXHJcbiAqIEBwYXJhbSBmaWVsZHNFeHByZXNzaW9uIC0gRmllbGRzIGV4cHJlc3Npb24gdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5nZXRJc0ZpZWxkc0V4cHJlc3Npb25FeGNsdXNpdmUgPSBmdW5jdGlvbiAoZmllbGRzRXhwcmVzc2lvbikge1xyXG4gICAgdmFyIGlzRXhjbHVzaXZlO1xyXG4gICAgZm9yICh2YXIgZmllbGROYW1lIGluIGZpZWxkc0V4cHJlc3Npb24pIHtcclxuICAgICAgICBpZiAoZmllbGROYW1lICE9PSBDb25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQgJiYgZmllbGRzRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShmaWVsZE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0V4Y2x1c2l2ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRzRXhwcmVzc2lvbltmaWVsZE5hbWVdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNFeGNsdXNpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkc0V4cHJlc3Npb25bZmllbGROYW1lXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGRzRXhwcmVzc2lvbltmaWVsZE5hbWVdID09PSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXhjbHVzaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpc0V4Y2x1c2l2ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVsYXRpb25UcmVlQnVpbGRlcjtcclxuIiwiLyohXHJcbiAqIGFzeW5jXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYW9sYW4vYXN5bmNcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTAtMjAxNCBDYW9sYW4gTWNNYWhvblxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qanNoaW50IG9uZXZhcjogZmFsc2UsIGluZGVudDo0ICovXHJcbi8qZ2xvYmFsIHNldEltbWVkaWF0ZTogZmFsc2UsIHNldFRpbWVvdXQ6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBhc3luYyA9IHt9O1xyXG5cclxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcclxuICAgIHZhciByb290LCBwcmV2aW91c19hc3luYztcclxuXHJcbiAgICByb290ID0gdGhpcztcclxuICAgIGlmIChyb290ICE9IG51bGwpIHtcclxuICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xyXG4gICAgICAgIHJldHVybiBhc3luYztcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gb25seV9vbmNlKGZuKSB7XHJcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcclxuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm4uYXBwbHkocm9vdCwgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vLyBjcm9zcy1icm93c2VyIGNvbXBhdGlibGl0eSBmdW5jdGlvbnMgLy8vL1xyXG5cclxuICAgIHZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2VhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xyXG4gICAgICAgIGlmIChhcnIuZm9yRWFjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyLmZvckVhY2goaXRlcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbaV0sIGksIGFycik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKGFyci5tYXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAoaXRlcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yKHgsIGksIGEpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWVtbykge1xyXG4gICAgICAgIGlmIChhcnIucmVkdWNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xyXG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xyXG5cclxuICAgIC8vLy8gbmV4dFRpY2sgaW1wbGVtZW50YXRpb24gd2l0aCBicm93c2VyLWNvbXBhdGlibGUgZmFsbGJhY2sgLy8vL1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhKHByb2Nlc3MubmV4dFRpY2spKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcclxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIG9ubHlfb25jZShkb25lKSApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XHJcbiAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBhc3luYy5mb3JFYWNoID0gYXN5bmMuZWFjaDtcclxuXHJcbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xyXG4gICAgICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbY29tcGxldGVkXSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpdGVyYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgYXN5bmMuZm9yRWFjaFNlcmllcyA9IGFzeW5jLmVhY2hTZXJpZXM7XHJcblxyXG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBmbiA9IF9lYWNoTGltaXQobGltaXQpO1xyXG4gICAgICAgIGZuLmFwcGx5KG51bGwsIFthcnIsIGl0ZXJhdG9yLCBjYWxsYmFja10pO1xyXG4gICAgfTtcclxuICAgIGFzeW5jLmZvckVhY2hMaW1pdCA9IGFzeW5jLmVhY2hMaW1pdDtcclxuXHJcbiAgICB2YXIgX2VhY2hMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgIGlmICghYXJyLmxlbmd0aCB8fCBsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XHJcblxyXG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgc3RhcnRlZCA8IGFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycltzdGFydGVkIC0gMV0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB2YXIgZG9QYXJhbGxlbCA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgdmFyIGRvUGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0LCBmbikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFtfZWFjaExpbWl0KGxpbWl0KV0uY29uY2F0KGFyZ3MpKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBkb1NlcmllcyA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoU2VyaWVzXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB2YXIgX2FzeW5jTWFwID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3guaW5kZXhdID0gdjtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XHJcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xyXG4gICAgYXN5bmMubWFwTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIF9tYXBMaW1pdChsaW1pdCkoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX21hcExpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcclxuICAgICAgICByZXR1cm4gZG9QYXJhbGxlbExpbWl0KGxpbWl0LCBfYXN5bmNNYXApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XHJcbiAgICAvLyB3b3JrIGluIG1hbnkgc2l0dWF0aW9ucy5cclxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgeCwgZnVuY3Rpb24gKGVyciwgdikge1xyXG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gaW5qZWN0IGFsaWFzXHJcbiAgICBhc3luYy5pbmplY3QgPSBhc3luYy5yZWR1Y2U7XHJcbiAgICAvLyBmb2xkbCBhbGlhc1xyXG4gICAgYXN5bmMuZm9sZGwgPSBhc3luYy5yZWR1Y2U7XHJcblxyXG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xyXG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICAvLyBmb2xkciBhbGlhc1xyXG4gICAgYXN5bmMuZm9sZHIgPSBhc3luYy5yZWR1Y2VSaWdodDtcclxuXHJcbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XHJcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBhc3luYy5maWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpO1xyXG4gICAgYXN5bmMuZmlsdGVyU2VyaWVzID0gZG9TZXJpZXMoX2ZpbHRlcik7XHJcbiAgICAvLyBzZWxlY3QgYWxpYXNcclxuICAgIGFzeW5jLnNlbGVjdCA9IGFzeW5jLmZpbHRlcjtcclxuICAgIGFzeW5jLnNlbGVjdFNlcmllcyA9IGFzeW5jLmZpbHRlclNlcmllcztcclxuXHJcbiAgICB2YXIgX3JlamVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xyXG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcclxuICAgIGFzeW5jLnJlamVjdFNlcmllcyA9IGRvU2VyaWVzKF9yZWplY3QpO1xyXG5cclxuICAgIHZhciBfZGV0ZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xyXG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh4KTtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBhc3luYy5kZXRlY3QgPSBkb1BhcmFsbGVsKF9kZXRlY3QpO1xyXG4gICAgYXN5bmMuZGV0ZWN0U2VyaWVzID0gZG9TZXJpZXMoX2RldGVjdCk7XHJcblxyXG4gICAgYXN5bmMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XHJcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gYW55IGFsaWFzXHJcbiAgICBhc3luYy5hbnkgPSBhc3luYy5zb21lO1xyXG5cclxuICAgIGFzeW5jLmV2ZXJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcclxuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gYWxsIGFsaWFzXHJcbiAgICBhc3luYy5hbGwgPSBhc3luYy5ldmVyeTtcclxuXHJcbiAgICBhc3luYy5zb3J0QnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKGVyciwgY3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChmbiksIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xyXG4gICAgICAgIHZhciByZW1haW5pbmdUYXNrcyA9IGtleXMubGVuZ3RoXHJcbiAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XHJcblxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB2YXIgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoZm4pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdGFza0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZW1haW5pbmdUYXNrcy0tXHJcbiAgICAgICAgICAgIF9lYWNoKGxpc3RlbmVycy5zbGljZSgwKSwgZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgICAgICBmbigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBhZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBmaW5hbCBjYWxsYmFjayBmcm9tIGNhbGxpbmcgaXRzZWxmIGlmIGl0IGVycm9yc1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGVDYWxsYmFjayhudWxsLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfZWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICB2YXIgdGFzayA9IF9pc0FycmF5KHRhc2tzW2tdKSA/IHRhc2tzW2tdOiBbdGFza3Nba11dO1xyXG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBfZWFjaChfa2V5cyhyZXN1bHRzKSwgZnVuY3Rpb24ocmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHJlc3VsdHNbcmtleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba10gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3Vic2VxdWVudCBlcnJvcnMgaGl0dGluZyBjYWxsYmFjayBtdWx0aXBsZSB0aW1lc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcclxuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUodGFza0NvbXBsZXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHJlcXVpcmVzID0gdGFzay5zbGljZSgwLCBNYXRoLmFicyh0YXNrLmxlbmd0aCAtIDEpKSB8fCBbXTtcclxuICAgICAgICAgICAgdmFyIHJlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhICYmIHJlc3VsdHMuaGFzT3duUHJvcGVydHkoeCkpO1xyXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkgJiYgIXJlc3VsdHMuaGFzT3duUHJvcGVydHkoayk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMucmV0cnkgPSBmdW5jdGlvbih0aW1lcywgdGFzaywgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7XHJcbiAgICAgICAgdmFyIGF0dGVtcHRzID0gW107XHJcbiAgICAgICAgLy8gVXNlIGRlZmF1bHRzIGlmIHRpbWVzIG5vdCBwYXNzZWRcclxuICAgICAgICBpZiAodHlwZW9mIHRpbWVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGFzaztcclxuICAgICAgICAgICAgdGFzayA9IHRpbWVzO1xyXG4gICAgICAgICAgICB0aW1lcyA9IERFRkFVTFRfVElNRVM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aW1lcyBpcyBhIG51bWJlclxyXG4gICAgICAgIHRpbWVzID0gcGFyc2VJbnQodGltZXMsIDEwKSB8fCBERUZBVUxUX1RJTUVTO1xyXG4gICAgICAgIHZhciB3cmFwcGVkVGFzayA9IGZ1bmN0aW9uKHdyYXBwZWRDYWxsYmFjaywgd3JhcHBlZFJlc3VsdHMpIHtcclxuICAgICAgICAgICAgdmFyIHJldHJ5QXR0ZW1wdCA9IGZ1bmN0aW9uKHRhc2ssIGZpbmFsQXR0ZW1wdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllc0NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzayhmdW5jdGlvbihlcnIsIHJlc3VsdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NhbGxiYWNrKCFlcnIgfHwgZmluYWxBdHRlbXB0LCB7ZXJyOiBlcnIsIHJlc3VsdDogcmVzdWx0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgd3JhcHBlZFJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2hpbGUgKHRpbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRlbXB0cy5wdXNoKHJldHJ5QXR0ZW1wdCh0YXNrLCAhKHRpbWVzLT0xKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzeW5jLnNlcmllcyhhdHRlbXB0cywgZnVuY3Rpb24oZG9uZSwgZGF0YSl7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgKHdyYXBwZWRDYWxsYmFjayB8fCBjYWxsYmFjaykoZGF0YS5lcnIsIGRhdGEucmVzdWx0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGEgY2FsbGJhY2sgaXMgcGFzc2VkLCBydW4gdGhpcyBhcyBhIGNvbnRyb2xsIGZsb3dcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyB3cmFwcGVkVGFzaygpIDogd3JhcHBlZFRhc2tcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgaWYgKCFfaXNBcnJheSh0YXNrcykpIHtcclxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xyXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwSXRlcmF0b3IobmV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX3BhcmFsbGVsID0gZnVuY3Rpb24oZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcclxuICAgICAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XHJcbiAgICAgICAgICAgIGVhY2hmbi5lYWNoKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMucGFyYWxsZWwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBhc3luYy5tYXAsIGVhY2g6IGFzeW5jLmVhY2ggfSwgdGFza3MsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcclxuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IF9tYXBMaW1pdChsaW1pdCksIGVhY2g6IF9lYWNoTGltaXQobGltaXQpIH0sIHRhc2tzLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnNlcmllcyA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcclxuICAgICAgICAgICAgYXN5bmMubWFwU2VyaWVzKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcclxuICAgICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XHJcbiAgICAgICAgdmFyIG1ha2VDYWxsYmFjayA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFza3NbaW5kZXhdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBmbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBtYWtlQ2FsbGJhY2soMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLmFwcGx5ID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShcclxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9jb25jYXQgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGZuLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciByID0gW107XHJcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNiKSB7XHJcbiAgICAgICAgICAgIGZuKHgsIGZ1bmN0aW9uIChlcnIsIHkpIHtcclxuICAgICAgICAgICAgICAgIHIgPSByLmNvbmNhdCh5IHx8IFtdKTtcclxuICAgICAgICAgICAgICAgIGNiKGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xyXG4gICAgYXN5bmMuY29uY2F0U2VyaWVzID0gZG9TZXJpZXMoX2NvbmNhdCk7XHJcblxyXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0ZXN0KCkpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXN5bmMud2hpbHN0KHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICBpZiAodGVzdC5hcHBseShudWxsLCBhcmdzKSkge1xyXG4gICAgICAgICAgICAgICAgYXN5bmMuZG9XaGlsc3QoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMudW50aWwgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCF0ZXN0KCkpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXN5bmMudW50aWwodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcclxuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgaWYgKCF0ZXN0LmFwcGx5KG51bGwsIGFyZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICBhc3luYy5kb1VudGlsKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcclxuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xyXG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xyXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xyXG4gICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXHJcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcclxuICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHEudGFza3MucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHdvcmtlcnMgPSAwO1xyXG4gICAgICAgIHZhciBxID0ge1xyXG4gICAgICAgICAgICB0YXNrczogW10sXHJcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcclxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxyXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcclxuICAgICAgICAgICAgZHJhaW46IG51bGwsXHJcbiAgICAgICAgICAgIHN0YXJ0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXVzZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBxLmRyYWluID0gbnVsbDtcclxuICAgICAgICAgICAgICBxLnRhc2tzID0gW107XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXEucGF1c2VkICYmIHdvcmtlcnMgPCBxLmNvbmN1cnJlbmN5ICYmIHEudGFza3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLnRhc2tzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuZW1wdHkgJiYgcS50YXNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2suY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbiAmJiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBjYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VycztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaWRsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSB0cnVlKSB7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhc3luYy5wcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiBfY29tcGFyZVRhc2tzKGEsIGIpe1xyXG4gICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gX2JpbmFyeVNlYXJjaChzZXF1ZW5jZSwgaXRlbSwgY29tcGFyZSkge1xyXG4gICAgICAgICAgdmFyIGJlZyA9IC0xLFxyXG4gICAgICAgICAgICAgIGVuZCA9IHNlcXVlbmNlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICB3aGlsZSAoYmVnIDwgZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBtaWQgPSBiZWcgKyAoKGVuZCAtIGJlZyArIDEpID4+PiAxKTtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmUoaXRlbSwgc2VxdWVuY2VbbWlkXSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgIGJlZyA9IG1pZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gYmVnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xyXG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xyXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xyXG4gICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXHJcbiAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcclxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoX2JpbmFyeVNlYXJjaChxLnRhc2tzLCBpdGVtLCBfY29tcGFyZVRhc2tzKSArIDEsIDAsIGl0ZW0pO1xyXG5cclxuICAgICAgICAgICAgICBpZiAocS5zYXR1cmF0ZWQgJiYgcS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcclxuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxyXG4gICAgICAgIHZhciBxID0gYXN5bmMucXVldWUod29ya2VyLCBjb25jdXJyZW5jeSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHlcclxuICAgICAgICBxLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjayk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvblxyXG4gICAgICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcclxuICAgICAgICB2YXIgd29ya2luZyAgICAgPSBmYWxzZSxcclxuICAgICAgICAgICAgdGFza3MgICAgICAgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIGNhcmdvID0ge1xyXG4gICAgICAgICAgICB0YXNrczogdGFza3MsXHJcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXHJcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcclxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXHJcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxyXG4gICAgICAgICAgICBkcmFpbmVkOiB0cnVlLFxyXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZ28uZHJhaW5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXJnby5zYXR1cmF0ZWQgJiYgdGFza3MubGVuZ3RoID09PSBwYXlsb2FkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmdvLnNhdHVyYXRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGNhcmdvLnByb2Nlc3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihjYXJnby5kcmFpbiAmJiAhY2FyZ28uZHJhaW5lZCkgY2FyZ28uZHJhaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXJnby5kcmFpbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gdHlwZW9mIHBheWxvYWQgPT09ICdudW1iZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhc2tzLnNwbGljZSgwLCBwYXlsb2FkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXNrcy5zcGxpY2UoMCwgdGFza3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZHMgPSBfbWFwKHRzLCBmdW5jdGlvbiAodGFzaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihjYXJnby5lbXB0eSkgY2FyZ28uZW1wdHkoKTtcclxuICAgICAgICAgICAgICAgIHdvcmtpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgd29ya2VyKGRzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgICAgICAgICBfZWFjaCh0cywgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2tzLmxlbmd0aDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjYXJnbztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9jb25zb2xlX2ZuID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZVtuYW1lXSh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XSkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xyXG4gICAgYXN5bmMuZGlyID0gX2NvbnNvbGVfZm4oJ2RpcicpO1xyXG4gICAgLyphc3luYy5pbmZvID0gX2NvbnNvbGVfZm4oJ2luZm8nKTtcclxuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xyXG4gICAgYXN5bmMuZXJyb3IgPSBfY29uc29sZV9mbignZXJyb3InKTsqL1xyXG5cclxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xyXG4gICAgICAgIHZhciBtZW1vID0ge307XHJcbiAgICAgICAgdmFyIHF1ZXVlcyA9IHt9O1xyXG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIG1lbW8pIHtcclxuICAgICAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XHJcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBxW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XHJcbiAgICAgICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuO1xyXG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMudW5tZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy50aW1lcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXN5bmMubWFwKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnRpbWVzU2VyaWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuc2VxID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xyXG4gICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XHJcbiAgICAgICAgICAgIGFzeW5jLnJlZHVjZShmbnMsIGFyZ3MsIGZ1bmN0aW9uIChuZXdhcmdzLCBmbiwgY2IpIHtcclxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfV0pKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5jb21wb3NlID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xyXG4gICAgICByZXR1cm4gYXN5bmMuc2VxLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfYXBwbHlFYWNoID0gZnVuY3Rpb24gKGVhY2hmbiwgZm5zIC8qYXJncy4uLiovKSB7XHJcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHtcclxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FsbGJhY2spO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdvO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBhc3luYy5hcHBseUVhY2ggPSBkb1BhcmFsbGVsKF9hcHBseUVhY2gpO1xyXG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gZG9TZXJpZXMoX2FwcGx5RWFjaCk7XHJcblxyXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcclxuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmbihuZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBOb2RlLmpzXHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xyXG4gICAgfVxyXG4gICAgLy8gQU1EIC8gUmVxdWlyZUpTXHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3luYztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIGluY2x1ZGVkIGRpcmVjdGx5IHZpYSA8c2NyaXB0PiB0YWdcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcclxuICAgIH1cclxuXHJcbn0oKSk7XHJcbiIsInZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIEF1dG9RdWV1ZShtYXhDb25jdXJyZW50VGFza3MpIHtcclxuICAgICAgICBtYXhDb25jdXJyZW50VGFza3MgPSBwYXJzZUludChtYXhDb25jdXJyZW50VGFza3MgfHwgY29uc3RhbnRzLk1heENvbmN1cnJlbnREb3dubG9hZFRhc2tzKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTmFOKG1heENvbmN1cnJlbnRUYXNrcykgfHwgbWF4Q29uY3VycmVudFRhc2tzIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtYXhDb25jdXJyZW50VGFza3MgbXVzdCBiZSBhIG51bWJlciBsYXJnZXIgdGhhbiAwJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1heENvbmN1cnJlbnRUYXNrcyA9IG1heENvbmN1cnJlbnRUYXNrcztcclxuICAgICAgICB0aGlzLnJ1bm5pbmdUYXNrc0NvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnRhc2tzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgQXV0b1F1ZXVlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXNrXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdGFza1N1Y2Nlc3NcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXNrRXJyb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBlbnF1ZXVlOiBmdW5jdGlvbiAodGFzaywgdGFza1N1Y2Nlc3MsIHRhc2tFcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbih0YXNrU3VjY2VzcykgfHwgIV8uaXNGdW5jdGlvbih0YXNrRXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcigndGFza1N1Y2Nlc3MgYW5kIHRhc2tFcnJvciBmdW5jdGlvbnMgbXVzdCBiZSBwcm92aWRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRhc2tzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdGFzazogdGFzayxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0YXNrU3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiB0YXNrRXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9ydW5OZXh0KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3J1bk5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYucnVubmluZ1Rhc2tzQ291bnQgPT09IHNlbGYubWF4Q29uY3VycmVudFRhc2tzIHx8ICFzZWxmLnRhc2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLnJ1bm5pbmdUYXNrc0NvdW50Kys7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV4dFRhc2sgPSB0aGlzLnRhc2tzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHZhciB0YXNrID0gbmV4dFRhc2sudGFzaztcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXh0VGFzay5hcmdzO1xyXG4gICAgICAgICAgICB2YXIgdGFza1N1Y2Nlc3MgPSBuZXh0VGFzay5zdWNjZXNzO1xyXG4gICAgICAgICAgICB2YXIgdGFza0Vycm9yID0gbmV4dFRhc2suZXJyb3I7XHJcblxyXG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoZnVuY3Rpb24gZXhlY3V0ZWRDYWxsYmFjayhlcnIpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYucnVubmluZ1Rhc2tzQ291bnQtLTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFza0Vycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2tTdWNjZXNzLmFwcGx5KG51bGwsIFtdLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuX3J1bk5leHQoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0YXNrLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEF1dG9RdWV1ZTtcclxufSgpKTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xyXG5cclxudmFyIGFwcGx5ID0gZnVuY3Rpb24gYXBwbHkob2JqKSB7XHJcbiAgICBvYmouX2VtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gICAgb2JqLl9lbWl0dGVyUHJveHkgPSBmdW5jdGlvbiAoZXZlbnQsIGFyZ3MpIHtcclxuICAgICAgICBvYmouX2VtaXR0ZXJbZXZlbnRdLmFwcGx5KG9iai5fZW1pdHRlciwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG9iai5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvYmouX2VtaXR0ZXJQcm94eSgnYWRkTGlzdGVuZXInLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBvYmoub24gPSBvYmouYWRkTGlzdGVuZXI7XHJcblxyXG4gICAgb2JqLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG9iai5fZW1pdHRlclByb3h5KCdyZW1vdmVMaXN0ZW5lcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG9iai5vZmYgPSBvYmoucmVtb3ZlTGlzdGVuZXI7XHJcblxyXG4gICAgb2JqLm9uY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2JqLl9lbWl0dGVyUHJveHkoJ29uY2UnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBvYmoucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG9iai5fZW1pdHRlclByb3h5KCdyZW1vdmVBbGxMaXN0ZW5lcnMnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgYXBwbHk6IGFwcGx5XHJcbn07IiwidmFyIFNldHVwID0gcmVxdWlyZSgnLi9TZXR1cCcpO1xyXG52YXIgRGF0YSA9IHJlcXVpcmUoJy4vdHlwZXMvRGF0YScpO1xyXG52YXIgdXNlcnNNb2R1bGUgPSByZXF1aXJlKCcuL3R5cGVzL1VzZXJzJyk7XHJcbnZhciBmaWxlc01vZHVsZSA9IHJlcXVpcmUoJy4vdHlwZXMvRmlsZXMnKTtcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxudmFyIGJ1aWxkQXV0aEhlYWRlciA9IHV0aWxzLmJ1aWxkQXV0aEhlYWRlcjtcclxudmFyIFB1c2ggPSByZXF1aXJlKCcuL1B1c2gnKTtcclxudmFyIEF1dGhlbnRpY2F0aW9uID0gcmVxdWlyZSgnLi9hdXRoL0F1dGhlbnRpY2F0aW9uJyk7XHJcbnZhciBvZmZsaW5lTW9kdWxlID0gcmVxdWlyZSgnLi9vZmZsaW5lL29mZmxpbmUnKTtcclxudmFyIGNhY2hpbmcgPSByZXF1aXJlKCcuL2NhY2hpbmcvY2FjaGluZycpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vUmVxdWVzdCcpO1xyXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgRXZlcmxpdmVFcnJvcnMgPSByZXF1aXJlKCcuL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9ycztcclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvaGVscGVycycpO1xyXG52YXIgRXZlbnRFbWl0dGVyUHJveHkgPSByZXF1aXJlKCcuL0V2ZW50RW1pdHRlclByb3h5Jyk7XHJcblxyXG4vLyBSZWdpc3RlcmluZyBtaXhpbnM6XHJcbnZhciBtaXhpbnMgPSByZXF1aXJlKCcuL21peGlucy9taXhpbnMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvLyBUaGUgY29uc3RydWN0b3Igb2YgRXZlcmxpdmUgaW5zdGFuY2VzLlxyXG4gICAgLy8gVGhlIGVudHJ5IHBvaW50IGZvciB0aGUgU0RLLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEV2ZXJsaXZlXHJcbiAgICAgKiBAY2xhc3NkZXNjIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUge3tzaXRlLmJzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNESy4gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHRoZSBTREsuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBTZXR1cCBvYmplY3QuIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gcGFzcyBhIHN0cmluZyByZXByZXNlbnRpbmcgeW91ciBBUEkga2V5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gWW91ciBBUEkga2V5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVybD0vL2FwaS5ldmVybGl2ZS5jb20vdjEvXSAtIFRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IFVSTC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b2tlbl0gLSBBbiBhdXRoZW50aWNhdGlvbiB0b2tlbi4gVGhlIGluc3RhbmNlIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBwcmV2aW91c2x5IG9idGFpbmVkIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRva2VuVHlwZT1iZWFyZXJdIC0gVGhlIHR5cGUgb2YgdGhlIHRva2VuIHRoYXQgaXMgdXNlZCBmb3IgYXV0aGVudGljYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2NoZW1lPWh0dHBdIC0gVGhlIFVSSSBzY2hlbWUgdXNlZCB0byBtYWtlIHJlcXVlc3RzLiBTdXBwb3J0ZWQgdmFsdWVzOiBodHRwLCBodHRwc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lT2JqZWN0cz1mYWxzZV0gLSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIFNESyB3aWxsIHBhcnNlIG9ubHkgY29tcGxldGUgZGF0ZSBzdHJpbmdzIChhY2NvcmRpbmcgdG8gdGhlIElTTyA4NjAxIHN0YW5kYXJkKS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW11bGF0b3JNb2RlPWZhbHNlXSAtIFNldCB0aGlzIG9wdGlvbiB0byB0cnVlIHRvIHNldCB0aGUgU0RLIGluIGVtdWxhdG9yIG1vZGUuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9ucy5vZmZsaW5lXSAtIFNldCB0aGlzIG9wdGlvbiB0byB0cnVlIHRvIHVzZSB0aGUgZGVmYXVsdCBvZmZsaW5lIHNldHRpbmdzLlxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub2ZmbGluZS5lbmFibGVkPWZhbHNlXSAtIFdoZW4gdXNpbmcgYW4gb2JqZWN0IHRvIGluaXRpYWxpemUgT2ZmbGluZSBTdXBwb3J0IHdpdGggbm9uLWRlZmF1bHQgc2V0dGluZ3MsIHNldCB0aGlzIG9wdGlvbiB0byBlbmFibGUgb3IgZGlzYWJsZSBPZmZsaW5lIFN1cHBvcnQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm9mZmxpbmUuaXNPbmxpbmU9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBzdG9yYWdlIGlzIGluIG9ubGluZSBtb2RlIGluaXRpYWxseS5cclxuICAgICAqIEBwYXJhbSB7Q29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3l8ZnVuY3Rpb259IFtvcHRpb25zLm9mZmxpbmUuY29uZmxpY3RzLnN0cmF0ZWd5PUNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LkNsaWVudFdpbnNdIC0gQSBjb25zdGFudCBzcGVjaWZ5aW5nIHRoZSBjb25mbGljdCByZXNvbHV0aW9uIHN0cmF0ZWd5IG9yIGEgZnVuY3Rpb24gdXNlZCB0byByZXNvbHZlIHRoZSBjb25mbGljdHMuXHJcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VQcm92aWRlcnxvYmplY3R9IFtvcHRpb25zLm9mZmxpbmUuc3RvcmFnZS5wcm92aWRlcj1TdG9yYWdlUHJvdmlkZXIuTG9jYWxTdG9yYWdlXSAtIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHNldHRpbmdzIGZvciB0aGUgb2ZmbGluZSBzdG9yYWdlIHByb3ZpZGVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9mZmxpbmUuc3RvcmFnZS5zdG9yYWdlUGF0aD1lbF9zdG9yZV0gLSBBIHJlbGF0aXZlIHBhdGggc3BlY2lmeWluZyB3aGVyZSB0aGUgZmlsZXMgd2lsbCBiZSBzYXZlZCBpZiBmaWxlIHN5c3RlbSBpcyB1c2VkIGZvciBwZXJzaXN0ZW5jZSBmb3IgaXRlbSBtZXRhZGF0YS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5vZmZsaW5lLnN0b3JhZ2UucmVxdWVzdGVkUXVvdGE9MTA0ODU3NjBdIC0gSG93IG11Y2ggbWVtb3J5IChpbiBieXRlcykgdG8gYmUgcmVxdWVzdGVkIHdoZW4gdXNpbmcgdGhlIGZpbGUgc3lzdGVtIGZvciBwZXJzaXN0ZW5jZS4gVGhpcyBvcHRpb24gaXMgb25seSB2YWxpZCBmb3IgQ2hyb21lIGFzIHRoZSBvdGhlciBwbGF0Zm9ybXMgdXNlIGFsbCB0aGUgYXZhaWxhYmxlIHNwYWNlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9mZmxpbmUuZW5jcnlwdGlvbi5rZXldIC0gQSBrZXkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZW5jcnlwdCB0aGUgZGF0YSBzdG9yZWQgb2ZmbGluZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vZmZsaW5lLmZpbGVzLnN0b3JhZ2VQYXRoPWVsX2ZpbGVfc3RvcmVdIC0gQSByZWxhdGl2ZSBwYXRoIHNwZWNpZnlpbmcgd2hlcmUgdGhlIGZpbGVzIHdpbGwgYmUgc2F2ZWQgaWYgZmlsZSBzeXN0ZW0gaXMgdXNlZCBmb3IgcGVyc2lzdGVuY2Ugb2YgZmlsZXMgaW4gb2ZmbGluZSBtb2RlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9mZmxpbmUuZmlsZXMubWV0YVBhdGg9ZWxfZmlsZV9tYXBwaW5nXSAtIEEgcmVsYXRpdmUgcGF0aCBzcGVjaWZ5aW5nIHdoZXJlIHRoZSBtZXRhZGF0YSBmaWxlIHdpbGwgYmUgc2F2ZWQgaWYgZmlsZSBzeXN0ZW0gaXMgdXNlZCBmb3IgcGVyc2lzdGVuY2Ugb2YgZmlsZXMgaW4gb2ZmbGluZSBtb2RlLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnMub2ZmbGluZS5maWxlc10gLSBTZXQgdGhpcyBvcHRpb24gdG8gdHJ1ZSB0byBlbmFibGUgc3VwcG9ydCBmb3IgZmlsZXMgaW4gb2ZmbGluZSBtb2RlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm9mZmxpbmUuZmlsZXMubWF4Q29uY3VycmVudERvd25sb2Fkc10gLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgZmlsZXMgdGhhdCBjYW4gYmUgZG93bmxvYWRlZCBzaW11bHRhbmVvdXNseS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0aGVudGljYXRpb24ucGVyc2lzdD1mYWxzZV0gLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCB1c2VyJ3MgYXV0aGVudGljYXRpb24gd2lsbCBiZSBwZXJzaXN0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5hdXRoZW50aWNhdGlvbi5vbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWRdIC0gSW52b2tlZCB3aGVuIHRoZSB1c2VyJ3MgY3JlZGVudGlhbHMgaGF2ZSBleHBpcmVkLiBBbGxvd2luZyB5b3UgdG8gcGVyZm9ybSBjdXN0b20gbG9naWMuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVscGVyc10gLSBBbiBvYmplY3QgaG9sZGluZyBvcHRpb25zIGZvciBhbGwgRXZlcmxpdmUgaGVscGVyIGNvbXBvbmVudHMuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVscGVycy5odG1sXSAtIEhUTUwgSGVscGVyIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGVscGVycy5odG1sLnByb2Nlc3NPbkxvYWQ9ZmFsc2VdIC0gV2hldGhlciB0byBwcm9jZXNzIGFsbCBIVE1MIGVsZW1lbnRzIHdoZW4gdGhlIHdpbmRvdyBsb2Fkcy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGVscGVycy5odG1sLnByb2Nlc3NPblJlc2l6ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHByb2Nlc3MgYWxsIEhUTUwgZWxlbWVudHMgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXMuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaGVscGVycy5odG1sLmxvYWRpbmdJbWFnZVVybF0gLSBUaGUgaW1hZ2UgdG8gYmUgZGlzcGxheWVkIHdoaWxlIHRoZSBvcmlnaW5hbCBpbWFnZSBpcyBiZWluZyBwcm9jZXNzZWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaGVscGVycy5odG1sLmVycm9ySW1hZ2VVcmxdIC0gVGhlIGltYWdlIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBvcmlnaW5hbCBpbWFnZSBwcm9jZXNzaW5nIGZhaWxzLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlbHBlcnMuaHRtbC5hdHRyaWJ1dGVzXSAtIEhUTUwgSGVscGVyIGF0dHJpYnV0ZXMgY29uZmlndXJhdGlvbiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVscGVycy5odG1sLmF0dHJpYnV0ZXMubG9hZGluZ0ltYWdlPWRhdGEtbG9hZGluZy1pbWFnZV0gLSBBIGN1c3RvbSBuYW1lIGZvciB0aGUgYXR0cmlidXRlIHRvIGJlIHVzZWQgdG8gc2V0IGEgbG9hZGluZyBpbWFnZS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWxwZXJzLmh0bWwuYXR0cmlidXRlcy5lcnJvckltYWdlPWRhdGEtZXJyb3ItaW1hZ2VdIC0gQSBjdXN0b20gbmFtZSBmb3IgdGhlIGF0dHJpYnV0ZSB0byBiZSB1c2VkIHRvIHNldCBhbiBlcnJvciBpbWFnZS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWxwZXJzLmh0bWwuYXR0cmlidXRlcy5kcGk9ZGF0YS1kcGldIC0gQSBjdXN0b20gbmFtZSBmb3IgdGhlIGF0dHJpYnV0ZSB0byBiZSB1c2VkIHRvIHNwZWNpZnkgRFBJIHNldHRpbmdzLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlbHBlcnMuaHRtbC5hdHRyaWJ1dGVzLmltYWdlU291cmNlPWRhdGEtc3JjXSAtIEEgY3VzdG9tIG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUgdG8gYmUgdXNlZCB0byBzZXQgdGhlIGltYWdlIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWxwZXJzLmh0bWwuYXR0cmlidXRlcy5maWxlU291cmNlPWRhdGEtaHJlZl0gLSBBIGN1c3RvbSBuYW1lIGZvciB0aGUgYXR0cmlidXRlIHRvIGJlIHVzZWQgdG8gc2V0IHRoZSBhbmNob3Igc291cmNlLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlbHBlcnMuaHRtbC5hdHRyaWJ1dGVzLmVuYWJsZU9mZmxpbmU9ZGF0YS1vZmZsaW5lXSAtIEEgY3VzdG9tIG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUgdG8gYmUgdXNlZCB0byBjb250cm9sIG9mZmxpbmUgcHJvY2Vzc2luZy5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWxwZXJzLmh0bWwuYXR0cmlidXRlcy5lbmFibGVSZXNwb25zaXZlPWRhdGEtcmVzcG9uc2l2ZV0gLSBBIGN1c3RvbSBuYW1lIGZvciB0aGUgYXR0cmlidXRlIHRvIGJlIHVzZWQgdG8gY29udHJvbCBSZXNwb25zaXZlIEltYWdlcyBwcm9jZXNzaW5nLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVybGl2ZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc2V0dXAgPSBuZXcgU2V0dXAob3B0aW9ucyk7XHJcbiAgICAgICAgXy5lYWNoKGluaXRpYWxpemF0aW9ucywgZnVuY3Rpb24gKGluaXQpIHtcclxuICAgICAgICAgICAgaW5pdC5mdW5jLmNhbGwoc2VsZiwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChFdmVybGl2ZS4kID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIEV2ZXJsaXZlLiQgPSBzZWxmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRXZlbnRFbWl0dGVyUHJveHkuYXBwbHkodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBTREsuXHJcbiAgICAgKiBAbWV0aG9kIGFkZExpc3RlbmVyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB3aGljaCB0byBzdWJzY3JpYmUuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudExpc3RlbmVyIEFuIGV2ZW50IGxpc3RlbmVyIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uY2UgdGhlIGV2ZW50IGlzIHJhaXNlZC5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgU0RLLlxyXG4gICAgICogQG1ldGhvZCBvblxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gd2hpY2ggdG8gc3Vic2NyaWJlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRMaXN0ZW5lciBBbiBldmVudCBsaXN0ZW5lciB3aGljaCB3aWxsIGJlIGNhbGxlZCBvbmNlIHRoZSBldmVudCBpcyByYWlzZWQuXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gU0RLIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVMaXN0ZW5lclxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIHN0b3AgbGlzdGVuaW5nLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRMaXN0ZW5lciBUaGUgZXZlbnQgbGlzdGVuZXIgdG8gcmVtb3ZlLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIFNESyBldmVudCBsaXN0ZW5lci5cclxuICAgICAqIEBtZXRob2Qgb2ZmXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudExpc3RlbmVyXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIFNESyB3aGljaCB3aWxsIGJlIGNhbGxlZCBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBldmVudCBpcyBlbWl0dGVkLlxyXG4gICAgICogQG1ldGhvZCBvbmNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB3aGljaCB0byBzdWJzY3JpYmUuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudExpc3RlbmVyIEFuIGV2ZW50IGxpc3RlbmVyIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uY2UgdGhlIGV2ZW50IGlzIHJhaXNlZC5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgU0RLIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlQWxsTGlzdGVuZXJzXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNESy5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxyXG4gICAgICogQHR5cGUge0V2ZXJsaXZlfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS4kID0gbnVsbDtcclxuICAgIEV2ZXJsaXZlLmlkRmllbGQgPSBjb25zdGFudHMuaWRGaWVsZDtcclxuXHJcblxyXG4gICAgLy8gQW4gYXJyYXkga2VlcGluZyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbnMgY2FsbGVkIGJ5IHRoZSBFdmVybGl2ZSBjb25zdHJ1Y3Rvci5cclxuICAgIC8vIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIHVzZWQgdG8gZXh0ZW5kIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIEV2ZXJsaXZlIGluc3RhbmNlLlxyXG4gICAgdmFyIGluaXRpYWxpemF0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8qKiBBbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgaW52b2tlZCBkdXJpbmcgaW5zdGFudGlhdGlvbiBvZiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb25bXX1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLmluaXRpYWxpemF0aW9ucyA9IGluaXRpYWxpemF0aW9ucztcclxuXHJcbiAgICBFdmVybGl2ZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBFdmVybGl2ZS4kID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZXJsaXZlKG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIERhdGF9IGNsYXNzLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbGxlY3Rpb24gdG8gYmUgdXNlZC5cclxuICAgICAqIEByZXR1cm5zIHtEYXRhfVxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YSh0aGlzLnNldHVwLCBjb2xsZWN0aW9uTmFtZSwgdGhpcy5vZmZsaW5lU3RvcmFnZSwgdGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgVVJMIHRvIHRoZSB7e3NpdGUuYnN9fSBhcHBsaWNhdGlvbiBlbmRwb2ludCB0aGF0IHRoZSBTREsgdXNlcy5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgYnVpbGRVcmxcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZWQgVVJMLlxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuYnVpbGRVcmwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHRoaXMuc2V0dXApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXJzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gKEV2ZXJsaXZlKSBKYXZhU2NyaXB0IFNESyB0byBtYWtlIHJlcXVlc3RzIHRvIHRoZSB7e3NpdGUuYnN9fSBzZXJ2ZXJzLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBdXRob3JpemF0aW9uSGVhZGVycyBUaGUgZ2VuZXJhdGVkIEF1dGhvcml6YXRpb24gaGVhZGVycyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5idWlsZEF1dGhIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkQXV0aEhlYWRlcih0aGlzLnNldHVwKTtcclxuICAgIH07XHJcblxyXG4gICAgRXZlcmxpdmUuZGlzYWJsZVJlcXVlc3RDYWNoZSA9IHV0aWxzLmRpc2FibGVSZXF1ZXN0Q2FjaGU7XHJcblxyXG4gICAgRXZlcmxpdmUuQXV0aFN0YXR1cyA9IGNvbnN0YW50cy5BdXRoU3RhdHVzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGF1dGhJbmZvXHJcbiAgICAgKiBAbmFtZSBhdXRoSW5mb1xyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBzZWUge0BsaW5rIEF1dGhlbnRpY2F0aW9uLmdldEF1dGhlbnRpY2F0aW9uU3RhdHVzfVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0byB0aGUgYXV0aGVudGljYXRpb24gc3RhdHVzLlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gc3RhdHVzIG9mIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBhdXRoSW5mb1xyXG4gICAgICogQG5hbWUgYXV0aEluZm9cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAc2VlIHtAbGluayBBdXRoZW50aWNhdGlvbi5nZXRBdXRoZW50aWNhdGlvblN0YXR1c31cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuYXV0aEluZm8gPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNldHVwID0gc2VsZi5zZXR1cDtcclxuICAgICAgICAgICAgaWYgKHNldHVwLm1hc3RlcktleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogRXZlcmxpdmUuQXV0aFN0YXR1cy5tYXN0ZXJLZXl9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFzZXR1cC50b2tlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogRXZlcmxpdmUuQXV0aFN0YXR1cy51bmF1dGhlbnRpY2F0ZWR9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuYXV0aGVudGljYXRpb24gJiYgc2VsZi5hdXRoZW50aWNhdGlvbi5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0aW5nfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYuVXNlcnNcclxuICAgICAgICAgICAgICAgIC5za2lwQXV0aCh0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmN1cnJlbnRVc2VyKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0ZWQsIHVzZXI6IHJlcy5yZXN1bHR9KTtcclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdXRoZW50aWNhdGlvbiAmJiBzZWxmLmF1dGhlbnRpY2F0aW9uLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogRXZlcmxpdmUuQXV0aFN0YXR1cy5hdXRoZW50aWNhdGluZ30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmludmFsaWRSZXF1ZXN0LmNvZGUgfHwgZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmV4cGlyZWRUb2tlbi5jb2RlKSB7IC8vIGludmFsaWQgcmVxdWVzdCwgaS5lLiB0aGUgYWNjZXNzIHRva2VuIGlzIGludmFsaWQgb3IgbWlzc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLmludmFsaWRBdXRoZW50aWNhdGlvbn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIGEgcmVxdWVzdCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS5cclxuICAgICAqIEBtZXRob2QgcmVxdWVzdFxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT2JqZWN0IHVzZWQgdG8gY29uZmlndXJlIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmVuZHBvaW50XSBUaGUgZW5kcG9pbnQgb2YgdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgQVBJIHJlbGF0aXZlIHRvIHRoZSBBUEkga2V5IHNlY3Rpb24uIChGb3IgZXhhbXBsZSwgb3B0aW9ucy5lbmRwb2ludCA9IE15VHlwZSB3aWxsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBNeVR5cGUgdHlwZS4pXHJcbiAgICAgKiBAcGFyYW0ge0h0dHBNZXRob2R9IFtvcHRpb25zLm1ldGhvZF0gSFRUUCByZXF1ZXN0IG1ldGhvZC5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5kYXRhXSBEYXRhIHRvIGJlIHNlbnQgd2l0aCB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnN1Y2Nlc3NdIFN1Y2Nlc3MgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IGZpbmlzaGVzIHN1Y2Nlc3NmdWxseS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVycm9yXSBFcnJvciBjYWxsYmFjayB0byBiZSBjYWxsZWQgaW4gY2FzZSBvZiBhbiBlcnJvci5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0ge1F1ZXJ5fG9iamVjdH0gW29wdGlvbnMuZmlsdGVyXSBUaGlzIGlzIGVpdGhlciBhIHtAbGluayBRdWVyeX0gb3IgYSBbZmlsdGVyXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZXhwcmVzc2lvbi5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0aEhlYWRlcnM9dHJ1ZV0gV2hlbiBzZXQgdG8gZmFsc2UsIG5vIEF1dGhvcml6YXRpb24gaGVhZGVycyB3aWxsIGJlIHNlbnQgd2l0aCB0aGUgcmVxdWVzdC5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gVGhlIHJlcXVlc3QgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHNlbmRgIGZ1bmN0aW9uIHRoYXQgc2VuZHMgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcy5zZXR1cCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHByb3RlY3RPZmZsaW5lRW5hYmxlZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzT2ZmbGluZVN0b3JhZ2VFbmFibGVkKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1lvdSBoYXZlIGluc3RhbnRpYXRlZCB0aGUgU0RLIHdpdGhvdXQgc3VwcG9ydCBmb3Igb2ZmbGluZSBzdG9yYWdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5faXNPZmZsaW5lU3RvcmFnZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9mZmxpbmVTdG9yYWdlT3B0aW9ucyA9IHRoaXMuc2V0dXAub2ZmbGluZVN0b3JhZ2UgfHwgdGhpcy5zZXR1cC5vZmZsaW5lO1xyXG4gICAgICAgIHJldHVybiBvZmZsaW5lU3RvcmFnZU9wdGlvbnMgJiYgb2ZmbGluZVN0b3JhZ2VPcHRpb25zLmVuYWJsZWQgIT09IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIFNESyB0byB3b3JrIGluIG9mZmxpbmUgbW9kZS5cclxuICAgICAqIEBtZXRob2Qgb2ZmbGluZVxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNPZmZsaW5lID0gdHJ1ZV0gQm9vbGVhbiBwYXJhbWV0ZXIgZm9yIHNldHRpbmcgdGhlIFNESyB0byBvbmxpbmUgb3Igb2ZmbGluZSBtb2RlLlxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUub2ZmbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwcm90ZWN0T2ZmbGluZUVuYWJsZWQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgdmFyIGlzT2ZmbGluZTtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpc09mZmxpbmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlzT2ZmbGluZSA9IGFyZ3VtZW50c1swXSA9PSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlLl9zZXRPZmZsaW5lKGlzT2ZmbGluZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgU0RLIHRvIHdvcmsgaW4gb25saW5lIG1vZGUuXHJcbiAgICAgKiBAbWV0aG9kIG9ubGluZVxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNPbmxpbmUgPSB0cnVlXSBCb29sZWFuIHBhcmFtZXRlciBmb3Igc2V0dGluZyB0aGUgU0RLIHRvIG9ubGluZSBvciBvZmZsaW5lIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5vbmxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcHJvdGVjdE9mZmxpbmVFbmFibGVkLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgIHZhciBpc09ubGluZTtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpc09ubGluZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaXNPbmxpbmUgPSBhcmd1bWVudHNbMF0gPT0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vZmZsaW5lU3RvcmFnZS5fc2V0T2ZmbGluZSghaXNPbmxpbmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBTREsgaXMgaW4gb2ZmbGluZSBtb2RlLlxyXG4gICAgICogQG1ldGhvZCBpc09mZmxpbmVcclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIFNESyBpcyBpbiBvZmZsaW5lIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5pc09mZmxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcHJvdGVjdE9mZmxpbmVFbmFibGVkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzT25saW5lKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIFNESyBpcyBpbiBvbmxpbmUgbW9kZS5cclxuICAgICAqIEBtZXRob2QgaXNPbmxpbmVcclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIFNESyBpcyBpbiBvbmxpbmUgbW9kZS5cclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLmlzT25saW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlLmlzT25saW5lKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSBzeW5jaHJvbml6YXRpb24gcHJvY2VkdXJlLiBFbWl0cyB0aGUgJ3N5bmNTdGFydCcgZXZlbnQgd2hlbiBzdGFydGVkIGFuZCB0aGUgJ3N5bmNFbmQnIGV2ZW50IHdoZW4gdGhlIHByb2NlZHVyZSBmaW5pc2hlcy4gJ3N5bmNFbmQnIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb21wbGV0ZWQgc3luYyBvcGVyYXRpb24gdGhhdCB5b3UgY2FuIHVzZSB0byBmaW5kIG91dCBob3cgbWFueSBpdGVtcyB3ZXJlIHN5bmNocm9uaXplZC5cclxuICAgICAqIEBtZXRob2Qgc3luY1xyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwcm90ZWN0T2ZmbGluZUVuYWJsZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5zeW5jLmFwcGx5KHRoaXMub2ZmbGluZVN0b3JhZ2UsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbml0RGVmYXVsdCA9IGZ1bmN0aW9uIGluaXREZWZhdWx0KCkge1xyXG4gICAgICAgIHZhciB1c2VycyA9IHRoaXMuZGF0YSgnVXNlcnMnKTtcclxuICAgICAgICB1c2Vyc01vZHVsZS5hZGRVc2Vyc0Z1bmN0aW9ucyh1c2VycywgdGhpcyk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgICAgICogQHNlZSB7QGxpbmsgRXZlcmxpdmUudXNlcnN9XHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluc3RhbmNlIG9mIHRoZSBbVXNlcnNde0BsaW5rIFVzZXJzfSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHVzZXJzLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1VzZXJzfSBVc2Vyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuVXNlcnMgPSB1c2VycztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluc3RhbmNlIG9mIHRoZSBbVXNlcnNde0BsaW5rIFVzZXJzfSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHVzZXJzLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1VzZXJzfSB1c2Vyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXNlcnMgPSB1c2VycztcclxuXHJcbiAgICAgICAgdmFyIGZpbGVzID0gdGhpcy5kYXRhKCdGaWxlcycpO1xyXG4gICAgICAgIGZpbGVzTW9kdWxlLmFkZEZpbGVzRnVuY3Rpb25zKGZpbGVzKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGV2ZXJsaXZlLmZpbGVzIGluc3RlYWRcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBFdmVybGl2ZS5maWxlc31cclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtGaWxlc117QGxpbmsgRmlsZXN9IGNsYXNzIGZvciB3b3JraW5nIHdpdGggZmlsZXMuXHJcbiAgICAgICAgICogQG1lbWJlciB7RmlsZXN9IEZpbGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5GaWxlcyA9IGZpbGVzO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtGaWxlc117QGxpbmsgRmlsZXN9IGNsYXNzIGZvciB3b3JraW5nIHdpdGggZmlsZXMuXHJcbiAgICAgICAgICogQG1lbWJlciB7RmlsZXN9IGZpbGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWxlcyA9IGZpbGVzO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtQdXNoXXtAbGluayBQdXNofSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHB1c2ggbm90aWZpY2F0aW9ucy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtQdXNofSBwdXNoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wdXNoID0gbmV3IFB1c2godGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbml0QXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiBpbml0QXV0aGVudGljYXRpb24oKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluc3RhbmNlIG9mIHRoZSBbQXV0aGVudGljYXRpb25de0BsaW5rIEF1dGhlbnRpY2F0aW9ufSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHRoZSBhdXRoZW50aWNhdGlvbiBvZiB0aGUgU0RLLlxyXG4gICAgICAgICAqIEBtZW1iZXIge0F1dGhlbnRpY2F0aW9ufSBhdXRoZW50aWNhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRpb24gPSBuZXcgQXV0aGVudGljYXRpb24odGhpcywgdGhpcy5zZXR1cC5hdXRoZW50aWNhdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbml0aWFsaXplSGVscGVycyA9IGZ1bmN0aW9uIGluaXRpYWxpemVIZWxwZXJzKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi5oZWxwZXJzID0ge307XHJcblxyXG4gICAgICAgIF8uZWFjaChoZWxwZXJzLCBmdW5jdGlvbiAoaGVscGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWxwZXJPcHRpb25zID0gb3B0aW9ucy5oZWxwZXJzID8gb3B0aW9ucy5oZWxwZXJzW2hlbHBlci5uYW1lXSA6IG51bGw7XHJcbiAgICAgICAgICAgIHNlbGYuaGVscGVyc1toZWxwZXIubmFtZV0gPSBuZXcgaGVscGVyLmN0b3Ioc2VsZiwgaGVscGVyT3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGluaXRpYWxpemF0aW9ucy5wdXNoKHtuYW1lOiAnY2FjaGluZycsIGZ1bmM6IGNhY2hpbmcuaW5pdENhY2hpbmd9KTtcclxuICAgIGluaXRpYWxpemF0aW9ucy5wdXNoKHtuYW1lOiAnb2ZmbGluZVN0b3JhZ2UnLCBmdW5jOiBvZmZsaW5lTW9kdWxlLmluaXRPZmZsaW5lU3RvcmFnZX0pO1xyXG4gICAgaW5pdGlhbGl6YXRpb25zLnB1c2goe25hbWU6ICdjYWNoZVN0b3JlJywgZnVuYzogY2FjaGluZy5faW5pdFN0b3JlfSk7XHJcbiAgICBpbml0aWFsaXphdGlvbnMucHVzaCh7bmFtZTogJ2RlZmF1bHQnLCBmdW5jOiBpbml0RGVmYXVsdH0pO1xyXG4gICAgaW5pdGlhbGl6YXRpb25zLnB1c2goe25hbWU6ICdhdXRoZW50aWNhdGlvbicsIGZ1bmM6IGluaXRBdXRoZW50aWNhdGlvbn0pO1xyXG4gICAgaW5pdGlhbGl6YXRpb25zLnB1c2goe25hbWU6ICdoZWxwZXJzJywgZnVuYzogaW5pdGlhbGl6ZUhlbHBlcnN9KTtcclxuXHJcbiAgICByZXR1cm4gRXZlcmxpdmU7XHJcbn0oKSk7XHJcbiIsInZhciBFdmVybGl2ZUVycm9ycyA9IHtcclxuICAgIGl0ZW1Ob3RGb3VuZDoge1xyXG4gICAgICAgIGNvZGU6IDgwMSxcclxuICAgICAgICBtZXNzYWdlOiAnSXRlbSBub3QgZm91bmQuJ1xyXG4gICAgfSxcclxuICAgIHN5bmNDb25mbGljdDoge1xyXG4gICAgICAgIGNvZGU6IDEwMDAxLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdBIGNvbmZsaWN0IG9jY3VycmVkIHdoaWxlIHN5bmNpbmcgZGF0YS4nXHJcbiAgICB9LFxyXG4gICAgc3luY0Vycm9yOiB7XHJcbiAgICAgICAgY29kZTogMTAwMDIsXHJcbiAgICAgICAgbWVzc2FnZTogJ1N5bmNocm9uaXphdGlvbiBmYWlsZWQgZm9yIGl0ZW0uJ1xyXG4gICAgfSxcclxuICAgIHN5bmNJblByb2dyZXNzOiB7XHJcbiAgICAgICAgY29kZTogMTAwMDMsXHJcbiAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiB3aGlsZSBzeW5jaHJvbml6YXRpb24gaXMgaW4gcHJvZ3Jlc3MuJ1xyXG4gICAgfSxcclxuICAgIHN5bmNDYW5jZWxsZWRCeVVzZXI6IHtcclxuICAgICAgICBjb2RlOiAxMDAwNCxcclxuICAgICAgICBtZXNzYWdlOiAnU3luY2hyb25pemF0aW9uIGNhbmNlbGxlZCBieSB1c2VyLidcclxuICAgIH0sXHJcbiAgICBvcGVyYXRpb25Ob3RTdXBwb3J0ZWRPZmZsaW5lOiB7XHJcbiAgICAgICAgY29kZTogMjAwMDAgLy8gdGhlIGVycm9yIG1lc3NhZ2UgaXMgY3JlYXRlZCBkeW5hbWljYWxseSBiYXNlZCBvbiB0aGUgcXVlcnkgZmlsdGVyIGZvciBvZmZsaW5lIHN0b3JhZ2VcclxuICAgIH0sXHJcbiAgICBnZW5lcmFsRGF0YWJhc2VFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IDEwNyxcclxuICAgICAgICBtZXNzYWdlOiAnR2VuZXJhbCBkYXRhYmFzZSBlcnJvci4nXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZFRva2VuOiB7XHJcbiAgICAgICAgY29kZTogMzAxLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGFjY2VzcyB0b2tlbi4nXHJcbiAgICB9LFxyXG4gICAgZXhwaXJlZFRva2VuOiB7XHJcbiAgICAgICAgY29kZTogMzAyLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdFeHBpcmVkIGFjY2VzcyB0b2tlbi4nXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZEV4cGFuZEV4cHJlc3Npb246IHtcclxuICAgICAgICBjb2RlOiA2MTgsXHJcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZXhwYW5kIGV4cHJlc3Npb24uJ1xyXG4gICAgfSxcclxuICAgIGludmFsaWRSZXF1ZXN0OiB7XHJcbiAgICAgICAgY29kZTogNjAxLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHJlcXVlc3QuJ1xyXG4gICAgfSxcclxuICAgIG1pc3NpbmdDb250ZW50VHlwZToge1xyXG4gICAgICAgIGNvZGU6IDcwMSxcclxuICAgICAgICBtZXNzYWdlOiAnQ29udGVudFR5cGUgbm90IHNwZWNpZmllZC4nXHJcbiAgICB9LFxyXG4gICAgbWlzc2luZ09ySW52YWxpZEZpbGVDb250ZW50OiB7XHJcbiAgICAgICAgY29kZTogNzAyLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdNaXNzaW5nIG9yIGludmFsaWQgZmlsZSBjb250ZW50LidcclxuICAgIH0sXHJcbiAgICBjdXN0b21GaWxlU3luY05vdFN1cHBvcnRlZDoge1xyXG4gICAgICAgIGNvZGU6IDcwMyxcclxuICAgICAgICBtZXNzYWdlOiAnQ3VzdG9tIENvbmZsaWN0UmVzb2x1dGlvbiBmb3IgZmlsZXMgaXMgbm90IGFsbG93ZWQuJ1xyXG4gICAgfSxcclxuICAgIGNhbm5vdERvd25sb2FkT2ZmbGluZToge1xyXG4gICAgICAgIGNvZGU6IDcwNCxcclxuICAgICAgICBtZXNzYWdlOiAnQ2Fubm90IGRvd25sb2FkIGEgZmlsZSB3aGlsZSBvZmZsaW5lLidcclxuICAgIH0sXHJcbiAgICBjYW5ub3RGb3JjZUNhY2hlV2hlbkRpc2FibGVkOiB7XHJcbiAgICAgICAgY29kZTogNzA1LFxyXG4gICAgICAgIG1lc3NhZ2U6ICdDYW5ub3QgdXNlIGZvcmNlQ2FjaGUgd2hpbGUgdGhlIGNhY2hpbmcgaXMgZGlzYWJsZWQuJ1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIEV2ZXJsaXZlRXJyb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlcmxpdmVFcnJvcihtZXNzYWdlLCBjb2RlKSB7XHJcbiAgICAgICAgdmFyIHRtcEVycm9yID0gRXJyb3IuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdmFyIGVyciA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcclxuICAgICAgICAgICAgY29kZSA9IGVyci5jb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdG1wRXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdG1wRXJyb3IuY29kZSA9IGNvZGUgfHwgMDtcclxuICAgICAgICB0bXBFcnJvci5uYW1lID0gdGhpcy5uYW1lID0gJ0V2ZXJsaXZlRXJyb3InO1xyXG5cclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0bXBFcnJvci5tZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcEVycm9yLnN0YWNrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgRXZlcmxpdmVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICBFdmVybGl2ZUVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZSxcclxuICAgICAgICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRXZlcmxpdmVFcnJvcjtcclxufSgpKTtcclxuXHJcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25FcnJvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JUeXBlLCBtZXNzYWdlLCBhZGRpdGlvbmFsSW5mb3JtYXRpb24pIHtcclxuICAgICAgICBFdmVybGl2ZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5lcnJvclR5cGUgPSBlcnJvclR5cGU7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICBpZiAoYWRkaXRpb25hbEluZm9ybWF0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRpdGlvbmFsSW5mb3JtYXRpb24gPSBhZGRpdGlvbmFsSW5mb3JtYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZXJsaXZlRXJyb3IucHJvdG90eXBlKTtcclxuXHJcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5mcm9tRXZlcmxpdmVFcnJvciA9IGZ1bmN0aW9uIChldmVybGl2ZUVycm9yKSB7XHJcbiAgICAgICAgdmFyIGRldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gbmV3IERldmljZVJlZ2lzdHJhdGlvbkVycm9yKERldmljZVJlZ2lzdHJhdGlvbkVycm9yVHlwZXMuRXZlcmxpdmVFcnJvciwgZXZlcmxpdmVFcnJvci5tZXNzYWdlLCBldmVybGl2ZUVycm9yKTtcclxuICAgICAgICByZXR1cm4gZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3I7XHJcbiAgICB9O1xyXG5cclxuICAgIERldmljZVJlZ2lzdHJhdGlvbkVycm9yLmZyb21QbHVnaW5FcnJvciA9IGZ1bmN0aW9uIChlcnJvck9iaikge1xyXG4gICAgICAgIHZhciBtZXNzYWdlID0gJ0EgcGx1Z2luIGVycm9yIG9jY3VycmVkJztcclxuICAgICAgICBpZiAoZXJyb3JPYmopIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvck9iai5lcnJvciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvck9iai5lcnJvcjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3JPYmoubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvck9iai5tZXNzYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IoRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3JUeXBlcy5QbHVnaW5FcnJvciwgbWVzc2FnZSwgZXJyb3JPYmopO1xyXG4gICAgICAgIHJldHVybiBkZXZpY2VSZWdpc3RyYXRpb25FcnJvcjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIERldmljZVJlZ2lzdHJhdGlvbkVycm9yVHlwZXMgPSB7XHJcbiAgICAgICAgRXZlcmxpdmVFcnJvcjogMSxcclxuICAgICAgICBQbHVnaW5FcnJvcjogMlxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3I7XHJcbn0oKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEV2ZXJsaXZlRXJyb3I6IEV2ZXJsaXZlRXJyb3IsXHJcbiAgICBFdmVybGl2ZUVycm9yczogRXZlcmxpdmVFcnJvcnMsXHJcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25FcnJvcjogRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3JcclxufTsiLCJ2YXIgUHJvY2Vzc29yID0gcmVxdWlyZSgnLi9jb21tb24nKS5Qcm9jZXNzb3I7XHJcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5L0RhdGFRdWVyeScpO1xyXG52YXIgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5L1F1ZXJ5Jyk7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb2Nlc3Nvcih7XHJcbiAgICAgICAgZXhlY3V0aW9uTm9kZUZ1bmN0aW9uOiBmdW5jdGlvbiAobm9kZSwgZXhwYW5kQ29udGV4dCwgZG9uZSkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0VHlwZU5hbWUgPSBub2RlLnRhcmdldFR5cGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGNvbnN0YW50cy5GaWxlc1R5cGVOYW1lTGVnYWN5ID8gY29uc3RhbnRzLkZpbGVzVHlwZU5hbWUgOiBub2RlLnRhcmdldFR5cGVOYW1lO1xyXG5cclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdGFyZ2V0VHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IG5ldyBRdWVyeShub2RlLmZpbHRlciwgbm9kZS5zZWxlY3QsIG5vZGUuc29ydCwgbm9kZS5za2lwLCBub2RlLnRha2UpXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZXhwYW5kQ29udGV4dC5vZmZsaW5lTW9kdWxlLnByb2Nlc3NRdWVyeShxdWVyeSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCBkYXRhLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0sIGRvbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KCkpO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uKG9wZXJhdG9yLCBvcGVyYW5kcykge1xyXG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuICAgICAgICB0aGlzLm9wZXJhbmRzID0gb3BlcmFuZHMgfHwgW107XHJcbiAgICB9XHJcblxyXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgYWRkT3BlcmFuZDogZnVuY3Rpb24gKG9wZXJhbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVyYW5kcy5wdXNoKG9wZXJhbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEV4cHJlc3Npb247XHJcbn0oKSk7IiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy9UT0RPIGFkZCBhIGZ1bmN0aW9uIGZvciBjYWxjdWxhdGluZyB0aGUgZGlzdGFuY2VzIGluIGdlb3NwYXRpYWwgcXVlcmllc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzZGVzYyBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHZhbHVlIGZvciB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBHZW9Qb2ludCBmaWVsZC5cclxuICAgICAqIEBjbGFzcyBHZW9Qb2ludFxyXG4gICAgICogQHBhcmFtIGxvbmdpdHVkZSBMb25naXR1ZGUgb2YgdGhlIEdlb1BvaW50IGluIGRlY2ltYWwgZGVncmVlcyAocmFuZ2U6IC0xODAgdG8gMTgwKS4gRXhhbXBsZTogYDEyMy4zMjM5NDY3YFxyXG4gICAgICogQHBhcmFtIGxhdGl0dWRlIExhdGl0dWRlIG9mIHRoZSBHZW9Qb2ludCBpbiBkZWNpbWFsIGRlZ3JlZXMgKHJhbmdlOiAtOTAgdG8gOTApLiBFeGFtcGxlOiBgNDIuNjk1NDMyMmBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gR2VvUG9pbnQobG9uZ2l0dWRlLCBsYXRpdHVkZSkge1xyXG4gICAgICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlIHx8IDA7XHJcbiAgICAgICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlIHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEdlb1BvaW50O1xyXG59KCkpOyIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxudmFyIGJ1aWxkUHJvbWlzZSA9IHV0aWxzLmJ1aWxkUHJvbWlzZTtcclxudmFyIERldmljZVJlZ2lzdHJhdGlvblJlc3VsdCA9IHV0aWxzLkRldmljZVJlZ2lzdHJhdGlvblJlc3VsdDtcclxudmFyIGV2ZXJsaXZlRXJyb3JNb2R1bGUgPSByZXF1aXJlKCcuL0V2ZXJsaXZlRXJyb3InKTtcclxudmFyIERldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gZXZlcmxpdmVFcnJvck1vZHVsZS5EZXZpY2VSZWdpc3RyYXRpb25FcnJvcjtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSBldmVybGl2ZUVycm9yTW9kdWxlLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBDdXJyZW50RGV2aWNlID0gcmVxdWlyZSgnLi9wdXNoL0N1cnJlbnREZXZpY2UnKTtcclxudmFyIFBsYXRmb3JtID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKS5QbGF0Zm9ybTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIFB1c2hcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBjbGFzcyBmb3IgbWFuYWdpbmcgcHVzaCBub3RpZmljYXRpb25zIGluIHlvdXIgYXBwbGljYXRpb24uIFN1cHBvcnRlZCBhcmUgcHVzaCBub3RpZmljYXRpb25zIGZvciBoeWJyaWQgYXBwcyBvbiBBbmRyb2lkIGFuZCBpT1MuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gZWwge0V2ZXJsaXZlfSBFdmVybGl2ZSBPYmplY3RcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUHVzaChlbCkge1xyXG4gICAgICAgIHRoaXMuX2VsID0gZWw7XHJcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gZWwuZGF0YSgnUHVzaC9Ob3RpZmljYXRpb25zJyk7XHJcbiAgICAgICAgdGhpcy5kZXZpY2VzID0gZWwuZGF0YSgnUHVzaC9EZXZpY2VzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgUHVzaC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgVGVsZXJpayBQdXNoIE5vdGlmaWNhdGlvbnMgcGx1Zy1pbiBoYXMgYmVlbiBsb2FkZWQgYW5kIGlzIHJlYWR5IHRvIHVzZS4gQW4ge0V2ZXJsaXZlRXJyb3J9IGlzIHJldHVybmVkIGlmIHRoZSBwbHVnLWluIGlzIG5vdCBhdmFpbGFibGUuXHJcbiAgICAgICAgICogQG1ldGhvZCBlbnN1cmVQdXNoSXNBdmFpbGFibGVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBlbnN1cmVQdXNoSXNBdmFpbGFibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgQ3VycmVudERldmljZS5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTsgICAgICAgICAgICBcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZGV2aWNlIGZvciBzZW5kaW5nIHB1c2ggbm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4yLjdcclxuICAgICAgICAgKiBAc2VlIFtQdXNoLnJlZ2lzdGVyXXtAbGluayBwdXNoLnJlZ2lzdGVyfVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgY3VycmVudERldmljZVxyXG4gICAgICAgICAqIEBuYW1lIGN1cnJlbnREZXZpY2VcclxuICAgICAgICAgKiBAcGFyYW0gW2VtdWxhdG9yTW9kZV0ge0Jvb2xlYW59IElmIHNldCB0byB0cnVlLCBlbXVsYXRvciBtb2RlIGlzIGVuYWJsZWQgbWVhbmluZyB5b3UgY2Fubm90IHNlbmQgcHVzaCBub3RpZmljYXRpb25zLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtDdXJyZW50RGV2aWNlfSBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIEN1cnJlbnREZXZpY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3VycmVudERldmljZTogZnVuY3Rpb24gKGVtdWxhdG9yTW9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGVtdWxhdG9yTW9kZSA9IHRoaXMuX2VsLnNldHVwLl9lbXVsYXRvck1vZGU7XHJcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudERldmljZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudERldmljZSA9IG5ldyBDdXJyZW50RGV2aWNlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5BcHBCdWlsZGVyU2ltdWxhdG9yID0gdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5zaW11bGF0b3I7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RGV2aWNlLmVtdWxhdG9yTW9kZSA9IGVtdWxhdG9yTW9kZSB8fCBpbkFwcEJ1aWxkZXJTaW11bGF0b3I7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudERldmljZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBvbiB0aGUgZGV2aWNlIGFuZCByZWdpc3RlcnMgaXQgZm9yIHRoZSBmZWF0dXJlIHdpdGgge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuIElmIGl0IGhhcyBiZWVuIHJlZ2lzdGVyZWQsIHRoZSByZWdpc3RyYXRpb24gZGV0YWlscyBhcmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc2V0dGluZ3MgZm9yIHRoZSByZWdpc3RyYXRpb24uIEl0IGNhbiBpbmNsdWRlIGN1c3RvbSBwYXJhbWV0ZXJzIHRvIGJlIHN0b3JlZCBieSB7e3NpdGUuYnN9fS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MuaU9TPW51bGwgaU9TLXNwZWNpZmljIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2V0dGluZ3MuaU9TLmFsZXJ0PXRydWUgSWYgc2V0IHRvIHRydWUsIHRoZSBwdXNoIG5vdGlmaWNhdGlvbiB3aWxsIGRpc3BsYXkgYXMgYSBzdGFuZGFyZCBpT1MgYWxlcnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzZXR0aW5ncy5pT1MuYmFkZ2U9JysxJyBTcGVjaWZpZXMgdGhlIGJhZGdlIGNvdW50ZXIgdG8gYmUgZGlzcGxheWVkIG9uIHRoZSBkZXZpY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzZXR0aW5ncy5pT1MuY2xlYXJCYWRnZT1mYWxzZSBTcGVjaWZpZXMgd2hldGhlciB0byByZXNldCB0aGUgYmFkZ2UgY291bnQgdG8gMC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5zb3VuZD10cnVlIElmIHNldCB0byB0cnVlLCB0aGUgZGV2aWNlIHdpbGwgcGxheSBhIG5vdGlmaWNhdGlvbiBzb3VuZC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MuYW5kcm9pZD1udWxsIEFuZHJvaWQtc3BlY2lmaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQ9bnVsbCBZb3VyIEdvb2dsZSBBUEkgcHJvamVjdCBudW1iZXIuIEl0IGlzIHJlcXVpcmVkIHdoZW4gb2J0YWluaW5nIGEgcHVzaCB0b2tlbiBmb3IgYW4gQW5kcm9pZCBkZXZpY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQucHJvamVjdE51bWJlcj1udWxsIFN5bm9ueW0gZm9yIGFuZHJvaWQuc2VuZGVySUQuIEF2YWlsYWJsZSBpbiBKYXZhU2NyaXB0IFNESyB2ZXJzaW9ucyAxLjIuNyBhbmQgbGF0ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLndwOD1udWxsIFdpbmRvd3MgUGhvbmUgc3BlY2lmaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLndwOC5jaGFubmVsTmFtZT1udWxsIFRoZSBuYW1lIG9mIHRoZSBwdXNoIGNoYW5uZWwgdGhhdCB0aGUgZGV2aWNlIGlzIHJlZ2lzdGVyaW5nIHRvLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrSU9TIFNwZWNpZmllcyBhIGN1c3RvbSBjYWxsYmFjayB0byBiZSB1c2VkIHdoZW4gYSBwdXNoIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZCBvbiBpT1MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkIFNwZWNpZmllcyBhIGN1c3RvbSBjYWxsYmFjayB0byBiZSB1c2VkIHdoZW4gYSBwdXNoIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZCBvbiBBbmRyb2lkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrV1A4IFNwZWNpZmllcyBhIGN1c3RvbSBjYWxsYmFjayB0byBiZSB1c2VkIHdoZW4gYSBwdXNoIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZCBvbiBXaW5kb3dzIFBob25lIDguXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnM9bnVsbCBTcGVjaWZpZXMgb3B0aW9uYWwgY3VzdG9tIHJlZ2lzdHJhdGlvbiBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSBzYXZlZCBpbiBUZWxlcmlrIEJhY2tlbmQgU2VydmljZXMuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBvbiB0aGUgZGV2aWNlIGFuZCByZWdpc3RlcnMgaXQgZm9yIHRoZSBmZWF0dXJlIHdpdGgge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuIElmIGl0IGhhcyBiZWVuIHJlZ2lzdGVyZWQsIHRoZSByZWdpc3RyYXRpb24gZGV0YWlscyBhcmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBUZWxlcmlrIEJhY2tlbmQgU2VydmljZXMgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLlxyXG4gICAgICAgICAqIElmIGl0IHdhcyByZWdpc3RlcmVkIHRoZSByZWdpc3RyYXRpb24gZGV0YWlscyBhcmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgU2V0dGluZ3MgZm9yIHRoZSByZWdpc3RyYXRpb24uIENhbiBpbmNsdWRlIGN1c3RvbSBwYXJhbWV0ZXJzIHRvIGJlIHNhdmVkIGluIGJhY2tlbmQgc2VydmljZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLmlPUz1udWxsIGlPUyBzcGVjaWZpYyBzZXR0aW5nc1xyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2V0dGluZ3MuaU9TLmFsZXJ0PXRydWUgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRldmljZSB3aWxsIGRpc3BsYXkgYW4gYWxlcnQgbWVzc2FnZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNldHRpbmdzLmlPUy5iYWRnZT0nKzEnIFNwZWNpZmllcyB0aGUgYmFkZ2UgY291bnRlciB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIGRldmljZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5jbGVhckJhZGdlPWZhbHNlIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJlc2V0IHRoZSBiYWRnZSBjb3VudCB0byAwLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2V0dGluZ3MuaU9TLnNvdW5kPXRydWUgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRldmljZSB3aWxsIHBsYXkgYSBzb3VuZC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MuYW5kcm9pZD1udWxsIEFuZHJvaWQgc3BlY2lmaWMgc2V0dGluZ3NcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2V0dGluZ3MuYW5kcm9pZC5zZW5kZXJJRD1udWxsIFRoaXMgaXMgeW91ciBHb29nbGUgQVBJIHByb2plY3QgbnVtYmVyLiBJdCBpcyByZXF1aXJlZCB3aGVuIG9idGFpbmluZyBhIHB1c2ggdG9rZW4gZm9yIGFuIEFuZHJvaWQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy5hbmRyb2lkLnByb2plY3ROdW1iZXI9bnVsbCBTeW5vbnltIGZvciBhbmRyb2lkLnNlbmRlcklELiBBdmFpbGFibGUgaW4gSmF2YVNjcmlwdCBTREsgdmVyc2lvbnMgMS4yLjcgYW5kIGxhdGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy53cDg9bnVsbCBXaW5kb3dzIFBob25lIHNwZWNpZmljIHNldHRpbmdzXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLndwOC5jaGFubmVsTmFtZT1udWxsIFRoZSBuYW1lIG9mIHRoZSBwdXNoIGNoYW5uZWwgdGhhdCB0aGUgZGV2aWNlIGlzIHJlZ2lzdGVyaW5nIHRvLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrSU9TIFNwZWNpZmllcyBhIGN1c3RvbSBjYWxsYmFjayB0byBiZSB1c2VkIHdoZW4gYSBwdXNoIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZCBvbiBpT1MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkIFNwZWNpZmllcyBhIGN1c3RvbSBjYWxsYmFjayB0byBiZSB1c2VkIHdoZW4gYSBwdXNoIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZCBvbiBBbmRyb2lkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrV1A4IFNwZWNpZmllcyBhIGN1c3RvbSBjYWxsYmFjayB0byBiZSB1c2VkIHdoZW4gYSBwdXNoIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZCBvbiBXaW5kb3dzIFBob25lIDguXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnM9bnVsbCBTcGVjaWZpZXMgb3B0aW9uYWwgY3VzdG9tIHJlZ2lzdHJhdGlvbiBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSBzYXZlZCBpbiBUZWxlcmlrIEJhY2tlbmQgU2VydmljZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoc2V0dGluZ3MsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY3VycmVudERldmljZSA9IHRoaXMuY3VycmVudERldmljZSgpO1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcblxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5kcm9pZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYW5kcm9pZC5zZW5kZXJJRCA9IHNldHRpbmdzLmFuZHJvaWQucHJvamVjdE51bWJlciB8fCBzZXR0aW5ncy5hbmRyb2lkLnNlbmRlcklEO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3VjY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gKHRva2VuLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEZXZpY2VSZWdpc3RyYXRpb25SZXN1bHQodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBlcnJvckNhbGxiYWNrID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWdpc3RyYXRpb25FcnJvciA9IERldmljZVJlZ2lzdHJhdGlvbkVycm9yLmZyb21FdmVybGl2ZUVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZWdpc3RyYXRpb25FcnJvcik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgY2xlYXJCYWRnZUlmTmVlZGVkID0gZnVuY3Rpb24gKHRva2VuLCBzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwbGF0Zm9ybVR5cGUgPSBjdXJyZW50RGV2aWNlLl9nZXRQbGF0Zm9ybVR5cGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjbGVhckJhZGdlID0gcGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybS5pT1M7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyQmFkZ2UgJiYgc2V0dGluZ3MuaU9TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJCYWRnZSA9IHNldHRpbmdzLmlPUy5jbGVhckJhZGdlICE9PSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXJCYWRnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXJCYWRnZU51bWJlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2sodG9rZW4sIHN1Y2Nlc3NDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVyciwgZXJyb3JDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh0b2tlbiwgc3VjY2Vzc0NiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERldmljZS5lbmFibGVOb3RpZmljYXRpb25zKHNldHRpbmdzLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSByZXNwb25zZS50b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tUGFyYW1ldGVycyA9IHNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERldmljZS5nZXRSZWdpc3RyYXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGV2aWNlLnVwZGF0ZVJlZ2lzdHJhdGlvbihjdXN0b21QYXJhbWV0ZXJzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJCYWRnZUlmTmVlZGVkKHRva2VuLCBzdWNjZXNzQ2IsIGVycm9yQ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyLCBlcnJvckNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDgwMSkgeyAvL05vdCByZWdpc3RlcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERldmljZS5yZWdpc3RlcihjdXN0b21QYXJhbWV0ZXJzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyQmFkZ2VJZk5lZWRlZCh0b2tlbiwgc3VjY2Vzc0NiLCBlcnJvckNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBlcnJvckNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIsIGVycm9yQ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5mcm9tUGx1Z2luRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvckNiKGRldmljZVJlZ2lzdHJhdGlvbkVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZXMgcHVzaCBub3RpZmljYXRpb25zIGZvciB0aGUgY3VycmVudCBkZXZpY2UuIFRoaXMgbWV0aG9kIGludmFsaWRhdGVzIGFueSBwdXNoIHRva2VucyB0aGF0IHdlcmUgb2J0YWluZWQgZm9yIHRoZSBkZXZpY2UgZnJvbSB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi4gVGhlIGRldmljZSB3aWxsIGFsc28gYmUgdW5yZWdpc3RlcmVkIGZyb20ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fS5cclxuICAgICAgICAgKiBAbWV0aG9kIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAbmFtZSB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBjdXJyZW50IGRldmljZS4gVGhpcyBtZXRob2QgaW52YWxpZGF0ZXMgYW55IHB1c2ggdG9rZW5zIHRoYXQgd2VyZSBvYnRhaW5lZCBmb3IgdGhlIGRldmljZSBmcm9tIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uLiBUaGUgZGV2aWNlIHdpbGwgYWxzbyBiZSB1bnJlZ2lzdGVyZWQgZnJvbSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGludmFsaWRhdGVzIGFueSBwdXNoIHRva2VucyB0aGF0IHdlcmUgb2J0YWluZWQgZm9yIHRoZSBkZXZpY2UgZnJvbSB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi5cclxuICAgICAgICAgKiBUaGUgZGV2aWNlIHdpbGwgYWxzbyBiZSB1bnJlZ2lzdGVyZWQgZnJvbSBUZWxlcmlrIEJhY2tlbmQgU2VydmljZXMuXHJcbiAgICAgICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXZpY2UgPSB0aGlzLmN1cnJlbnREZXZpY2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZXZpY2UuZGlzYWJsZU5vdGlmaWNhdGlvbnMuYXBwbHkoY3VycmVudERldmljZSwgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uIElmIHt1bmRlZmluZWR9LCBjdXN0b21QYXJhbWV0ZXJzIGFyZSBub3QgdXBkYXRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uIElmIHt1bmRlZmluZWR9LCBjdXN0b21QYXJhbWV0ZXJzIGFyZSBub3QgdXBkYXRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZVJlZ2lzdHJhdGlvbjogZnVuY3Rpb24gKGN1c3RvbVBhcmFtZXRlcnMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXZpY2UgPSB0aGlzLmN1cnJlbnREZXZpY2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZXZpY2UudXBkYXRlUmVnaXN0cmF0aW9uLmFwcGx5KGN1cnJlbnREZXZpY2UsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgYmFkZ2UgbnVtYmVyIG9uIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHNlcnZlci5cclxuICAgICAgICAgKiBAbWV0aG9kIHNldEJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG5hbWUgc2V0QmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGJhZGdlIFRoZSBudW1iZXIgdG8gYmUgc2V0IGFzIGEgYmFkZ2UuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBiYWRnZSBudW1iZXIgb24gdGhlIHNlcnZlclxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbmFtZSBzZXRCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gYmFkZ2UgVGhlIG51bWJlciB0byBiZSBzZXQgYXMgYSBiYWRnZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldEJhZGdlTnVtYmVyOiBmdW5jdGlvbiAoYmFkZ2UsIG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgYmFkZ2UgPSBwYXJzZUludChiYWRnZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihiYWRnZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IobmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBiYWRnZSBtdXN0IGhhdmUgYSBudW1lcmljIHZhbHVlJykpO1xyXG4gICAgICAgICAgICAgICAgfSwgb25TdWNjZXNzLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRldmljZVJlZ2lzdHJhdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudERldmljZSA9IHRoaXMuY3VycmVudERldmljZSgpO1xyXG4gICAgICAgICAgICB2YXIgZGV2aWNlSWQgPSBjdXJyZW50RGV2aWNlLl9nZXREZXZpY2VJZCgpO1xyXG4gICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uSWQgPSAnSGFyZHdhcmVJZC8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKTtcclxuICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLkJhZGdlQ291bnRlciA9IGJhZGdlO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuX3B1c2hIYW5kbGVyLmRldmljZXMudXBkYXRlU2luZ2xlKGRldmljZVJlZ2lzdHJhdGlvbikudGhlbihcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cucGx1Z2lucyAmJiB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbi5zZXRBcHBsaWNhdGlvbkljb25CYWRnZU51bWJlcihzdWNjZXNzQ2IsIGVycm9yQ2IsIGJhZGdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzQ2IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9yQ2IpXHJcbiAgICAgICAgICAgIH0sIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoZSBiYWRnZSBudW1iZXIgb24gdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gc2VydmVyIHRvIDAuXHJcbiAgICAgICAgICogQG1ldGhvZCBjbGVhckJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG5hbWUgY2xlYXJCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSBiYWRnZSBudW1iZXIgb24gdGhlIHNlcnZlciBieSBzZXR0aW5nIGl0IHRvIDBcclxuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyQmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbmFtZSBjbGVhckJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGVhckJhZGdlTnVtYmVyOiBmdW5jdGlvbiAob25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRCYWRnZU51bWJlcigwLCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHB1c2ggbm90aWZpY2F0aW9ucyByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWV0aG9kIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcHVzaCByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWV0aG9kIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UmVnaXN0cmF0aW9uOiBmdW5jdGlvbiAob25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY3VycmVudERldmljZSA9IHRoaXMuY3VycmVudERldmljZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERldmljZS5nZXRSZWdpc3RyYXRpb24uYXBwbHkoY3VycmVudERldmljZSwgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZW5kcyBhIHB1c2ggbm90aWZpY2F0aW9uLlxyXG4gICAgICAgICAqIEBtZXRob2Qgc2VuZFxyXG4gICAgICAgICAqIEBuYW1lIHNlbmRcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm90aWZpY2F0aW9uIFRoZSBwdXNoIG5vdGlmaWNhdGlvbiBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VuZHMgYSBwdXNoIG1lc3NhZ2VcclxuICAgICAgICAgKiBAbWV0aG9kIHNlbmRcclxuICAgICAgICAgKiBAbmFtZSBzZW5kXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmaWNhdGlvbiBUaGUgcHVzaCBub3RpZmljYXRpb24gb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZW5kOiBmdW5jdGlvbiAobm90aWZpY2F0aW9uLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdGlmaWNhdGlvbnMuY3JlYXRlLmFwcGx5KHRoaXMubm90aWZpY2F0aW9ucywgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBwcm92aWRlcyBhIGRpZmZlcmVudCBvcGVyYXRpb24gb24gZWFjaCBzdXBwb3J0ZWQgcGxhdGZvcm06XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAtIE9uIGlPUzogQ2hlY2tzIGlmIE5vdGlmaWNhdGlvbnMgaXMgZW5hYmxlZCBmb3IgdGhpcyBhcHBsaWNhdGlvbiBpbiB0aGUgZGV2aWNlJ3MgTm90aWZpY2F0aW9uIENlbnRlci5cclxuICAgICAgICAgKiAtIE9uIFdpbmRvd3MgUGhvbmU6IENoZWNrcyBpZiB0aGUgYXBwbGljYXRpb24gaGFzIGFuIGFjdGl2ZSBvcGVuIGNoYW5uZWwgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgTWljcm9zb2Z0IFB1c2ggTm90aWZpY2F0aW9uIFNlcnZpY2UuIFRoZSBvdXRjb21lIGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgZGV2aWNlJ3Mgbm90aWZpY2F0aW9uIHNldHRpbmdzLlxyXG4gICAgICAgICAqIC0gT24gQW5kcm9pZDogQ2hlY2tzIGlmIHRoZSBhcHBsaWNhdGlvbiBoYXMgZXN0YWJsaXNoZWQgYSBjb25uZWN0aW9uIHdpdGggR29vZ2xlIENsb3VkIE1lc3NhZ2luZy4gVGhlIG91dGNvbWUgZG9lcyBub3QgZGVwZW5kIG9uIHRoZSBkZXZpY2UncyBub3RpZmljYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgICogQG1ldGhvZCBhcmVOb3RpZmljYXRpb25zRW5hYmxlZFxyXG4gICAgICAgICAqIEBuYW1lIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IHBhc3NlZCB0byB0aGUgUHVzaCBOb3RpZmljYXRpb24gcGx1Z2luJ3MgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWQgbWV0aG9kXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBpT1M6IENoZWNrcyBpZiB0aGUgTm90aWZpY2F0aW9ucyBhcmUgZW5hYmxlZCBmb3IgdGhpcyBBcHBsaWNhdGlvbiBpbiB0aGUgRGV2aWNlJ3MgTm90aWZpY2F0aW9uIENlbnRlci5cclxuICAgICAgICAgKiBXaW5kb3dzIFBob25lOiBDaGVja3MgaWYgdGhlIEFwcGxpY2F0aW9uIGhhcyBhbiBhY3RpdmUgb3BlbmVkIENoYW5uZWwgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgTm90aWZpY2F0aW9uIFNlcnZpY2UuIE5vdCByZWx5aW5nIG9uIHRoZSBkZXZpY2Ugbm90aWZpY2F0aW9uIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEFuZHJvaWQ6IENoZWNrcyBpZiB0aGUgQXBwbGljYXRpb24gaGFzIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24gd2l0aCB0aGUgTm90aWZpY2F0aW9uIFNlcnZpY2UuIE5vdCByZWx5aW5nIG9uIHRoZSBkZXZpY2Ugbm90aWZpY2F0aW9uIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEBtZXRob2QgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcclxuICAgICAgICAgKiBAbmFtZSBhcmVOb3RpZmljYXRpb25zRW5hYmxlZFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCBwYXNzZWQgdG8gdGhlIFB1c2ggTm90aWZpY2F0aW9uIHBsdWdpbidzIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkIG1ldGhvZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzc2Z1bCBjaGVjay4gUGFzc2VzIGEgc2luZ2xlIGJvb2xlYW4gdmFsdWU6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGVycm9yIGluIHRoZSBwdXNoIHBsdWdpbiBoYXMgb2NjdXJyZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWQ6IGZ1bmN0aW9uIChvcHRpb25zLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGV2aWNlLmFyZU5vdGlmaWNhdGlvbnNFbmFibGVkKG9wdGlvbnMsIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUHVzaDtcclxufSgpKTsiLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciByc3ZwID0gcmVxdWlyZSgnLi9jb21tb24nKS5yc3ZwO1xyXG52YXIgYnVpbGRBdXRoSGVhZGVyID0gdXRpbHMuYnVpbGRBdXRoSGVhZGVyO1xyXG52YXIgcGFyc2VVdGlsaXRpZXMgPSB1dGlscy5wYXJzZVV0aWxpdGllcztcclxudmFyIGd1YXJkVW5zZXQgPSB1dGlscy5ndWFyZFVuc2V0O1xyXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxudmFyIHJlcXdlc3QgPSBjb21tb24ucmVxd2VzdDtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIEhlYWRlcnMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLkhlYWRlcnM7XHJcbnZhciBpc05vZGVqcyA9IHJlcXVpcmUoJy4vZXZlcmxpdmUucGxhdGZvcm0nKS5pc05vZGVqcztcclxudmFyIFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeS9RdWVyeScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIF9zZWxmO1xyXG5cclxuICAgIC8vIFRoZSBSZXF1ZXN0IHR5cGUgaXMgYW4gYWJzdHJhY3Rpb24gb3ZlciBBamF4IGxpYnJhcmllc1xyXG4gICAgLy8gQSBSZXF1ZXN0IG9iamVjdCBuZWVkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgRXZlcmxpdmUgY29ubmVjdGlvbiBhbmQgaW5pdGlhbGl6YXRpb24gb3B0aW9uc1xyXG5cclxuICAgIGZ1bmN0aW9uIFJlcXVlc3Qoc2V0dXAsIG9wdGlvbnMpIHtcclxuICAgICAgICBndWFyZFVuc2V0KHNldHVwLCAnc2V0dXAnKTtcclxuICAgICAgICBndWFyZFVuc2V0KG9wdGlvbnMsICdvcHRpb25zJyk7XHJcbiAgICAgICAgdGhpcy5zZXR1cCA9IHNldHVwO1xyXG4gICAgICAgIHRoaXMubWV0aG9kID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVuZHBvaW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xyXG4gICAgICAgIC8vIFRPRE8gc3VjY2VzcyBhbmQgZXJyb3IgY2FsbGJhY2tzIHNob3VsZCBiZSB1bmlmb3JtZWQgZm9yIGFsbCBhamF4IGxpYnNcclxuICAgICAgICB0aGlzLnN1Y2Nlc3MgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFyc2UgPSBSZXF1ZXN0LnBhcnNlcnMuc2ltcGxlO1xyXG5cclxuICAgICAgICBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICBfc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBSZXF1ZXN0LnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvLyBDYWxscyB0aGUgdW5kZXJseWluZyBBamF4IGxpYnJhcnlcclxuICAgICAgICBzZW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3Quc2VuZFJlcXVlc3QodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBSZXR1cm5zIGFuIGF1dGhvcml6YXRpb24gaGVhZGVyIHVzZWQgYnkgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBsb2dnZWQgaW4gdXNlciBmb3IgdGhlIEV2ZXJsaXZlIGluc3RhbmNlIHRoZW4gaGVyL2hpcyBhdXRoZW50aWNhdGlvbiB3aWxsIGJlIHVzZWQuXHJcbiAgICAgICAgYnVpbGRBdXRoSGVhZGVyOiBidWlsZEF1dGhIZWFkZXIsXHJcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBVUkwgb2YgdGhlIHRhcmdldCBFdmVybGl2ZSBzZXJ2aWNlXHJcbiAgICAgICAgYnVpbGRVcmw6IGZ1bmN0aW9uIGJ1aWxkVXJsKHNldHVwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5idWlsZFVybChzZXR1cCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHF1ZXJ5IHRvIHJldHVybiBhcHByb3ByaWF0ZSBoZWFkZXJzIHRvIGJlIHVzZWQgYnkgdGhlIHJlcXVlc3RcclxuICAgICAgICBidWlsZFF1ZXJ5SGVhZGVyczogZnVuY3Rpb24gYnVpbGRRdWVyeUhlYWRlcnMocXVlcnkpIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkgaW5zdGFuY2VvZiBRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZXF1ZXN0LnByb3RvdHlwZS5fYnVpbGRRdWVyeUhlYWRlcnMocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3QucHJvdG90eXBlLl9idWlsZEZpbHRlckhlYWRlcihxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIFJlcXVlc3Qgb2JqZWN0IGJ5IHVzaW5nIHRoZSBwYXNzZWQgb3B0aW9uc1xyXG4gICAgICAgIF9pbml0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBfLmV4dGVuZCh0aGlzLmhlYWRlcnMsIHRoaXMuYnVpbGRBdXRoSGVhZGVyKHRoaXMuc2V0dXAsIG9wdGlvbnMpLCB0aGlzLmJ1aWxkUXVlcnlIZWFkZXJzKG9wdGlvbnMuZmlsdGVyKSwgb3B0aW9ucy5oZWFkZXJzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFRyYW5zbGF0ZXMgYW4gRXZlcmxpdmUuUXVlcnkgdG8gcmVxdWVzdCBoZWFkZXJzXHJcbiAgICAgICAgX2J1aWxkUXVlcnlIZWFkZXJzOiBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5idWlsZCgpO1xyXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAocXVlcnkuJHdoZXJlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuZmlsdGVyXSA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LiR3aGVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiRzZWxlY3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy5zZWxlY3RdID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuJHNlbGVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiRzb3J0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuc29ydF0gPSBKU09OLnN0cmluZ2lmeShxdWVyeS4kc29ydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiRza2lwICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuc2tpcF0gPSBxdWVyeS4kc2tpcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocXVlcnkuJHRha2UgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy50YWtlXSA9IHF1ZXJ5LiR0YWtlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS4kZXhwYW5kICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuZXhwYW5kXSA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LiRleHBhbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQ3JlYXRlcyBhIGhlYWRlciBmcm9tIGEgc2ltcGxlIGZpbHRlclxyXG4gICAgICAgIF9idWlsZEZpbHRlckhlYWRlcjogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xyXG4gICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuZmlsdGVyXSA9IEpTT04uc3RyaW5naWZ5KGZpbHRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmcgPSBfc2VsZiAmJiBfc2VsZi5zZXR1cCAmJiBfc2VsZi5zZXR1cC5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lT2JqZWN0cztcclxuXHJcbiAgICB2YXIgcmV2aXZlciA9IHBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIocGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZVN0cmluZyk7XHJcblxyXG4gICAgUmVxdWVzdC5wYXJzZXJzID0ge1xyXG4gICAgICAgIHNpbXBsZToge1xyXG4gICAgICAgICAgICByZXN1bHQ6IHBhcnNlVXRpbGl0aWVzLnBhcnNlUmVzdWx0LmJpbmQobnVsbCwgcmV2aXZlciksXHJcbiAgICAgICAgICAgIGVycm9yOiBwYXJzZVV0aWxpdGllcy5wYXJzZUVycm9yLmJpbmQobnVsbCwgcmV2aXZlcilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpbmdsZToge1xyXG4gICAgICAgICAgICByZXN1bHQ6IHBhcnNlVXRpbGl0aWVzLnBhcnNlU2luZ2xlUmVzdWx0LmJpbmQobnVsbCwgcmV2aXZlciksXHJcbiAgICAgICAgICAgIGVycm9yOiBwYXJzZVV0aWxpdGllcy5wYXJzZUVycm9yLmJpbmQobnVsbCwgcmV2aXZlcilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZToge1xyXG4gICAgICAgICAgICByZXN1bHQ6IHBhcnNlVXRpbGl0aWVzLnBhcnNlVXBkYXRlUmVzdWx0LmJpbmQobnVsbCwgcmV2aXZlciksXHJcbiAgICAgICAgICAgIGVycm9yOiBwYXJzZVV0aWxpdGllcy5wYXJzZUVycm9yLmJpbmQobnVsbCwgcmV2aXZlcilcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRPRE8gYnVpbHQgZm9yIHJlcXVlc3RcclxuICAgIGlmICh0eXBlb2YgUmVxdWVzdC5zZW5kUmVxdWVzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBSZXF1ZXN0LnNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcclxuICAgICAgICAgICAgdmFyIHVybCA9IHJlcXVlc3QuYnVpbGRVcmwocmVxdWVzdC5zZXR1cCkgKyByZXF1ZXN0LmVuZHBvaW50O1xyXG4gICAgICAgICAgICB1cmwgPSB1dGlscy5kaXNhYmxlUmVxdWVzdENhY2hlKHVybCwgcmVxdWVzdC5tZXRob2QpO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kIHx8ICdHRVQnO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJlcXVlc3QubWV0aG9kID09PSAnR0VUJyA/IHJlcXVlc3QuZGF0YSA6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QuZGF0YSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdFBhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNOb2RlanMpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLCByZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc3VjY2Vzcy5jYWxsKHJlcXVlc3QsIHJlcXVlc3QucGFyc2UucmVzdWx0KGRhdGEpLCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuZXJyb3IgPSBmdW5jdGlvbiAoanFYSFIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmVycm9yLmNhbGwocmVxdWVzdCwgcmVxdWVzdC5wYXJzZS5lcnJvcihqcVhIUi5yZXNwb25zZVRleHQgfHwganFYSFIuc3RhdHVzVGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMudHlwZSA9ICdqc29uJztcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuY3Jvc3NPcmlnaW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcy5zdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVlc3QucGFyc2UucmVzdWx0KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc3VjY2Vzcy5jYWxsKHJlcXVlc3QsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuZXJyb3IgPSBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gcmVxdWVzdC5wYXJzZS5lcnJvcihqcVhIUi5yZXNwb25zZVRleHQgfHwganFYSFIuc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5lcnJvci5jYWxsKHJlcXVlc3QsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlcXdlc3QocmVxdWVzdFBhcmFtcyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUmVxdWVzdDtcclxufSgpKTsiLCJ2YXIgXyA9IHJlcXVpcmUoJy4vY29tbW9uJykuXztcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbnZhciBBdXRoZW50aWNhdGlvblNldHVwID0gcmVxdWlyZSgnLi9hdXRoL0F1dGhlbnRpY2F0aW9uU2V0dXAnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBldmVybGl2ZVVybCA9IGNvbnN0YW50cy5ldmVybGl2ZVVybDtcclxuXHJcbiAgICAvLyBBbiBvYmplY3QgdGhhdCBrZWVwcyBpbmZvcm1hdGlvbiBhYm91dCBhbiBFdmVybGl2ZSBjb25uZWN0aW9uXHJcbiAgICBmdW5jdGlvbiBTZXR1cChvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy51cmwgPSBldmVybGl2ZVVybDtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tYXN0ZXJLZXkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByaW5jaXBhbElkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNjaGVtZSA9ICdodHRwJzsgLy8gaHR0cCBvciBodHRwc1xyXG4gICAgICAgIHRoaXMucGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZU9iamVjdHMgPSBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0aW9ucztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9lbXVsYXRvck1vZGUgPSBvcHRpb25zLmVtdWxhdG9yTW9kZTtcclxuICAgICAgICAgICAgXy5leHRlbmQodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uID0gbmV3IEF1dGhlbnRpY2F0aW9uU2V0dXAodGhpcywgb3B0aW9ucy5hdXRoZW50aWNhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgU2V0dXAucHJvdG90eXBlLnNldEF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHRva2VuLCB0b2tlblR5cGUsIHByaW5jaXBhbElkKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xyXG4gICAgICAgIHRoaXMucHJpbmNpcGFsSWQgPSBwcmluY2lwYWxJZDtcclxuICAgIH07XHJcblxyXG4gICAgU2V0dXAucHJvdG90eXBlLmdldEF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLnRva2VuLFxyXG4gICAgICAgICAgICB0b2tlblR5cGU6IHRoaXMudG9rZW5UeXBlLFxyXG4gICAgICAgICAgICBwcmluY2lwYWxJZDogdGhpcy5wcmluY2lwYWxJZFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBTZXR1cDtcclxuXHJcbn0oKSk7IiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgRXZlcmxpdmUgPSByZXF1aXJlKCcuLi9FdmVybGl2ZScpO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciB1c2Vyc0NvbGxlY3Rpb25OYW1lID0gJ1VzZXJzJztcclxudmFyIGJ1aWxkUHJvbWlzZSA9IHV0aWxzLmJ1aWxkUHJvbWlzZTtcclxudmFyIExvY2FsU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yYWdlcy9Mb2NhbFN0b3JlJyk7XHJcbnZhciBFdmVybGl2ZUVycm9ycyA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9ycztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiBAY2xhc3NkZXNjIEEgY2xhc3MgZm9yIG1hbmFnaW5nIGF1dGhlbnRpY2F0aW9uIG9mIGEgdXNlciBpbiB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIGVsIHtFdmVybGl2ZX0gRXZlcmxpdmUgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gc2V0dXAge0F1dGhTZXR1cH0gdGhlIGF1dGhlbnRpY2F0aW9uIHNldHVwIG9iamVjdFxyXG4gICAgICovXHJcbiAgICB2YXIgQXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiAoZWwsIHNldHVwKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoU2V0dXAgPSBzZXR1cCB8fCB7fTtcclxuICAgICAgICB0aGlzLl9lbCA9IGVsO1xyXG4gICAgICAgIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5hdXRoU2V0dXAucGVyc2lzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0b3JlID0gbmV3IExvY2FsU3RvcmUoZWwpO1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxTdG9yZUtleSA9IHRoaXMuX2dldExvY2FsU3RvcmVLZXkoKTtcclxuICAgICAgICAgICAgdmFyIGF1dGhPcHRpb25zID0gdGhpcy5fbG9jYWxTdG9yZS5nZXRJdGVtKGxvY2FsU3RvcmVLZXkpO1xyXG4gICAgICAgICAgICB2YXIgYXV0aEluZm87XHJcbiAgICAgICAgICAgIGlmIChhdXRoT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgYXV0aEluZm8gPSBKU09OLnBhcnNlKHRoaXMuX2xvY2FsU3RvcmUuZ2V0SXRlbShsb2NhbFN0b3JlS2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGF1dGhJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbC5zZXR1cC5zZXRBdXRob3JpemF0aW9uUHJvcGVydGllcyhhdXRoSW5mby50b2tlbiwgYXV0aEluZm8udG9rZW5UeXBlLCBhdXRoSW5mby5wcmluY2lwYWxJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIExvZ3MgaW4gYSB1c2VyIHVzaW5nIGEgdXNlcm5hbWUgYW5kIGEgcGFzc3dvcmQgdG8gdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuIEFsbCByZXF1ZXN0cyBpbml0aWF0ZWQgYnkgdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2Ugd2lsbCBiZSBhdXRoZW50aWNhdGVkIHdpdGggdGhhdCB1c2VyJ3MgY3JlZGVudGlhbHMuXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luXHJcbiAgICAgKiBAbmFtZSBsb2dpblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gQWxsIHJlcXVlc3RzIGluaXRpYXRlZCBieSB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZSB3aWxsIGJlIGF1dGhlbnRpY2F0ZWQgd2l0aCB0aGF0IHVzZXIncyBjcmVkZW50aWFscy5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5cclxuICAgICAqIEBuYW1lIGxvZ2luXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWNjZXNzRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2xvZ2luU3VjY2Vzcy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB1c2Vyc0NvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3Bhc3N3b3JkJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzRnVuYyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2VsLlVzZXJzLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dvdXRcclxuICAgICAqIEBuYW1lIGxvZ291dFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dvdXRcclxuICAgICAqIEBuYW1lIGxvZ291dFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dvdXQgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fbG9nb3V0U3VjY2Vzcy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGVycm9yRnVuYyA9IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gMzAxKSB7IC8vaW52YWxpZCB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXJBdXRob3JpemF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZXJyb3IuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9nb3V0LFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHVzZXJzQ29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBza2lwQXV0aDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2Vzc0Z1bmMsXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvckZ1bmNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZWwuVXNlcnMucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuX2dldExvY2FsU3RvcmVLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50cy5BdXRoU3RvcmVLZXkgKyB0aGlzLl9lbC5zZXR1cC5hcGlLZXkgKyAnJGF1dGhlbnRpY2F0aW9uJztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhGYWNlYm9vayA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnRmFjZWJvb2snLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoQURGU1xyXG4gICAgICogQG5hbWUgbG9naW5XaXRoQURGU1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhBREZTID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdBREZTJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9naW5XaXRoUHJvdmlkZXIoaWRlbnRpdHksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgTGl2ZUlEIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhMaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBMaXZlSUQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgTGl2ZUlEIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhMaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBMaXZlSUQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhMaXZlSUQgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0xpdmVJRCcsXHJcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2luV2l0aFByb3ZpZGVyKGlkZW50aXR5LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUubG9naW5XaXRoR29vZ2xlID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdHb29nbGUnLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9naW5XaXRoUHJvdmlkZXIoaWRlbnRpdHksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHdpdGggYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFR3aXR0ZXIgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVHdpdHRlciBzZWNyZXQgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVHdpdHRlciB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblNlY3JldCBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUubG9naW5XaXRoVHdpdHRlciA9IGZ1bmN0aW9uICh0b2tlbiwgdG9rZW5TZWNyZXQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ1R3aXR0ZXInLFxyXG4gICAgICAgICAgICBUb2tlbjogdG9rZW4sXHJcbiAgICAgICAgICAgIFRva2VuU2VjcmV0OiB0b2tlblNlY3JldFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIHRoYXQgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgd2lsbCB1c2UgZm9yIGF1dGhvcml6YXRpb24uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHNldEF1dGhvcml6YXRpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlbiB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYXV0aG9yaXphdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuVG9rZW5UeXBlfSB0b2tlblR5cGUgVG9rZW4gdHlwZS4gQ3VycmVudGx5IG9ubHkgJ2JlYXJlcicgdG9rZW4gaXMgc3VwcG9ydGVkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaW5jaXBhbElkIFRoZSBpZCBvZiB0aGUgdXNlciB0aGF0IGlzIGxvZ2dlZCBpbi5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLnNldEF1dGhvcml6YXRpb24gPSBmdW5jdGlvbiBzZXRBdXRob3JpemF0aW9uKHRva2VuLCB0b2tlblR5cGUsIHByaW5jaXBhbElkKSB7XHJcbiAgICAgICAgdGhpcy5fZWwuc2V0dXAuc2V0QXV0aG9yaXphdGlvblByb3BlcnRpZXModG9rZW4sIHRva2VuVHlwZSwgcHJpbmNpcGFsSWQpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hdXRoU2V0dXAucGVyc2lzdCkge1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxTdG9yZUtleSA9IHRoaXMuX2dldExvY2FsU3RvcmVLZXkoKTtcclxuICAgICAgICAgICAgdmFyIGF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzID0gdGhpcy5fZWwuc2V0dXAuZ2V0QXV0aG9yaXphdGlvblByb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYWxTdG9yZS5zZXRJdGVtKGxvY2FsU3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KGF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fYXV0aGVudGljYXRpb25DYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXV0aGVudGljYXRpb25DYWxsYmFja3Muc3VjY2VzcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4gdGhhdCB0aGUge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgY3VycmVudGx5IHVzZXMuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCB0aGFuIGxvZ2dpbmcgb3V0LCBiZWNhdXNlIHRoZSBhdXRob3JpemF0aW9uIHRva2VuIHRoYXQgd2FzIHVzZWQsIHdpbGwgbm90IGJlIGludmFsaWRhdGVkLlxyXG4gICAgICogQG1ldGhvZCBjbGVhckF1dGhvcml6YXRpb25cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmNsZWFyQXV0aG9yaXphdGlvbiA9IGZ1bmN0aW9uIGNsZWFyQXV0aG9yaXphdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldEF1dGhvcml6YXRpb24obnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5jbGVhclBlcnNpc3RlZEF1dGhlbnRpY2F0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHBlcnNpc3RlZCBhdXRoZW50aWNhdGlvbiBmcm9tIHRoZSBsb2NhbCBzdG9yZSBmb3IgdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuIFdpbGwgbm90IGxvZ291dCBvciBtb2RpZnkgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gb2YgdGhlIEphdmFzY3JpcHQgU0RLLlxyXG4gICAgICogQG1ldGhvZCBjbGVhclBlcnNpc3RlZEF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5jbGVhclBlcnNpc3RlZEF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbFN0b3JlS2V5ID0gdGhpcy5fZ2V0TG9jYWxTdG9yZUtleSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0b3JlLnJlbW92ZUl0ZW0obG9jYWxTdG9yZUtleSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsLnNldHVwLnNldEF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzKG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZW1lbnQgaXMgZW5hYmxlZCBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgYW4gb25BdXRoZW50aWNhdGlvblJlcXVpcmVkIGZ1bmN0aW9uIGlzIHByb3ZpZGVkXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuYXV0aFNldHVwLm9uQXV0aGVudGljYXRpb25SZXF1aXJlZCA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEVuc3VyZXMgdGhhdCBhdXRoZW50aWNhdGlvbiBpcyBjb21wbGV0ZWQgYmVmb3JlIGNvbnRpbnVpbmcuXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgYXV0aGVudGljYXRpb24gaXMgY29tcGxldGUuIFNlZSB7e0BsaW5rIEV2ZXJsaXZlLnByb3RvdHlwZS5jb21wbGV0ZUF1dGhlbnRpY2F0aW9ufX0uXHJcbiAgICAgKiBAdGhyb3dzIHRocm93cyBhbiBlcnJvciBpZiBubyBvbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQgaGFuZGxlciBpcyBwcm92aWRlZCB0byB0aGUgc2V0dXAuXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5fZW5zdXJlQXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQgb3B0aW9uIG9mIEV2ZXJsaXZlLlNldHVwLkF1dGhlbnRpY2F0aW9uIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0F1dGhlbnRpY2F0aW5nKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzLnByb21pc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNsZWFyQXV0aG9yaXphdGlvbigpO1xyXG4gICAgICAgIHRoaXMuYXV0aFNldHVwLm9uQXV0aGVudGljYXRpb25SZXF1aXJlZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzID0gdXRpbHMuZ2V0Q2FsbGJhY2tzKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzLnByb21pc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBtZXRob2QgdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGF1dGhlbnRpY2F0aW9uIHJlc3VsdC5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSBhdXRoZW50aWNhdGlvbiBhdXRoZW50aWNhdGlvbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcclxuICAgICAqIEBwYXJhbSBhdXRoZW50aWNhdGlvbi5hY2Nlc3NfdG9rZW5cclxuICAgICAqIEBwYXJhbSBhdXRoZW50aWNhdGlvbi50b2tlbl90eXBlXHJcbiAgICAgKiBAcGFyYW0gYXV0aGVudGljYXRpb24ucHJpbmNpcGFsX2lkXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5jb21wbGV0ZUF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKGF1dGhlbnRpY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fZWwuc2V0QXV0aG9yaXphdGlvbihhdXRoZW50aWNhdGlvbi5hY2Nlc3NfdG9rZW4sIGF1dGhlbnRpY2F0aW9uLnRva2VuX3R5cGUsIGF1dGhlbnRpY2F0aW9uLnByaW5jaXBhbF9pZCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIHN0YXR1cyBvZiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgZ2V0QXV0aGVudGljYXRpb25TdGF0dXNcclxuICAgICAqIEBuYW1lIGdldEF1dGhlbnRpY2F0aW9uU3RhdHVzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRvIHRoZSBhdXRoZW50aWNhdGlvbiBzdGF0dXMuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGdldEF1dGhlbnRpY2F0aW9uU3RhdHVzXHJcbiAgICAgKiBAbmFtZSBnZXRBdXRoZW50aWNhdGlvblN0YXR1c1xyXG4gICAgICogQHBhcmFtIHtFdmVybGl2ZS5DYWxsYmFja3MuYXV0aGVudGljYXRpb25TdGF0dXNTdWNjZXNzfSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmdldEF1dGhlbnRpY2F0aW9uU3RhdHVzID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB1dGlscy5idWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXR1cCA9IHNlbGYuX2VsLnNldHVwO1xyXG4gICAgICAgICAgICBpZiAoc2V0dXAubWFzdGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBjb25zdGFudHMuQXV0aFN0YXR1cy5tYXN0ZXJLZXl9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFzZXR1cC50b2tlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMudW5hdXRoZW50aWNhdGVkfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IGNvbnN0YW50cy5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0aW5nfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYuX2VsLlVzZXJzXHJcbiAgICAgICAgICAgICAgICAuc2tpcEF1dGgodHJ1ZSlcclxuICAgICAgICAgICAgICAgIC5jdXJyZW50VXNlcigpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMuYXV0aGVudGljYXRlZCwgdXNlcjogcmVzLnJlc3VsdH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMuYXV0aGVudGljYXRpbmd9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5pbnZhbGlkUmVxdWVzdC5jb2RlIHx8IGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5pbnZhbGlkVG9rZW4uY29kZSkgeyAvLyBpbnZhbGlkIHJlcXVlc3QsIGkuZS4gdGhlIGFjY2VzcyB0b2tlbiBpcyBpbnZhbGlkIG9yIG1pc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMuaW52YWxpZEF1dGhlbnRpY2F0aW9ufSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuZXhwaXJlZFRva2VuLmNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMuZXhwaXJlZEF1dGhlbnRpY2F0aW9ufSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGlzIGN1cnJlbnRseSB3YWl0aW5nIGZvciBhdXRoZW50aWNhdGlvbiB0byBiZSBjb21wbGV0ZWQuIFNlZSB7e0BsaW5rIEV2ZXJsaXZlLnByb3RvdHlwZS5jb21wbGV0ZUF1dGhlbnRpY2F0aW9ufX0uXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmlzQXV0aGVudGljYXRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYXV0aGVudGljYXRpb25DYWxsYmFja3M7XHJcbiAgICB9O1xyXG5cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5fbG9naW5TdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YS5yZXN1bHQ7XHJcbiAgICAgICAgdGhpcy5zZXRBdXRob3JpemF0aW9uKHJlc3VsdC5hY2Nlc3NfdG9rZW4sIHJlc3VsdC50b2tlbl90eXBlLCByZXN1bHQucHJpbmNpcGFsX2lkKTtcclxuICAgIH07XHJcblxyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLl9sb2dvdXRTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJBdXRob3JpemF0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5fbG9naW5XaXRoUHJvdmlkZXIgPSBmdW5jdGlvbiAoaWRlbnRpdHksIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHVzZXIgPSB7XHJcbiAgICAgICAgICAgIElkZW50aXR5OiBpZGVudGl0eVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWNjZXNzRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2xvZ2luU3VjY2Vzcy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbldpdGhQcm92aWRlcixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB1c2Vyc0NvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogdXNlcixcclxuICAgICAgICAgICAgICAgIGF1dGhIZWFkZXJzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NGdW5jLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9lbC5Vc2Vycy5wcm9jZXNzRGF0YVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBBdXRoZW50aWNhdGlvbjtcclxufSgpKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgQXV0aGVudGljYXRpb25TZXR1cCA9IGZ1bmN0aW9uIChldmVybGl2ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHRoaXMub25BdXRoZW50aWNhdGlvblJlcXVpcmVkID0gb3B0aW9ucy5vbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQ7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ID0gb3B0aW9ucy5wZXJzaXN0O1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQXV0aGVudGljYXRpb25TZXR1cDtcclxufSgpKTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIGJ1aWxkUHJvbWlzZSA9IHV0aWxzLmJ1aWxkUHJvbWlzZTtcclxudmFyIGpzb25TdHJpbmdpZnkgPSBjb21tb24uanNvblN0cmluZ2lmeTtcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcblxyXG52YXIgcGVyc2lzdGVycyA9IHJlcXVpcmUoJy4uL29mZmxpbmUvb2ZmbGluZVBlcnNpc3RlcnMnKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIFF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvUXVlcnknKTtcclxudmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L0RhdGFRdWVyeScpO1xyXG52YXIgYnVpbGRPZmZsaW5lU3RvcmFnZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9vZmZsaW5lL29mZmxpbmUnKS5idWlsZE9mZmxpbmVTdG9yYWdlT3B0aW9ucztcclxuXHJcbnZhciBDYWNoZU1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBldmVybGl2ZSkge1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIHRoaXMudHlwZVNldHRpbmdzID0gdGhpcy5vcHRpb25zLnR5cGVTZXR0aW5ncztcclxuICAgIHRoaXMubWF4QWdlSW5NcyA9IHRoaXMub3B0aW9ucy5tYXhBZ2UgKiA2MCAqIDEwMDA7XHJcbiAgICB0aGlzLl9ldmVybGl2ZSA9IGV2ZXJsaXZlO1xyXG59O1xyXG5cclxudmFyIGNhY2hlYWJsZU9wZXJhdGlvbnMgPSBbXHJcbiAgICBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkLFxyXG4gICAgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZEJ5SWQsXHJcbiAgICBEYXRhUXVlcnkub3BlcmF0aW9ucy5jb3VudFxyXG5dO1xyXG5cclxuQ2FjaGVNb2R1bGUucHJvdG90eXBlID0ge1xyXG4gICAgX2hhc2g6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4ganNvblN0cmluZ2lmeShvYmopO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2luZyB0aGUgb2ZmbGluZSBzdG9yYWdlIG9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgc2FtZSB0eXBlIG9mIHN0b3JhZ2VcclxuICAgIF9pbml0U3RvcmU6IGZ1bmN0aW9uIChzZGtPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBlcnNpc3Rlcikge1xyXG4gICAgICAgICAgICB2YXIgb2ZmbGluZVN0b3JhZ2VPcHRpb25zID0gYnVpbGRPZmZsaW5lU3RvcmFnZU9wdGlvbnMoc2RrT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlS2V5ID0gdGhpcy5vcHRpb25zLnN0b3JhZ2Uuc3RvcmFnZVBhdGg7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlciA9IHBlcnNpc3RlcnMuZ2V0UGVyc2lzdGVyKHN0b3JhZ2VLZXksIG9mZmxpbmVTdG9yYWdlT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfZ2V0Q2FjaGVEYXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVEYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZXJzaXN0ZXJHZXRBbGxEYXRhV3JhcCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2FjaGVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWNoZURhdGEgPSBjYWNoZURhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FjaGVEYXRhO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdXRpbHMuc3VjY2Vzc2Z1bFByb21pc2UodGhpcy5jYWNoZURhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcGVyc2lzdGVyR2V0QWxsRGF0YVdyYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucGVyc2lzdGVyLmdldEFsbERhdGEocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX3BlcnNpc3RlclNhdmVEYXRhV3JhcDogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucGVyc2lzdGVyLnNhdmVEYXRhKGNvbnRlbnRUeXBlLCBKU09OLnN0cmluZ2lmeShkYXRhKSwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2dldENhY2hlRGF0YUZvckNvbnRlbnRUeXBlOiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVEYXRhKClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNhY2hlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWNoZURhdGFbY29udGVudFR5cGVdID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlRGF0YVtjb250ZW50VHlwZV0gPSBKU09OLnBhcnNlKGNhY2hlRGF0YVtjb250ZW50VHlwZV0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZURhdGFbY29udGVudFR5cGVdID0gY2FjaGVEYXRhW2NvbnRlbnRUeXBlXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5jbG9uZShjYWNoZURhdGFbY29udGVudFR5cGVdKTtcclxuICAgICAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgX3BlcnNpc3RDYWNoZURhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgY2FjaGVEYXRhKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVEYXRhRm9yQ29udGVudFR5cGUoY29udGVudFR5cGUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhVG9DYWNoZSA9IF8uZXh0ZW5kKHt9LCBzZWxmLmNhY2hlRGF0YVtjb250ZW50VHlwZV0sIGNhY2hlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNhY2hlRGF0YVtjb250ZW50VHlwZV0gPSBfLmNvbXBhY3RPYmplY3QoZGF0YVRvQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3BlcnNpc3RlclNhdmVEYXRhV3JhcChjb250ZW50VHlwZSwgc2VsZi5jYWNoZURhdGFbY29udGVudFR5cGVdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzUXVlcnlVbnN1cHBvcnRlZE9mZmxpbmU6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgaGFzUG93ZXJmaWVsZHNFeHByZXNzaW9uID0gISFkYXRhUXVlcnkuZ2V0SGVhZGVyKGNvbnN0YW50cy5IZWFkZXJzLnBvd2VyRmllbGRzKTtcclxuICAgICAgICB2YXIgcXVlcnlQYXJhbXMgPSBkYXRhUXVlcnkuZ2V0UXVlcnlQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgdmFyIGRhdGFRdWVyeUZpbHRlciA9IHF1ZXJ5UGFyYW1zLmZpbHRlcjtcclxuICAgICAgICB2YXIgdW5zdXBwb3J0ZWREYk9wZXJhdG9ycyA9IHV0aWxzLmdldFVuc3VwcG9ydGVkT3BlcmF0b3JzKGRhdGFRdWVyeUZpbHRlcik7XHJcbiAgICAgICAgdmFyIGhhc1Vuc3VwcG9ydGVkT3BlcmF0b3JzID0gdW5zdXBwb3J0ZWREYk9wZXJhdG9ycy5sZW5ndGggIT09IDA7XHJcbiAgICAgICAgcmV0dXJuIGhhc1Bvd2VyZmllbGRzRXhwcmVzc2lvbiB8fCBoYXNVbnN1cHBvcnRlZE9wZXJhdG9ycztcclxuICAgIH0sXHJcblxyXG4gICAgX3Nob3VsZFNraXBDYWNoZTogZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBvcGVyYXRpb25TaG91bGRTa2lwQ2FjaGUgPSBjYWNoZWFibGVPcGVyYXRpb25zLmluZGV4T2YoZGF0YVF1ZXJ5Lm9wZXJhdGlvbikgPT09IC0xO1xyXG4gICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICB2YXIgdHlwZVNldHRpbmdzID0gdGhpcy50eXBlU2V0dGluZ3M7XHJcbiAgICAgICAgdmFyIGNhY2hlRGlzYWJsZWRGb3JDb250ZW50VHlwZSA9IHR5cGVTZXR0aW5ncyAmJiB0eXBlU2V0dGluZ3MgJiYgdHlwZVNldHRpbmdzW2NvbGxlY3Rpb25OYW1lXSAmJiB0eXBlU2V0dGluZ3NbY29sbGVjdGlvbk5hbWVdLmVuYWJsZWQgPT09IGZhbHNlO1xyXG4gICAgICAgIHZhciBpZ25vcmVDYWNoZUZvclF1ZXJ5ID0gZGF0YVF1ZXJ5Lmlnbm9yZUNhY2hlO1xyXG5cclxuICAgICAgICB2YXIgaXNVbnN1cHBvcnRlZE9mZmxpbmUgPSB0aGlzLmlzUXVlcnlVbnN1cHBvcnRlZE9mZmxpbmUoZGF0YVF1ZXJ5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvblNob3VsZFNraXBDYWNoZSB8fCBjYWNoZURpc2FibGVkRm9yQ29udGVudFR5cGUgfHwgaWdub3JlQ2FjaGVGb3JRdWVyeSB8fCBpc1Vuc3VwcG9ydGVkT2ZmbGluZTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NhY2hlRGF0YVF1ZXJ5OiBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFNraXBDYWNoZShkYXRhUXVlcnkpKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuaWdub3JlQ2FjaGUgJiYgIXRoaXMuaXNRdWVyeVVuc3VwcG9ydGVkT2ZmbGluZShkYXRhUXVlcnkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2dldEhhc2hGb3JRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVRdWVyeShkYXRhUXVlcnksIGhhc2gpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlcmxpdmUuZGF0YShkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpLl9zZW5kUmVxdWVzdChkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YVF1ZXJ5LnVzZUNhY2hlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NDYWNoZUl0ZW0oZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9wcm9jZXNzQ2FjaGVJdGVtOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgY29udGVudFR5cGUgPSBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9nZXRIYXNoRm9yUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVEYXRhRm9yQ29udGVudFR5cGUoY29udGVudFR5cGUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjYWNoZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZURhdGFbaGFzaF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5faXNIYXNoRXhwaXJlZChjb250ZW50VHlwZSwgaGFzaCwgZGF0YVF1ZXJ5Lm1heEFnZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXhwaXJlZCAmJiAhZGF0YVF1ZXJ5LmZvcmNlQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcHVyZ2VGb3JIYXNoKGNvbnRlbnRUeXBlLCBoYXNoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fY2FjaGVRdWVyeShkYXRhUXVlcnksIGhhc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2V2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLnByb2Nlc3NRdWVyeShkYXRhUXVlcnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFRdWVyeS5vblN1Y2Nlc3MocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGRhdGFRdWVyeS5vbkVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9jYWNoZVF1ZXJ5KGRhdGFRdWVyeSwgaGFzaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBfYWRkT2JqZWN0VG9DYWNoZTogZnVuY3Rpb24gKG9iaiwgY29udGVudFR5cGUsIG1heEFnZSkge1xyXG4gICAgICAgIHZhciBpdGVtSGFzaCA9IG9iai5JZDtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVSZXN1bHRGcm9tRGF0YVF1ZXJ5KGNvbnRlbnRUeXBlLCBpdGVtSGFzaCwgbWF4QWdlKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NhY2hlUXVlcnk6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGhhc2gpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xyXG5cclxuICAgICAgICB2YXIgb3JpZ2luYWxTdWNjZXNzID0gZGF0YVF1ZXJ5Lm9uU3VjY2VzcztcclxuICAgICAgICBkYXRhUXVlcnkub25TdWNjZXNzID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldENhY2hlRGF0YSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlRm9ySXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzcG9uc2UucmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVF1ZXJ5Lm9wZXJhdGlvbiAhPT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHJlc3VsdCwgZnVuY3Rpb24gKHNpbmdsZVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUl0ZW1Qcm9taXNlID0gc2VsZi5fYWRkT2JqZWN0VG9DYWNoZShzaW5nbGVSZXN1bHQsIGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVGb3JJdGVtcy5wdXNoKGNhY2hlSXRlbVByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVJdGVtUHJvbWlzZSA9IHNlbGYuX2FkZE9iamVjdFRvQ2FjaGUocmVzdWx0LCBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVGb3JJdGVtcy5wdXNoKGNhY2hlSXRlbVByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnN2cC5hbGwoY2FjaGVGb3JJdGVtcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5vcGVyYXRpb24gIT09IERhdGFRdWVyeS5vcGVyYXRpb25zLmNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2NhY2hlUmVzdWx0RnJvbURhdGFRdWVyeShjb250ZW50VHlwZSwgaGFzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFN1Y2Nlc3MuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fZXZlcmxpdmUuZGF0YShkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpLl9zZW5kUmVxdWVzdChkYXRhUXVlcnkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY2FjaGVSZXN1bHRGcm9tRGF0YVF1ZXJ5OiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGhhc2gpIHtcclxuICAgICAgICB2YXIgY2FjaGVEYXRhID0ge307XHJcbiAgICAgICAgY2FjaGVEYXRhW2hhc2hdID0ge1xyXG4gICAgICAgICAgICBjYWNoZWRBdDogRGF0ZS5ub3coKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJzaXN0Q2FjaGVEYXRhKGNvbnRlbnRUeXBlLCBjYWNoZURhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfZ2V0RXhwaXJhdGlvbkZvckhhc2g6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgaGFzaCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZURhdGFGb3JDb250ZW50VHlwZShjb250ZW50VHlwZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNhY2hlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRGF0YVtoYXNoXS5jYWNoZWRBdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9pc0hhc2hFeHBpcmVkOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGhhc2gsIG1heEFnZSkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEV4cGlyYXRpb25Gb3JIYXNoKGNvbnRlbnRUeXBlLCBoYXNoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2FjaGVkQXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXhBZ2VGb3JDb250ZW50VHlwZSA9IHNlbGYudHlwZVNldHRpbmdzICYmIHNlbGYudHlwZVNldHRpbmdzW2NvbnRlbnRUeXBlXSA/IHNlbGYudHlwZVNldHRpbmdzW2NvbnRlbnRUeXBlXS5tYXhBZ2UgKiA2MCAqIDEwMDAgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlQWdlID0gbWF4QWdlIHx8IG1heEFnZUZvckNvbnRlbnRUeXBlIHx8IHNlbGYubWF4QWdlSW5NcztcclxuICAgICAgICAgICAgICAgIHJldHVybiAoY2FjaGVkQXQgKyBjYWNoZUFnZSkgPCBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX3B1cmdlRm9ySGFzaDogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBoYXNoKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlRGF0YSA9IHt9O1xyXG4gICAgICAgIGNhY2hlRGF0YVtoYXNoXSA9IG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJzaXN0Q2FjaGVEYXRhKGNvbnRlbnRUeXBlLCBjYWNoZURhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfZ2V0SGFzaEZvclF1ZXJ5OiBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKGRhdGFRdWVyeS5vcGVyYXRpb24gPT09IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWRCeUlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcXVlcnlQYXJhbXMgPSBkYXRhUXVlcnkuZ2V0UXVlcnlQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2gocXVlcnlQYXJhbXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucGVyc2lzdGVyLnB1cmdlKGNvbnRlbnRUeXBlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5jYWNoZURhdGFbY29udGVudFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2V2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLnNldHVwLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLl9xdWVyeVByb2Nlc3Nvci5fcGVyc2lzdGVyLnB1cmdlKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGVycm9yKTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyQWxsOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi5jYWNoZURhdGEgPSBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wZXJzaXN0ZXIucHVyZ2VBbGwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2V2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLnNldHVwLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLl9xdWVyeVByb2Nlc3Nvci5fcGVyc2lzdGVyLnB1cmdlQWxsKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZXJyb3IpXHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZU1vZHVsZTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQ2FjaGVNb2R1bGUgPSByZXF1aXJlKCcuL0NhY2hlTW9kdWxlJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxuXHJcbnZhciBnZXREZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWF4QWdlOiA2MCxcclxuICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICBzdG9yYWdlOiB7XHJcbiAgICAgICAgICAgIHN0b3JhZ2VQYXRoOiAnZWxfY2FjaGUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBpbml0Q2FjaGluZzogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgY2FjaGluZ09wdGlvbnM7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0gZ2V0RGVmYXVsdE9wdGlvbnMoKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5jYWNoaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGNhY2hpbmdPcHRpb25zID0gXy5kZWVwRXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNhY2hpbmdPcHRpb25zLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhY2hpbmdPcHRpb25zID0gXy5kZWVwRXh0ZW5kKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLmNhY2hpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FjaGluZyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXR1cC5jYWNoaW5nID0gY2FjaGluZ09wdGlvbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IENhY2hlTW9kdWxlKGNhY2hpbmdPcHRpb25zLCB0aGlzKTtcclxuICAgIH0sXHJcbiAgICBfaW5pdFN0b3JlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuY2FjaGUuX2luaXRTdG9yZShvcHRpb25zKTtcclxuICAgIH1cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY29tbW9uID0ge307XHJcbiAgICB2YXIgZGVwZW5kZW5jeVN0b3JlID0ge307XHJcblxyXG4gICAgdmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xyXG4gICAgdmFyIGlzTmF0aXZlU2NyaXB0ID0gcGxhdGZvcm0uaXNOYXRpdmVTY3JpcHQ7XHJcbiAgICB2YXIgaXNOb2RlanMgPSBwbGF0Zm9ybS5pc05vZGVqcztcclxuXHJcbiAgICBpZiAoIWlzTm9kZWpzICYmICFpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgIGRlcGVuZGVuY3lTdG9yZS5yZXF3ZXN0ID0gcmVxdWlyZSgncmVxd2VzdCcpO1xyXG4gICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgIGNvbW1vbi5yb290ID0gZ2xvYmFsO1xyXG4gICAgICAgIGRlcGVuZGVuY3lTdG9yZS5yZXF3ZXN0ID0gcmVxdWlyZSgnLi9yZXF3ZXN0Lm5hdGl2ZXNjcmlwdCcpO1xyXG4gICAgfSBlbHNlIGlmIChpc05vZGVqcykge1xyXG4gICAgICAgIGNvbW1vbi5yb290ID0gZ2xvYmFsO1xyXG4gICAgICAgIGRlcGVuZGVuY3lTdG9yZS5yZXF3ZXN0ID0gcmVxdWlyZSgnLi9yZXF3ZXN0Lm5vZGVqcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tbW9uLnJvb3QpIHtcclxuICAgICAgICAvL2Jyb3dzZXIvcmVxdWlyZWpzL2NvcmRvdmFcclxuICAgICAgICBjb21tb24ucm9vdCA9IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXhwb3J0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIGV4cG9ydERlcGVuZGVuY3koZ2xvYmFsTmFtZSwgbG9jYWxOYW1lKSB7XHJcbiAgICAgICAgaWYgKCFsb2NhbE5hbWUpIHtcclxuICAgICAgICAgICAgbG9jYWxOYW1lID0gZ2xvYmFsTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZm9yIHRoZSBldmVybGl2ZSBidW5kbGUgd2l0aG91dCBkZXBlbmRlbmNpZXMgaW5jbHVkZWQsIGJyb3dzZXJpZnkgcmVwbGFjZXMgdGhlbSB3aXRoIGVtcHR5IG9iamVjdHNcclxuICAgICAgICAvL3dlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlc2UgZGVwZW5kZW5jaWVzIGFyZSBtYXJrZWQgYXMgdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKGRlcGVuZGVuY3lTdG9yZVtsb2NhbE5hbWVdICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBkZXBlbmRlbmN5U3RvcmVbbG9jYWxOYW1lXSA9PT0gJ29iamVjdCcgJiYgIU9iamVjdC5rZXlzKGRlcGVuZGVuY3lTdG9yZVtsb2NhbE5hbWVdKS5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgIGRlcGVuZGVuY3lTdG9yZVtsb2NhbE5hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbW1vbiwgbG9jYWxOYW1lLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3lTdG9yZVtsb2NhbE5hbWVdIHx8IHRoaXMucm9vdFtnbG9iYWxOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBkZXBlbmRlbmN5U3RvcmUuXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxuICAgIGV4cG9ydERlcGVuZGVuY3koJ18nKTtcclxuXHJcbiAgICBkZXBlbmRlbmN5U3RvcmUuanN0eiA9IHJlcXVpcmUoJ2pzdGltZXpvbmVkZXRlY3QnKS5qc3R6O1xyXG4gICAgZXhwb3J0RGVwZW5kZW5jeSgnanN0eicpO1xyXG5cclxuICAgIGRlcGVuZGVuY3lTdG9yZS5tb25nb1F1ZXJ5ID0gcmVxdWlyZSgnbW9uZ28tcXVlcnknKTtcclxuICAgIGV4cG9ydERlcGVuZGVuY3koJ21vbmdvUXVlcnknKTtcclxuXHJcbiAgICBkZXBlbmRlbmN5U3RvcmUuTWluZ28gPSByZXF1aXJlKCdtaW5nbycpO1xyXG4gICAgZXhwb3J0RGVwZW5kZW5jeSgnTWluZ28nKTtcclxuXHJcbiAgICBkZXBlbmRlbmN5U3RvcmUuUHJvY2Vzc29yID0gcmVxdWlyZSgnLi4vc2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yJyk7XHJcbiAgICBleHBvcnREZXBlbmRlbmN5KCdQcm9jZXNzb3InKTtcclxuXHJcbiAgICAvL2RlcGVuZGVuY3lTdG9yZS5CYXNlNjQgPSByZXF1aXJlKCdCYXNlNjQnKTtcclxuICAgIC8vZXhwb3J0RGVwZW5kZW5jeSgnQmFzZTY0Jyk7XHJcblxyXG4gICAgZGVwZW5kZW5jeVN0b3JlLnJzdnAgPSByZXF1aXJlKCdyc3ZwJyk7XHJcbiAgICBleHBvcnREZXBlbmRlbmN5KCdSU1ZQJywgJ3JzdnAnKTtcclxuXHJcbiAgICBleHBvcnREZXBlbmRlbmN5KCdyZXF3ZXN0Jyk7XHJcblxyXG4gICAgZGVwZW5kZW5jeVN0b3JlLmpzb25TdHJpbmdpZnkgPSByZXF1aXJlKCdqc29uLXN0YWJsZS1zdHJpbmdpZnknKTtcclxuICAgIGV4cG9ydERlcGVuZGVuY3koJ2pzb24tc3RhYmxlLXN0cmluZ2lmeScsICdqc29uU3RyaW5naWZ5Jyk7XHJcblxyXG4gICAgcmV0dXJuIGNvbW1vbjtcclxufSgpKTsiLCIvKipcclxuICogQ29uc3RhbnRzIHVzZWQgYnkgdGhlIFNES1xyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVybGl2ZS5Db25zdGFudHNcclxuICovXHJcblxyXG52YXIgY29uc3RhbnRzID0ge1xyXG4gICAgaWRGaWVsZDogJ0lkJyxcclxuICAgIGd1aWRFbXB0eTogJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCcsXHJcbiAgICBldmVybGl2ZVVybDogJy8vYXBpLmV2ZXJsaXZlLmNvbS92MS8nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNsYXNzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBjb25mbGljdCByZXNvbHV0aW9uIHN0cmF0ZWdpZXMuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gQ2xpZW50V2luc1xyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFNlcnZlcldpbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDdXN0b21cclxuICAgICAqIEB0eXBlZGVmIHtzdHJpbmd9IEV2ZXJsaXZlLkNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneVxyXG4gICAgICovXHJcbiAgICBDb25mbGljdFJlc29sdXRpb25TdHJhdGVneToge1xyXG4gICAgICAgIENsaWVudFdpbnM6ICdjbGllbnRXaW5zJyxcclxuICAgICAgICBTZXJ2ZXJXaW5zOiAnc2VydmVyV2lucycsXHJcbiAgICAgICAgQ3VzdG9tOiAnY3VzdG9tJ1xyXG4gICAgfSxcclxuICAgIENvbmZsaWN0UmVzb2x1dGlvbjoge1xyXG4gICAgICAgIEtlZXBTZXJ2ZXI6ICdrZWVwU2VydmVyJyxcclxuICAgICAgICBLZWVwQ2xpZW50OiAna2VlcENsaWVudCcsXHJcbiAgICAgICAgQ3VzdG9tOiAnY3VzdG9tJyxcclxuICAgICAgICBTa2lwOiAnc2tpcCdcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEEgY2xhc3MgdXNlZCB0byByZXByZXNlbnQgdGhlIGF2YWlsYWJsZSBzdG9yYWdlIHByb3ZpZGVycy5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBMb2NhbFN0b3JhZ2VcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBGaWxlU3lzdGVtXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gQ3VzdG9tXHJcbiAgICAgKiBAdHlwZWRlZiB7c3RyaW5nfSBFdmVybGl2ZS5Db25zdGFudHMuU3RvcmFnZVByb3ZpZGVyXHJcbiAgICAgKi9cclxuICAgIFN0b3JhZ2VQcm92aWRlcjoge1xyXG4gICAgICAgIExvY2FsU3RvcmFnZTogJ2xvY2FsU3RvcmFnZScsXHJcbiAgICAgICAgRmlsZVN5c3RlbTogJ2ZpbGVTeXN0ZW0nLFxyXG4gICAgICAgIEN1c3RvbTogJ2N1c3RvbSdcclxuICAgIH0sXHJcblxyXG4gICAgRGVmYXVsdFN0b3JhZ2VQYXRoOiAnZWxfc3RvcmUnLFxyXG5cclxuICAgIC8vIHRoZSBkZWZhdWx0IGxvY2F0aW9uIGZvciBzdG9yaW5nIGZpbGVzIG9mZmxpbmVcclxuICAgIERlZmF1bHRGaWxlc1N0b3JhZ2VQYXRoOiAnZWxfZmlsZV9zdG9yZScsXHJcblxyXG4gICAgLy8gdGhlIGRlZmF1bHQgbG9jYXRpb24gZm9yIHN0b3Jpbmcgb2ZmbGluZSB0byBvbmxpbmUgbG9jYXRpb24gbWFwXHJcbiAgICBEZWZhdWx0RmlsZXNNZXRhZGF0YVBhdGg6ICdlbF9maWxlX21hcHBpbmcnLFxyXG5cclxuICAgIEVuY3J5cHRpb25Qcm92aWRlcjoge1xyXG4gICAgICAgIERlZmF1bHQ6ICdkZWZhdWx0JyxcclxuICAgICAgICBDdXN0b206ICdjdXN0b20nXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRoZSBoZWFkZXJzIHVzZWQgYnkgdGhlIEV2ZXJsaXZlIHNlcnZpY2VzXHJcbiAgICBIZWFkZXJzOiB7XHJcbiAgICAgICAgZmlsdGVyOiAnWC1FdmVybGl2ZS1GaWx0ZXInLFxyXG4gICAgICAgIHNlbGVjdDogJ1gtRXZlcmxpdmUtRmllbGRzJyxcclxuICAgICAgICBzb3J0OiAnWC1FdmVybGl2ZS1Tb3J0JyxcclxuICAgICAgICBza2lwOiAnWC1FdmVybGl2ZS1Ta2lwJyxcclxuICAgICAgICB0YWtlOiAnWC1FdmVybGl2ZS1UYWtlJyxcclxuICAgICAgICBleHBhbmQ6ICdYLUV2ZXJsaXZlLUV4cGFuZCcsXHJcbiAgICAgICAgc2luZ2xlRmllbGQ6ICdYLUV2ZXJsaXZlLVNpbmdsZS1GaWVsZCcsXHJcbiAgICAgICAgaW5jbHVkZUNvdW50OiAnWC1FdmVybGl2ZS1JbmNsdWRlLUNvdW50JyxcclxuICAgICAgICBwb3dlckZpZWxkczogJ1gtRXZlcmxpdmUtUG93ZXItRmllbGRzJyxcclxuICAgICAgICBkZWJ1ZzogJ1gtRXZlcmxpdmUtRGVidWcnLFxyXG4gICAgICAgIG92ZXJyaWRlU3lzdGVtRmllbGRzOiAnWC1FdmVybGl2ZS1PdmVycmlkZS1TeXN0ZW0tRmllbGRzJyxcclxuICAgICAgICBzZGs6ICdYLUV2ZXJsaXZlLVNkaycsXHJcbiAgICAgICAgc3luYzogJ1gtRXZlcmxpdmUtU3luYydcclxuICAgIH0sXHJcbiAgICAvL0NvbnN0YW50cyBmb3IgZGlmZmVyZW50IHBsYXRmb3JtcyBpbiBFdmVybGl2ZVxyXG4gICAgUGxhdGZvcm06IHtcclxuICAgICAgICBXaW5kb3dzUGhvbmU6IDEsXHJcbiAgICAgICAgV2luZG93czogMixcclxuICAgICAgICBBbmRyb2lkOiAzLFxyXG4gICAgICAgIGlPUzogNCxcclxuICAgICAgICBPU1g6IDUsXHJcbiAgICAgICAgQmxhY2tiZXJyeTogNixcclxuICAgICAgICBOb2tpYTogNyxcclxuICAgICAgICBVbmtub3duOiAxMDBcclxuICAgIH0sXHJcbiAgICBPcGVyYXRvclR5cGU6IHtcclxuICAgICAgICBxdWVyeTogMSxcclxuXHJcbiAgICAgICAgd2hlcmU6IDEwMCxcclxuICAgICAgICBmaWx0ZXI6IDEwMSxcclxuXHJcbiAgICAgICAgYW5kOiAxMTAsXHJcbiAgICAgICAgb3I6IDExMSxcclxuICAgICAgICBub3Q6IDExMixcclxuXHJcbiAgICAgICAgZXF1YWw6IDEyMCxcclxuICAgICAgICBub3RfZXF1YWw6IDEyMSxcclxuICAgICAgICBsdDogMTIyLFxyXG4gICAgICAgIGx0ZTogMTIzLFxyXG4gICAgICAgIGd0OiAxMjQsXHJcbiAgICAgICAgZ3RlOiAxMjUsXHJcbiAgICAgICAgaXNpbjogMTI2LFxyXG4gICAgICAgIG5vdGluOiAxMjcsXHJcbiAgICAgICAgYWxsOiAxMjgsXHJcbiAgICAgICAgc2l6ZTogMTI5LFxyXG4gICAgICAgIHJlZ2V4OiAxMzAsXHJcbiAgICAgICAgY29udGFpbnM6IDEzMSxcclxuICAgICAgICBzdGFydHNXaXRoOiAxMzIsXHJcbiAgICAgICAgZW5kc1dpdGg6IDEzMyxcclxuXHJcbiAgICAgICAgbmVhclNocGVyZTogMTQwLFxyXG4gICAgICAgIHdpdGhpbkJveDogMTQxLFxyXG4gICAgICAgIHdpdGhpblBvbHlnb246IDE0MixcclxuICAgICAgICB3aXRoaW5TaHBlcmU6IDE0MyxcclxuXHJcbiAgICAgICAgc2VsZWN0OiAyMDAsXHJcbiAgICAgICAgZXhjbHVkZTogMjAxLFxyXG5cclxuICAgICAgICBvcmRlcjogMzAwLFxyXG4gICAgICAgIG9yZGVyX2Rlc2M6IDMwMSxcclxuXHJcbiAgICAgICAgc2tpcDogNDAwLFxyXG4gICAgICAgIHRha2U6IDQwMSxcclxuICAgICAgICBleHBhbmQ6IDQwMlxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2xhc3MgdXNlZCB0byByZXByZXNlbnQgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gc3RhdHVzIG9mIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLlxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHVuYXV0aGVudGljYXRlZCBJbmRpY2F0ZXMgdGhhdCBubyB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWFzdGVyS2V5IEluZGljYXRlcyB0aGF0IGEgbWFzdGVyIGtleSBhdXRoZW50aWNhdGlvbiBpcyB1c2VkLlxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGludmFsaWRBdXRoZW50aWNhdGlvbiBJbmRpY2F0ZXMgYW4gYXV0aGVudGljYXRpb24gaGFzIGJlZW4gYXR0ZW1wdGVkLCBidXQgaXQgd2FzIGludmFsaWQuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYXV0aGVudGljYXRlZCBJbmRpY2F0ZXMgdGhhdCBhIHVzZXIgaXMgYXV0aGVudGljYXRlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXRoZW50aWNhdGluZyBJbmRpY2F0ZXMgdGhhdCBhIHVzZXIgaXMgY3VycmVudGx5IGF1dGhlbnRpY2F0aW5nLiBTb21lIHJlcXVlc3RzIG1pZ2h0IGJlIHBlbmRpbmcgYW5kIHdhaXRpbmcgZm9yIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHBpcmVkQXV0aGVudGljYXRpb24gSW5kaWNhdGVzIHRoYXQgYSB1c2VyJ3MgYXV0aGVudGljYXRpb24gaGFzIGV4cGlyZWQgYW5kIHRoYXQgdGhlIHVzZXIgbXVzdCBsb2cgYmFjayBpbi5cclxuICAgICAqIEB0eXBlZGVmIHtzdHJpbmd9IEV2ZXJsaXZlLkF1dGhTdGF0dXNcclxuICAgICAqL1xyXG4gICAgQXV0aFN0YXR1czoge1xyXG4gICAgICAgIHVuYXV0aGVudGljYXRlZDogJ3VuYXV0aGVudGljYXRlZCcsXHJcbiAgICAgICAgbWFzdGVyS2V5OiAnbWFzdGVyS2V5JyxcclxuICAgICAgICBpbnZhbGlkQXV0aGVudGljYXRpb246ICdpbnZhbGlkQXV0aGVudGljYXRpb24nLFxyXG4gICAgICAgIGF1dGhlbnRpY2F0ZWQ6ICdhdXRoZW50aWNhdGVkJyxcclxuICAgICAgICBleHBpcmVkQXV0aGVudGljYXRpb246ICdleHBpcmVkQXV0aGVudGljYXRpb24nLFxyXG4gICAgICAgIGF1dGhlbnRpY2F0aW5nOiAnYXV0aGVudGljYXRpbmcnXHJcbiAgICB9LFxyXG4gICAgb2ZmbGluZUl0ZW1TdGF0ZXM6IHtcclxuICAgICAgICBjcmVhdGVkOiAnY3JlYXRlJyxcclxuICAgICAgICBtb2RpZmllZDogJ3VwZGF0ZScsXHJcbiAgICAgICAgZGVsZXRlZDogJ2RlbGV0ZSdcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIVFRQIE1ldGhvZHNcclxuICAgICAqIEBlbnVtIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIEh0dHBNZXRob2Q6IHtcclxuICAgICAgICBHRVQ6ICdHRVQnLFxyXG4gICAgICAgIFBPU1Q6ICdQT1NUJyxcclxuICAgICAgICBQVVQ6ICdQVVQnLFxyXG4gICAgICAgIERFTEVURTogJ0RFTEVURSdcclxuICAgIH0sXHJcbiAgICBtYXhEaXN0YW5jZUNvbnN0czoge1xyXG4gICAgICAgIHJhZGlhbnM6ICckbWF4RGlzdGFuY2UnLFxyXG4gICAgICAgIGttOiAnJG1heERpc3RhbmNlSW5LaWxvbWV0ZXJzJyxcclxuICAgICAgICBtaWxlczogJyRtYXhEaXN0YW5jZUluTWlsZXMnXHJcbiAgICB9LFxyXG4gICAgcmFkaXVzQ29uc3RzOiB7XHJcbiAgICAgICAgcmFkaWFuczogJ3JhZGl1cycsXHJcbiAgICAgICAga206ICdyYWRpdXNJbktpbG9tZXRlcnMnLFxyXG4gICAgICAgIG1pbGVzOiAncmFkaXVzSW5NaWxlcydcclxuICAgIH1cclxufTtcclxuXHJcbi8vIHVzaW5nIGFuIGludmFsaWQgZmllbGQgbmFtZSBpbiB0aGUgY29udGV4dCBvZiBFdmVybGl2ZVxyXG4vLyB0byBlbnN1cmUgbm8gbmFtaW5nIGNvbGxpc2lvbnMgY2FuIG9jY3VyXHJcbmNvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlciA9ICdfX2V2ZXJsaXZlX29mZmxpbmVfc3RhdGUnO1xyXG5cclxuY29uc3RhbnRzLlN5bmNFcnJvcnMgPSB7XHJcbiAgICBnZW5lcmFsRXJyb3I6ICdnZW5lcmFsRXJyb3InLFxyXG4gICAgaXRlbVN5bmNFcnJvcjogJ2l0ZW1TeW5jRXJyb3InXHJcbn07XHJcblxyXG5jb25zdGFudHMuc3luY0JhdGNoU2l6ZSA9IDEwO1xyXG5cclxuY29uc3RhbnRzLkF1dGhTdG9yZUtleSA9ICdfX2V2ZXJsaXZlX2F1dGhfa2V5JztcclxuXHJcbmNvbnN0YW50cy5DYWNoaW5nU3RvcmVLZXkgPSAnX19ldmVybGl2ZV9jYWNoZSc7XHJcblxyXG4vLyB0aGUgbWluaW11bSBpbnRlcnZhbCBiZXR3ZWVuIHN5bmMgcmVxdWVzdHNcclxuY29uc3RhbnRzLmRlZmF1bHRTeW5jSW50ZXJ2YWwgPSAxMDAwICogNjAgKiAxMDsgLy8gMTAgbWludXRlc1xyXG5jb25zdGFudHMuZmlsZVVwbG9hZEtleSA9ICdmaWxlVXBsb2FkJztcclxuY29uc3RhbnRzLmZpbGVVcGxvYWREZWxpbWl0ZXIgPSAnXyc7XHJcblxyXG5jb25zdGFudHMuRmlsZXNUeXBlTmFtZUxlZ2FjeSA9ICdzeXN0ZW0uZmlsZXMnO1xyXG5jb25zdGFudHMuRmlsZXNUeXBlTmFtZSA9ICdGaWxlcyc7XHJcblxyXG5jb25zdGFudHMuTWF4Q29uY3VycmVudERvd25sb2FkVGFza3MgPSAzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudHM7XHJcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJ25vZGUtY3J5cHRvanMtYWVzJykuQ3J5cHRvSlM7XHJcbnZhciBBRVMgPSBDcnlwdG9KUy5BRVM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gQ3J5cHRvZ3JhcGhpY1Byb3ZpZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIENyeXB0b2dyYXBoaWNQcm92aWRlci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX2dldEtleTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmVuY3J5cHRpb24ua2V5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9jYW5FbmNyeXB0RGVjcnlwdDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEtleSgpICYmIGNvbnRlbnQgIT09IG51bGwgJiYgY29udGVudCAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FuRW5jcnlwdERlY3J5cHQoY29udGVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQUVTLmVuY3J5cHQoY29udGVudCwgdGhpcy5fZ2V0S2V5KCkpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5FbmNyeXB0RGVjcnlwdChjb250ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBBRVMuZGVjcnlwdChjb250ZW50LCB0aGlzLl9nZXRLZXkoKSkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIENyeXB0b2dyYXBoaWNQcm92aWRlcjtcclxufSgpKTsiLCJ2YXIgaXNOYXRpdmVTY3JpcHQgPSBCb29sZWFuKCgodHlwZW9mIGFuZHJvaWQgIT09ICd1bmRlZmluZWQnICYmIGFuZHJvaWQgJiYgYW5kcm9pZC53aWRnZXQgJiYgYW5kcm9pZC53aWRnZXQuQnV0dG9uKVxyXG58fCAodHlwZW9mIFVJQnV0dG9uICE9PSAndW5kZWZpbmVkJyAmJiBVSUJ1dHRvbikpKTtcclxuXHJcbnZhciBwbGF0Zm9ybTtcclxudmFyIGlzQ29yZG92YSA9IGZhbHNlO1xyXG52YXIgaXNXaW5kb3dzUGhvbmUgPSBmYWxzZTtcclxudmFyIGlzQW5kcm9pZCA9IGZhbHNlO1xyXG5cclxuaWYgKGlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICBnbG9iYWwud2luZG93ID0ge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZToge1xyXG4gICAgICAgICAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIH0gLy9zaGltIGZvciBtb25nby1xdWVyeSB1bmRlciBuYXRpdmVzY3JpcHRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgaXNDb3Jkb3ZhID0gL15maWxlOlxcL3szfVteXFwvXXx4LXdtYXBwL2kudGVzdCh3aW5kb3cubG9jYXRpb24uaHJlZikgJiYgL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8aWVtb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gICAgaXNXaW5kb3dzUGhvbmUgPSBpc0NvcmRvdmEgJiYgL2llbW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICAgIGlzQW5kcm9pZCA9IGlzQ29yZG92YSAmJiBjb3Jkb3ZhLnBsYXRmb3JtSWQgPT09ICdhbmRyb2lkJztcclxufVxyXG5cclxudmFyIGlzTm9kZWpzID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xyXG52YXIgaXNSZXF1aXJlanMgPSB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQ7XHJcbnZhciBpc0Rlc2t0b3AgPSAhaXNOYXRpdmVTY3JpcHQgJiYgIWlzQ29yZG92YSAmJiAhaXNOb2RlanM7XHJcblxyXG5pZiAoaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgIHBsYXRmb3JtID0gJ25zJztcclxufSBlbHNlIGlmIChpc05vZGVqcykge1xyXG4gICAgcGxhdGZvcm0gPSAnbm9kZWpzJztcclxufSBlbHNlIGlmIChpc0Rlc2t0b3ApIHtcclxuICAgIHBsYXRmb3JtID0gJ2Rlc2t0b3AnO1xyXG59IGVsc2UgaWYgKGlzQ29yZG92YSkge1xyXG4gICAgcGxhdGZvcm0gPSAnY29yZG92YSc7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgaXNDb3Jkb3ZhOiBpc0NvcmRvdmEsXHJcbiAgICBpc05hdGl2ZVNjcmlwdDogaXNOYXRpdmVTY3JpcHQsXHJcbiAgICBpc0Rlc2t0b3A6IGlzRGVza3RvcCxcclxuICAgIGlzV2luZG93c1Bob25lOiBpc1dpbmRvd3NQaG9uZSxcclxuICAgIGlzQW5kcm9pZDogaXNBbmRyb2lkLFxyXG4gICAgaXNOb2RlanM6IGlzTm9kZWpzLFxyXG4gICAgaXNSZXF1aXJlanM6IGlzUmVxdWlyZWpzLFxyXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtXHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBIZWxwZXJzXHJcbiAqIEBjbGFzc2Rlc2MgRXZlcmxpdmUgaGVscGVyIGNsYXNzZXNcclxuICovXHJcblxyXG52YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xyXG5cclxudmFyIGhlbHBlcnMgPSBbXTtcclxuXHJcbnZhciBodG1sSGVscGVyID0gcmVxdWlyZSgnLi9odG1sL2h0bWxIZWxwZXInKTtcclxuXHJcbmlmIChwbGF0Zm9ybS5pc0NvcmRvdmEgfHwgcGxhdGZvcm0uaXNEZXNrdG9wKSB7XHJcbiAgICBoZWxwZXJzLnB1c2goe1xyXG4gICAgICAgIG5hbWU6ICdodG1sJyxcclxuICAgICAgICBjdG9yOiBodG1sSGVscGVyXHJcbiAgICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBoZWxwZXJzOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoJy4uLy4uL2V2ZXJsaXZlLnBsYXRmb3JtJyk7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24nKTtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIEh0bWxIZWxwZXJSZXNwb25zaXZlTW9kdWxlID0gcmVxdWlyZSgnLi9odG1sSGVscGVyUmVzcG9uc2l2ZU1vZHVsZScpO1xyXG52YXIgSHRtbEhlbHBlck9mZmxpbmVNb2R1bGUgPSByZXF1aXJlKCcuL2h0bWxIZWxwZXJPZmZsaW5lTW9kdWxlJyk7XHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMnKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIEV2ZW50RW1pdHRlclByb3h5ID0gcmVxdWlyZSgnLi4vLi4vRXZlbnRFbWl0dGVyUHJveHknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBkZWZhdWx0cyA9IHtcclxuICAgICAgICBwcm9jZXNzT25Mb2FkOiBmYWxzZSxcclxuICAgICAgICBwcm9jZXNzT25SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgIGxvYWRpbmdJbWFnZVVybDogJycsXHJcbiAgICAgICAgZXJyb3JJbWFnZVVybDogJycsXHJcbiAgICAgICAgYXR0cmlidXRlczoge1xyXG4gICAgICAgICAgICBsb2FkaW5nSW1hZ2U6ICdkYXRhLWxvYWRpbmctaW1hZ2UnLFxyXG4gICAgICAgICAgICBlcnJvckltYWdlOiAnZGF0YS1lcnJvci1pbWFnZScsXHJcbiAgICAgICAgICAgIGRwaTogJ2RhdGEtZHBpJyxcclxuICAgICAgICAgICAgaW1hZ2VTb3VyY2U6ICdkYXRhLXNyYycsXHJcbiAgICAgICAgICAgIGZpbGVTb3VyY2U6ICdkYXRhLWhyZWYnLFxyXG4gICAgICAgICAgICBlbmFibGVPZmZsaW5lOiAnZGF0YS1vZmZsaW5lJyxcclxuICAgICAgICAgICAgZW5hYmxlUmVzcG9uc2l2ZTogJ2RhdGEtcmVzcG9uc2l2ZSdcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGVkZWYgSGVscGVycy5odG1sXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gRXZlcmxpdmUgaGVscGVyIGZvciBodG1sIHJlbGF0ZWQgb3BlcmF0aW9ucywgc3VjaCBhcyBwcm9jZXNzaW5nIGh0bWwgZWxlbWVudHMgd2l0aCBzcGVjaWZpYyB0YWdzLlxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gSHRtbEhlbHBlcihldmVybGl2ZSwgY29uZmlnKSB7XHJcbiAgICAgICAgRXZlbnRFbWl0dGVyUHJveHkuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuX2V2ZXJsaXZlID0gZXZlcmxpdmU7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgIHVybFRlbXBsYXRlOiAnW3Byb3RvY29sXVtob3N0bmFtZV1bYXBpa2V5XS9bb3BlcmF0aW9uc11bdXJsXScsXHJcbiAgICAgICAgICAgIHNlcnZlcjogJ2JzMS5jZG4udGVsZXJpay5jb20vaW1hZ2UvdjEvJ1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe30sIGRlZmF1bHRzLCBjb25maWcpO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzID0gXy5leHRlbmQoe30sIGRlZmF1bHRzLmF0dHJpYnV0ZXMsIGNvbmZpZy5hdHRyaWJ1dGVzKTtcclxuXHJcbiAgICAgICAgdGhpcy5fcmVzcG9uc2l2ZSA9IG5ldyBIdG1sSGVscGVyUmVzcG9uc2l2ZU1vZHVsZSh0aGlzKTtcclxuICAgICAgICB0aGlzLl9vZmZsaW5lID0gbmV3IEh0bWxIZWxwZXJPZmZsaW5lTW9kdWxlKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLl9pbml0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgSHRtbEhlbHBlci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX2luaXQ6IGZ1bmN0aW9uIF9pbml0KCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMucHJvY2Vzc09uTG9hZCkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnByb2Nlc3NBbGwuYmluZCh0aGlzKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb2Nlc3NPblJlc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIF8uZGVib3VuY2UodGhpcy5wcm9jZXNzQWxsLmJpbmQodGhpcyksIDMwMCksIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF90cmlnZ2VyT25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIF90cmlnZ2VyT25Qcm9jZXNzZWQoYXJncykge1xyXG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmVtaXQoJ3Byb2Nlc3NlZCcsIGFyZ3MpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kZWZhdWx0UHJvY2Vzc1NldHRpbmdzOiBmdW5jdGlvbiBfZGVmYXVsdFByb2Nlc3NTZXR0aW5ncyhzZXR0aW5ncykge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvZmZsaW5lOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9zZXRMb2FkaW5nVXJsOiBmdW5jdGlvbiBfc2V0TG9hZGluZ1VybChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBsb2FkaW5nSW1hZ2VVcmkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmlidXRlcy5sb2FkaW5nSW1hZ2UpIHx8IHRoaXMub3B0aW9ucy5sb2FkaW5nSW1hZ2VVcmw7XHJcbiAgICAgICAgICAgIGlmICghbG9hZGluZ0ltYWdlVXJpIHx8IHV0aWxzLmlzRWxlbWVudC5hbmNob3IoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5zdWNjZXNzZnVsUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0VXJsKGVsZW1lbnQsIGxvYWRpbmdJbWFnZVVyaSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldEJhY2tncm91bmRTcmM6IGZ1bmN0aW9uIF9nZXRCYWNrZ3JvdW5kU3JjKGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgYmFja2dySW1hZ2UgPSBlbFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JhY2tncm91bmQtaW1hZ2UnKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbWcgPSBiYWNrZ3JJbWFnZSAhPT0gJ25vbmUnID8gYmFja2dySW1hZ2UgOiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGltZykge1xyXG4gICAgICAgICAgICAgICAgaW1nID0gaW1nLnJlcGxhY2UoL3VybFxcKCgnP1wiPykoLio/KVxcMVxcKS9naSwgJyQyJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbWc7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldEVycm9yVXJsOiBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JJbWFnZVVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLmVycm9ySW1hZ2UpIHx8IHRoaXMub3B0aW9ucy5lcnJvckltYWdlVXJsO1xyXG4gICAgICAgICAgICBpZiAoIWVycm9ySW1hZ2VVcmwgfHwgdXRpbHMuaXNFbGVtZW50LmFuY2hvcihlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnN1Y2Nlc3NmdWxQcm9taXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRVcmwoZWxlbWVudCwgZXJyb3JJbWFnZVVybCwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldFVybDogZnVuY3Rpb24gX3NldFVybChlbGVtZW50LCB1cmwsIGFwcGx5KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsQXR0ciA9IHNlbGYuX2dldEF0dHIoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNFbGVtZW50LmltYWdlKGVsZW1lbnQpICYmIGVsQXR0ciA9PT0gc2VsZi5vcHRpb25zLmF0dHJpYnV0ZXMuaW1hZ2VTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXBwbHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IoJ0NhblxcJ3QgYmUgbG9hZGVkOiAnICsgdXJsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NldFVybChlbGVtZW50LCB1cmwsIHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhcHBseSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsQXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsQXR0ciA9PT0gc2VsZi5vcHRpb25zLmF0dHJpYnV0ZXMuaW1hZ2VTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSAnc3JjJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbEF0dHIgPT09IHNlbGYub3B0aW9ucy5hdHRyaWJ1dGVzLmZpbGVTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSAnaHJlZic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gXy5sYXN0KGVsQXR0ci5zcGxpdCgnLScpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJyArIHVybCArICcpJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0QXR0cjogZnVuY3Rpb24gX2dldEF0dHIoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXMuaW1hZ2VTb3VyY2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXMuaW1hZ2VTb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmlidXRlcy5maWxlU291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLmZpbGVTb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0VXJsOiBmdW5jdGlvbiBfZ2V0VXJsKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIHVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLmltYWdlU291cmNlKVxyXG4gICAgICAgICAgICAgICAgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXMuZmlsZVNvdXJjZSlcclxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2dldEJhY2tncm91bmRTcmMoZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF93cmFwRWxlbWVudHM6IGZ1bmN0aW9uIF93cmFwRWxlbWVudHMoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBfLm1hcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZXZhbHVhdGVEYXRhQXR0ciA9IGZ1bmN0aW9uIGV2YWx1YXRlRGF0YUF0dHIoYXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGEtYSAtIHRydWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhLWE9XCJcIiAtIHRydWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhLWE9XCJ0cnVlXCIgLSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YS1hPVwiYW55dGhpbmdcIiAtIHRydWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhLWE9XCJmYWxzZVwiIC0gZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBtaXNzaW5nIC0gZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVmFsID0gKGVsZW1lbnQuYXR0cmlidXRlc1thdHRyXSB8fCB7dmFsdWU6IG51bGx9KS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZhbCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFkYXRhVmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBKU09OLnBhcnNlKGRhdGFWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2FuUmVzcG9uc2l2ZSA9IGV2YWx1YXRlRGF0YUF0dHIoc2VsZi5vcHRpb25zLmF0dHJpYnV0ZXMuZW5hYmxlUmVzcG9uc2l2ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FuT2ZmbGluZSA9IGV2YWx1YXRlRGF0YUF0dHIoc2VsZi5vcHRpb25zLmF0dHJpYnV0ZXMuZW5hYmxlT2ZmbGluZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtOiBlbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHRhZzogdGFnLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2l2ZTogY2FuUmVzcG9uc2l2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmbGluZTogY2FuT2ZmbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBwcm9jZXNzXHJcbiAgICAgICAgICogQG1lbWJlck9mIEhlbHBlcnMuaHRtbFxyXG4gICAgICAgICAqIEBwYXJhbSB7SHRtbEVsZW1lbnR8SHRtbEVsZW1lbnRbXX0gZWxlbWVudHNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgQSBzZXR0aW5ncyBzcGVjaWZ5aW5nIGN1c3RvbSBiZWhhdmlvci5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXR0aW5ncy5yZXNwb25zaXZlXSBXaGV0aGVyIHRvIHByb2Nlc3MgdGhlIGRhdGEtcmVzcG9uc2l2ZSBhdHRyaWJ1dGVzIHRoYXQgaGVscCBpbXBsZW1lbnQgUmVzcG9uc2l2ZSBJbWFnZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2V0dGluZ3Mub2ZmbGluZV0gV2hldGhlciB0byBwcm9jZXNzIHRoZSBkYXRhLW9mZmxpbmUgYXR0cmlidXRlcyB0aGF0IGhlbHAgaW1wbGVtZW50IG9mZmxpbmUgZmlsZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWV0aG9kIHByb2Nlc3NcclxuICAgICAgICAgKiBAbWVtYmVyT2YgSGVscGVycy5odG1sXHJcbiAgICAgICAgICogQHBhcmFtIHtIdG1sRWxlbWVudHxIdG1sRWxlbWVudFtdfSBlbGVtZW50c1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyBBIHNldHRpbmdzIHNwZWNpZnlpbmcgY3VzdG9tIGJlaGF2aW9yLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldHRpbmdzLnJlc3BvbnNpdmVdIFdoZXRoZXIgdG8gcHJvY2VzcyB0aGUgZGF0YS1yZXNwb25zaXZlIGF0dHJpYnV0ZXMgdGhhdCBoZWxwIGltcGxlbWVudCBSZXNwb25zaXZlIEltYWdlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXR0aW5ncy5vZmZsaW5lXSBXaGV0aGVyIHRvIHByb2Nlc3MgdGhlIGRhdGEtb2ZmbGluZSBhdHRyaWJ1dGVzIHRoYXQgaGVscCBpbXBsZW1lbnQgb2ZmbGluZSBmaWxlcy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRvIHRoZSBwcm9jZXNzIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoZWxlbWVudHMsIHNldHRpbmdzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9IHNlbGYuX2RlZmF1bHRQcm9jZXNzU2V0dGluZ3Moc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheShlbGVtZW50cykgfHwgZWxlbWVudHMgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBlbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IF8uZmxhdHRlbihlbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZEVsZW1lbnRzID0gc2VsZi5fd3JhcEVsZW1lbnRzKGVsZW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKHdyYXBwZWRFbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50Lml0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZsaW5lOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVXJsID0gc2VsZi5fZ2V0VXJsKHJlc3VsdC5lbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhVXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlcy5wdXNoKHV0aWxzLnN1Y2Nlc3NmdWxQcm9taXNlKHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhblJlc3BvbnNpdmUgPSBzZXR0aW5ncy5yZXNwb25zaXZlID8gZWxlbWVudC5vcGVyYXRpb25zLnJlc3BvbnNpdmUgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FuT2ZmbGluZSA9IHNldHRpbmdzLm9mZmxpbmUgPyBlbGVtZW50Lm9wZXJhdGlvbnMub2ZmbGluZSA6IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhblJlc3BvbnNpdmUgJiYgIWNhbk9mZmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzLnB1c2goc2VsZi5fc2V0VXJsKHJlc3VsdC5lbGVtZW50LCBkYXRhVXJsLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuX3NldExvYWRpbmdVcmwocmVzdWx0LmVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVPcGVyYXRpb24gPSBmdW5jdGlvbiBoYW5kbGVPcGVyYXRpb24ob3BlcmF0aW9uLCB1cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W29wZXJhdGlvbl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5SZXNwb25zaXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3Jlc3BvbnNpdmUucmVzcG9uc2l2ZUltYWdlKGVsZW1lbnQsIGRhdGFVcmwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oaGFuZGxlT3BlcmF0aW9uLmJpbmQodGhpcywgJ3Jlc3BvbnNpdmUnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbk9mZmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzcG9uc2l2ZVNyYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29mZmxpbmUucHJvY2Vzc09mZmxpbmUocmVzcG9uc2l2ZVNyYyB8fCBkYXRhVXJsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGhhbmRsZU9wZXJhdGlvbi5iaW5kKHRoaXMsICdvZmZsaW5lJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGZpbmFsVXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9zZXRVcmwocmVzdWx0LmVsZW1lbnQsIGZpbmFsVXJsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9zZXRFcnJvclVybChyZXN1bHQuZWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHJlc3VsdC5lbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByc3ZwLmFsbFNldHRsZWQocHJvbWlzZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbGVkID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2gocmVzdWx0cywgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gJ2Z1bGZpbGxlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChyZXN1bHQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWQucHVzaChyZXN1bHQucmVhc29uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkOiBwcm9jZXNzZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWQ6IGZhaWxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJpZ2dlck9uUHJvY2Vzc2VkKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZXRob2QgcHJvY2Vzc0FsbFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBIZWxwZXJzLmh0bWxcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgQSBzZXR0aW5ncyBzcGVjaWZ5aW5nIGN1c3RvbSBiZWhhdmlvci5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXR0aW5ncy5yZXNwb25zaXZlXSBXaGV0aGVyIHRvIHByb2Nlc3MgdGhlIGRhdGEtcmVzcG9uc2l2ZSBhdHRyaWJ1dGVzIHRoYXQgaGVscCBpbXBsZW1lbnQgUmVzcG9uc2l2ZSBJbWFnZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2V0dGluZ3Mub2ZmbGluZV0gV2hldGhlciB0byBwcm9jZXNzIHRoZSBkYXRhLW9mZmxpbmUgYXR0cmlidXRlcyB0aGF0IGhlbHAgaW1wbGVtZW50IG9mZmxpbmUgZmlsZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWV0aG9kIHByb2Nlc3NBbGxcclxuICAgICAgICAgKiBAbWVtYmVyT2YgSGVscGVycy5odG1sXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIEEgc2V0dGluZ3Mgc3BlY2lmeWluZyBjdXN0b20gYmVoYXZpb3IuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2V0dGluZ3MucmVzcG9uc2l2ZV0gV2hldGhlciB0byBwcm9jZXNzIHRoZSBkYXRhLXJlc3BvbnNpdmUgYXR0cmlidXRlcyB0aGF0IGhlbHAgaW1wbGVtZW50IFJlc3BvbnNpdmUgSW1hZ2VzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldHRpbmdzLm9mZmxpbmVdIFdoZXRoZXIgdG8gcHJvY2VzcyB0aGUgZGF0YS1vZmZsaW5lIGF0dHJpYnV0ZXMgdGhhdCBoZWxwIGltcGxlbWVudCBvZmZsaW5lIGZpbGVzLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdG8gdGhlIHByb2Nlc3Mgc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJvY2Vzc0FsbDogZnVuY3Rpb24gcHJvY2Vzc0FsbChzZXR0aW5ncywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLl9kZWZhdWx0UHJvY2Vzc1NldHRpbmdzKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgdmFyIHJlc3BvbnNpdmVTZWxlY3RvciA9ICdbJyArIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLmVuYWJsZVJlc3BvbnNpdmUgKyAnXSc7XHJcbiAgICAgICAgICAgIHZhciBvZmZsaW5lU2VsZWN0b3IgPSAnWycgKyB0aGlzLm9wdGlvbnMuYXR0cmlidXRlcy5lbmFibGVPZmZsaW5lICsgJ10nO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3BvbnNpdmVFbGVtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MucmVzcG9uc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2l2ZUVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChyZXNwb25zaXZlU2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2ZmbGluZUVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5vZmZsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBvZmZsaW5lRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG9mZmxpbmVTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzbGljZSA9IFtdLnNsaWNlO1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBfLnVuaXF1ZShzbGljZS5jYWxsKHJlc3BvbnNpdmVFbGVtZW50cykuY29uY2F0KHNsaWNlLmNhbGwob2ZmbGluZUVsZW1lbnRzKSkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3MoZWxlbWVudHMsIHNldHRpbmdzLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gSHRtbEhlbHBlcjtcclxufSgpKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcclxudmFyIEV2ZXJsaXZlRXJyb3JNb2R1bGUgPSByZXF1aXJlKCcuLi8uLi9FdmVybGl2ZUVycm9yJyk7XHJcbnZhciBFdmVybGl2ZUVycm9ycyA9IEV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcnM7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gRXZlcmxpdmVFcnJvck1vZHVsZS5FdmVybGl2ZUVycm9yO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vY29uc3RhbnRzJyk7XHJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uJyk7XHJcbnZhciBfID0gY29tbW9uLl87XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIdG1sSGVscGVyT2ZmbGluZU1vZHVsZShodG1sSGVscGVyKSB7XHJcbiAgICAgICAgdGhpcy5odG1sSGVscGVyID0gaHRtbEhlbHBlcjtcclxuICAgIH1cclxuXHJcbiAgICBIdG1sSGVscGVyT2ZmbGluZU1vZHVsZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgcHJvY2Vzc09mZmxpbmU6IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzZWxmLmh0bWxIZWxwZXIuX2V2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLmZpbGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMucmVqZWN0ZWRQcm9taXNlKG5ldyBFdmVybGl2ZUVycm9yKCdPZmZsaW5lIHN0b3JhZ2UgbXVzdCBiZSBlbmFibGVkIGluIG9yZGVyIHRvIHVzZSB0aGUgb2ZmbGluZSBmZWF0dXJlcyBvZiB0aGUgaW1hZ2VzIGNvbXBvbmVudC4nKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmh0bWxIZWxwZXIuX2V2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLmZpbGVzLmRvd25sb2FkT2ZmbGluZSh1cmwpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobG9jYWxVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxVcmw7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09IEV2ZXJsaXZlRXJyb3JzLmNhbm5vdERvd25sb2FkT2ZmbGluZS5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmh0bWxIZWxwZXIuX2V2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldE9mZmxpbmVGaWxlc0RhdGEoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUZpbGVzRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZSh1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZEZpbGUgPSBfLmZpbmQob2ZmbGluZUZpbGVzRGF0YSwgZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lm9ubGluZUxvY2F0aW9uICYmIGVudHJ5Lm9mZmxpbmVMb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25saW5lTG9jYXRpb24gPSBlbnRyeS5vbmxpbmVMb2NhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VuYW1lSW5kZXggPSBvbmxpbmVMb2NhdGlvbi5sYXN0SW5kZXhPZihiYXNlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlbmFtZUluZGV4ICE9PSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRGaWxlLm9mZmxpbmVMb2NhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignQ2Fubm90IGZpbmQgb2ZmbGluZSBpbWFnZSAnICsgdXJsLCBFdmVybGl2ZUVycm9ycy5taXNzaW5nT3JJbnZhbGlkRmlsZUNvbnRlbnQuY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gSHRtbEhlbHBlck9mZmxpbmVNb2R1bGU7XHJcbn0oKSk7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbicpO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uLy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vY29uc3RhbnRzJyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIdG1sSGVscGVyUmVzcG9uc2l2ZU1vZHVsZShodG1sSGVscGVyKSB7XHJcbiAgICAgICAgdGhpcy5odG1sSGVscGVyID0gaHRtbEhlbHBlcjtcclxuICAgIH1cclxuXHJcbiAgICBIdG1sSGVscGVyUmVzcG9uc2l2ZU1vZHVsZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgZ2V0QmFja2dyb3VuZFdpZHRoOiBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kV2lkdGgoZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChlbC5vZmZzZXRXaWR0aCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcGFyc2VQYXJhbXNTdHJpbmc6IGZ1bmN0aW9uIHBhcnNlUGFyYW1zU3RyaW5nKHN0cikge1xyXG4gICAgICAgICAgICBpZiAoIXN0ciB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJyB8fCBzdHIubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGlzVXNlclJlc2l6ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBzdHIuc3BsaXQoJy8nKTtcclxuICAgICAgICAgICAgdmFyIGlpID0gdG1wLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0bXBbaV0uc3BsaXQoJz0nKSxcclxuICAgICAgICAgICAgICAgICAgICB0bXBPYmogPSB7fTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbVsxXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtWzFdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMV0gPSB1bmVzY2FwZShpdGVtWzFdLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0bXBPYmpbaXRlbVswXV0gPSBpdGVtWzFdO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godG1wT2JqKTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtWzBdID09PSAncmVzaXplJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzVXNlclJlc2l6ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgaXNVc2VyUmVzaXplOiBpc1VzZXJSZXNpemVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRJbWdQYXJhbXM6IGZ1bmN0aW9uIGdldEltZ1BhcmFtcyhzcmMpIHtcclxuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciBpbWdVcmwgPSBzcmMucmVwbGFjZSgvLio/cmVzaXplPVteLy9dKlxcLy9naSwgJycpO1xyXG4gICAgICAgICAgICB2YXIgcHJvdG9jb2xSZSA9IG5ldyBSZWdFeHAoJ2h0dHBzPzovLycsICdnaScpO1xyXG4gICAgICAgICAgICB2YXIgc2VydmVyUmUgPSBuZXcgUmVnRXhwKHRoaXMuaHRtbEhlbHBlci5fc2V0dGluZ3Muc2VydmVyLCAnZ2knKTtcclxuICAgICAgICAgICAgdmFyIGFwaUtleVJlID0gbmV3IFJlZ0V4cCh0aGlzLmh0bWxIZWxwZXIuX2V2ZXJsaXZlLmFwaUtleSArICcvJywgJ2dpJyk7XHJcblxyXG4gICAgICAgICAgICBvcGVyYXRpb25zID0gc3JjLnJlcGxhY2UoaW1nVXJsLCAnJykucmVwbGFjZShwcm90b2NvbFJlLCAnJykucmVwbGFjZShzZXJ2ZXJSZSwgJycpLnJlcGxhY2UoYXBpS2V5UmUsICcnKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9ucyAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMgPSBvcGVyYXRpb25zLmluZGV4T2YoJy8nKSA/IG9wZXJhdGlvbnMuc3Vic3RyaW5nKDAsIG9wZXJhdGlvbnMubGVuZ3RoIC0gMSkgOiBvcGVyYXRpb25zO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvcGVyYXRpb25zID0gdGhpcy5wYXJzZVBhcmFtc1N0cmluZyhvcGVyYXRpb25zKTtcclxuICAgICAgICAgICAgLy8gSWYgaXQncyBhIHVzZXIgcmVzaXplIG9wZXJhdGlvbiwgdXNlIHRoZSBwYXNzZWQgdXJsIGluIHRoZSBkYXRhLXNyYyBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9ucy5pc1VzZXJSZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIGltZ1VybCA9IHNyYztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGltZ1VybDogaW1nVXJsLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uczogb3BlcmF0aW9ucy5wYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBpc1VzZXJSZXNpemU6IG9wZXJhdGlvbnMuaXNVc2VyUmVzaXplXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjbCkge1xyXG4gICAgICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCcoPzpcXFxcc3xeKScgKyBjbCArICcoPzpcXFxcc3wkKScpO1xyXG4gICAgICAgICAgICByZXR1cm4gISFlbC5jbGFzc05hbWUubWF0Y2gocmVnZXgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldEltYWdlV2lkdGg6IGZ1bmN0aW9uIGdldEltYWdlV2lkdGgoZWwpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gZWwucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudFdpZHRoID0gcGFyZW50RWwub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBpdGVtU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnRFbCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHZhciBwbCA9IHBhcnNlRmxvYXQoaXRlbVN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctbGVmdCcpKTtcclxuICAgICAgICAgICAgdmFyIHByID0gcGFyc2VGbG9hdChpdGVtU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpKTtcclxuICAgICAgICAgICAgdmFyIGJsID0gcGFyc2VGbG9hdChpdGVtU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLWxlZnQtd2lkdGgnKSk7XHJcbiAgICAgICAgICAgIHZhciBiciA9IHBhcnNlRmxvYXQoaXRlbVN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1yaWdodC13aWR0aCcpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhwYXJlbnRXaWR0aCAtIE1hdGguY2VpbChwbCArIHByICsgYmwgKyBicikpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldERldmljZVBpeGVsUmF0aW86IGZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRQaXhlbFJhdGlvOmZ1bmN0aW9uIGdldFBpeGVsUmF0aW8oZWwpIHtcclxuICAgICAgICAgICAgdmFyIHBpeGVsRGVuc2l0eSA9IGVsLmdldEF0dHJpYnV0ZSh0aGlzLmh0bWxIZWxwZXIub3B0aW9ucy5hdHRyaWJ1dGVzLmRwaSkgfHwgJyc7XHJcbiAgICAgICAgICAgIHJldHVybiBwaXhlbERlbnNpdHkgIT09ICcnID8gXy5pc051bWJlcihwaXhlbERlbnNpdHkpID8gcGFyc2VGbG9hdChwaXhlbERlbnNpdHkpIDogZmFsc2UgOiB0aGlzLmdldERldmljZVBpeGVsUmF0aW8oKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRJbWdQYXJhbXNTdHJpbmc6IGZ1bmN0aW9uIGdldEltZ1BhcmFtc1N0cmluZyhpbWFnZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXNTdHIgPSAnJztcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICB2YXIgaWkgPSBwYXJhbXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gcGFyYW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF8ua2V5cyhpdGVtKVswXTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzRWxlbWVudC5pbWFnZShpbWFnZSkgJiYga2V5ID09PSAncmVzaXplJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwaXhlbERlbnNpdHkgPSB0aGlzLmdldFBpeGVsUmF0aW8oaW1hZ2UuaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBwaXhlbERlbnNpdHkgPSAocGl4ZWxEZW5zaXR5KSA/ICcscGQ6JyArIHBpeGVsRGVuc2l0eSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoa2V5ID09PSAncmVzaXplJykgPyBpdGVtW2tdICsgcGl4ZWxEZW5zaXR5IDogaXRlbVtrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwYXJhbXNTdHIgKz0ga2V5ICsgJz0nICsgdmFsdWUgKyAnLyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXNTdHI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVzcG9uc2l2ZUltYWdlOiBmdW5jdGlvbiByZXNwb25zaXZlSW1hZ2UoaXRlbSwgZGF0YVNyYykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IF8uZXh0ZW5kKHt9LCBpdGVtKTtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBpbWFnZS5pdGVtO1xyXG4gICAgICAgICAgICB2YXIgdGFnID0gaW1hZ2UudGFnO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlzSW1hZ2UgPSB1dGlscy5pc0VsZW1lbnQuaW1hZ2UodGFnKTtcclxuICAgICAgICAgICAgdmFyIGltZ1dpZHRoO1xyXG5cclxuICAgICAgICAgICAgaW1hZ2UgPSBfLmV4dGVuZCh7fSwgaW1hZ2UsIHNlbGYuZ2V0SW1nUGFyYW1zKGRhdGFTcmMpKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghaW1hZ2UuaXNVc2VyUmVzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBpbWdXaWR0aCA9ICghaXNJbWFnZSkgPyBzZWxmLmdldEJhY2tncm91bmRXaWR0aChlbGVtZW50KSA6IHNlbGYuZ2V0SW1hZ2VXaWR0aChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW1nV2lkdGggPSBpbWdXaWR0aCA/IGltZ1dpZHRoIDogZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBzcmMgPSBpbWFnZS5pc1VzZXJSZXNpemUgPyBpbWFnZS5pbWdVcmwgOiBzZWxmLmdldEltZ1NyYyhpbWFnZSwgaW1nV2lkdGgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaW1nV2lkdGggJiYgIWltYWdlLmlzVXNlclJlc2l6ZSkgeyAvLyB3ZSBkb24ndCBoYXZlIHRoZSB3aWR0aCBvZiB0aGUgdXNlciBpbWFnZSBlaXRoZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBlbGVtZW50IGlzIG5vdCB2aXNpYmxlLCB3ZSBkb24ndCBoYXZlIHRvIHByb2Nlc3MgaXQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoc3JjKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0SW1nU3JjOiBmdW5jdGlvbiBnZXRJbWdTcmMoaW1hZ2UsIGltZ1dpZHRoKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IHRoaXMuaHRtbEhlbHBlci5fZXZlcmxpdmUuc2V0dXAuc2NoZW1lICsgJzovLyc7XHJcbiAgICAgICAgICAgIHZhciBhcGlLZXkgPSB0aGlzLmh0bWxIZWxwZXIuX2V2ZXJsaXZlLnNldHVwLmFwaUtleTtcclxuICAgICAgICAgICAgdmFyIHNlcnZlciA9IHRoaXMuaHRtbEhlbHBlci5fc2V0dGluZ3Muc2VydmVyO1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5odG1sSGVscGVyLl9zZXR0aW5ncy51cmxUZW1wbGF0ZTtcclxuICAgICAgICAgICAgdmFyIHBpeGVsRGVuc2l0eSA9IHRoaXMuZ2V0UGl4ZWxSYXRpbyhpbWFnZS5pdGVtKTtcclxuXHJcbiAgICAgICAgICAgIHBpeGVsRGVuc2l0eSA9IHBpeGVsRGVuc2l0eSA/ICcscGQ6JyArIHBpeGVsRGVuc2l0eSA6ICcnO1xyXG5cclxuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ1twcm90b2NvbF0nLCBwcm90b2NvbCk7XHJcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCdbYXBpa2V5XScsIGFwaUtleSA/IGFwaUtleSA6ICcnKTtcclxuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ1tob3N0bmFtZV0nLCBzZXJ2ZXIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGltYWdlLm9wZXJhdGlvbnMgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb25zID0gJyc7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLmdldEltZ1BhcmFtc1N0cmluZyhpbWFnZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0VsZW1lbnQuaW1hZ2UoaW1hZ2UudGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMgPSBpbWdXaWR0aCA/ICdyZXNpemU9dzonICsgaW1nV2lkdGggKyBwaXhlbERlbnNpdHkgKyAnLycgKyBwYXJhbXMgOiBwYXJhbXM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMgPSAncmVzaXplPXc6JyArIGltZ1dpZHRoICsgcGl4ZWxEZW5zaXR5ICsgJy8nICsgcGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ1tvcGVyYXRpb25zXScsIG9wZXJhdGlvbnMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ1tvcGVyYXRpb25zXScsICdyZXNpemU9dzonICsgaW1nV2lkdGggKyBwaXhlbERlbnNpdHkgKyAnLycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgnW3VybF0nLCBpbWFnZS5pbWdVcmwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEh0bWxIZWxwZXJSZXNwb25zaXZlTW9kdWxlO1xyXG59KCkpOyIsIi8qIVxyXG4gVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTMgVGVsZXJpayBBRFxyXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiBUSEUgU09GVFdBUkUueSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqL1xyXG4vKiFcclxuIEV2ZXJsaXZlIFNES1xyXG4gVmVyc2lvbiAxLjUuMVxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBFdmVybGl2ZSA9IHJlcXVpcmUoJy4vRXZlcmxpdmUnKTtcclxuICAgIHZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoJy4vZXZlcmxpdmUucGxhdGZvcm0nKTtcclxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xyXG5cclxuICAgIGlmICghcGxhdGZvcm0uaXNOYXRpdmVTY3JpcHQgJiYgIXBsYXRmb3JtLmlzTm9kZWpzKSB7XHJcbiAgICAgICAgdmFyIGtlbmRvID0gcmVxdWlyZSgnLi9rZW5kby9rZW5kby5ldmVybGl2ZScpO1xyXG4gICAgICAgIEV2ZXJsaXZlLmNyZWF0ZURhdGFTb3VyY2UgPSBrZW5kby5jcmVhdGVEYXRhU291cmNlO1xyXG4gICAgICAgIEV2ZXJsaXZlLmNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2UgPSBrZW5kby5jcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vR2xvYmFsIGV2ZW50IGhhbmRsZXJzIGZvciBwdXNoIG5vdGlmaWNhdGlvbiBldmVudHMuIFJlcXVpcmVkIGJ5IHRoZSBjb3Jkb3ZhIFB1c2hOb3RpZmljYXRpb25zIHBsdWdpbiB0aGF0IHdlIHVzZS5cclxuICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3MgPSB7fTtcclxuICAgIEV2ZXJsaXZlLk9mZmxpbmUgPSB7fTtcclxuXHJcbiAgICBFdmVybGl2ZS5RdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnkvUXVlcnknKTtcclxuICAgIEV2ZXJsaXZlLlF1ZXJ5QnVpbGRlciA9IHJlcXVpcmUoJy4vcXVlcnkvUXVlcnlCdWlsZGVyJyk7XHJcbiAgICBFdmVybGl2ZS5HZW9Qb2ludCA9IHJlcXVpcmUoJy4vR2VvUG9pbnQnKTtcclxuICAgIEV2ZXJsaXZlLkNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbiAgICBFdmVybGl2ZS5SZXF1ZXN0ID0gcmVxdWlyZSgnLi9SZXF1ZXN0Jyk7XHJcbiAgICBFdmVybGl2ZS5EYXRhID0gcmVxdWlyZSgnLi90eXBlcy9EYXRhJyk7XHJcbiAgICBFdmVybGl2ZS5fdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbiAgICBFdmVybGl2ZS5fdHJhdmVyc2VBbmRSZXZpdmUgPSBFdmVybGl2ZS5fdXRpbHMucGFyc2VVdGlsaXRpZXMudHJhdmVyc2VBbmRSZXZpdmU7XHJcbiAgICBFdmVybGl2ZS5fY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxuXHJcbiAgICB2YXIgcGVyc2lzdGVyc01vZHVsZSA9IHJlcXVpcmUoJy4vb2ZmbGluZS9vZmZsaW5lUGVyc2lzdGVycycpO1xyXG4gICAgRXZlcmxpdmUucGVyc2lzdGVyID0ge1xyXG4gICAgICAgIExvY2FsU3RvcmFnZTogcGVyc2lzdGVyc01vZHVsZS5Mb2NhbFN0b3JhZ2VQZXJzaXN0ZXIsXHJcbiAgICAgICAgRmlsZVN5c3RlbTogcGVyc2lzdGVyc01vZHVsZS5GaWxlU3lzdGVtUGVyc2lzdGVyXHJcbiAgICB9O1xyXG5cclxuICAgIC8vZXZlcmxpdmVNb2R1bGUgaXMgcHJvdmlkZWQgYnkgYSBjbG9zdXJlIGdlbmVyYXRlZCBkdXJpbmcgYnVpbGRcclxuICAgIGlmIChwbGF0Zm9ybS5pc05vZGVqcyB8fCBwbGF0Zm9ybS5pc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXZlcmxpdmVNb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGV2ZXJsaXZlTW9kdWxlLmV4cG9ydHMgPSBFdmVybGl2ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZXJsaXZlO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9pbiByZXF1aXJlanMgRXZlcmxpdmUgaXMgZGVmaW5lZCBpbiB0aGUgc2FtZSBjbG9zdXJlXHJcbiAgICAgICAgLy9icm93c2VyXHJcbiAgICAgICAgY29tbW9uLnJvb3QuRXZlcmxpdmUgPSBFdmVybGl2ZTtcclxuICAgIH1cclxufSgpKTsiLCJ2YXIgUXVlcnlCdWlsZGVyID0gcmVxdWlyZSgnLi4vcXVlcnkvUXVlcnlCdWlsZGVyJyk7XHJcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L1F1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxudmFyIEV2ZXJsaXZlID0gcmVxdWlyZSgnLi4vRXZlcmxpdmUnKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cualF1ZXJ5ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93LmtlbmRvID09PSAndW5kZWZpbmVkJyB8fCBfLmlzRW1wdHkod2luZG93LmtlbmRvLmRhdGEpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciAkID0gd2luZG93LmpRdWVyeTtcclxuICAgIHZhciBrZW5kbyA9IHdpbmRvdy5rZW5kbztcclxuXHJcbiAgICB2YXIgZXh0ZW5kID0gJC5leHRlbmQ7XHJcblxyXG4gICAgdmFyIGV2ZXJsaXZlVHJhbnNwb3J0ID0ga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZXh0ZW5kKHtcclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJsaXZlJCA9IG9wdGlvbnMuZGF0YVByb3ZpZGVyIHx8IEV2ZXJsaXZlLiQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ldmVybGl2ZSQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaW5zdGFuY2Ugb2YgdGhlIEJhY2tlbmQgc2VydmljZXMgc2RrIG11c3QgYmUgcHJvdmlkZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50eXBlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHR5cGUgbmFtZSBtdXN0IGJlIHByb3ZpZGVkLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRhdGFDb2xsZWN0aW9uID0gdGhpcy5ldmVybGl2ZSQuZGF0YShvcHRpb25zLnR5cGVOYW1lKTtcclxuICAgICAgICAgICAga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZm4uaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RPcHRpb24gPSB0aGlzLm9wdGlvbnNbJ3JlYWQnXTtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24udXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZm4ucmVhZC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RIZWFkZXJzO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2RIZWFkZXJzID0gbWV0aG9kT3B0aW9uLmhlYWRlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gdHJhbnNsYXRlS2VuZG9RdWVyeShvcHRpb25zLmRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgZXZlcmxpdmVRdWVyeSA9IG5ldyBRdWVyeShxdWVyeS4kd2hlcmUsIG51bGwsIHF1ZXJ5LiRzb3J0LCBxdWVyeS4kc2tpcCwgcXVlcnkuJHRha2UpO1xyXG4gICAgICAgICAgICB2YXIgaWQgPSBvcHRpb25zLmRhdGEuSWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS53aXRoSGVhZGVycyhtZXRob2RIZWFkZXJzKS5nZXRCeUlkKGlkKS50aGVuKG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcikuY2F0Y2gob3B0aW9ucy5lcnJvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb2xsZWN0aW9uLndpdGhIZWFkZXJzKHRoaXMuaGVhZGVycykud2l0aEhlYWRlcnMobWV0aG9kSGVhZGVycykuZ2V0KGV2ZXJsaXZlUXVlcnkpLnRoZW4ob3B0aW9ucy5zdWNjZXNzLCBvcHRpb25zLmVycm9yKS5jYXRjaChvcHRpb25zLmVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE9wdGlvbiA9IHRoaXMub3B0aW9uc1sndXBkYXRlJ107XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RPcHRpb24gJiYgbWV0aG9kT3B0aW9uLnVybCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlbmRvLmRhdGEuUmVtb3RlVHJhbnNwb3J0LmZuLnJlYWQuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWV0aG9kSGVhZGVycztcclxuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24uaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kSGVhZGVycyA9IG1ldGhvZE9wdGlvbi5oZWFkZXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc011bHRpcGxlID0gXy5pc0FycmF5KG9wdGlvbnMuZGF0YS5tb2RlbHMpO1xyXG4gICAgICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXRjaCB1cGRhdGUgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtRm9yVXBkYXRlID0gb3B0aW9ucy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS53aXRoSGVhZGVycyhtZXRob2RIZWFkZXJzKS51cGRhdGVTaW5nbGUoaXRlbUZvclVwZGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihvcHRpb25zLnN1Y2Nlc3MuYmluZCh0aGlzLCBpdGVtRm9yVXBkYXRlKSwgb3B0aW9ucy5lcnJvcikuY2F0Y2gob3B0aW9ucy5lcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RPcHRpb24gPSB0aGlzLm9wdGlvbnNbJ2NyZWF0ZSddO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi51cmwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZW5kby5kYXRhLlJlbW90ZVRyYW5zcG9ydC5mbi5yZWFkLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1ldGhvZEhlYWRlcnM7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RPcHRpb24gJiYgbWV0aG9kT3B0aW9uLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZEhlYWRlcnMgPSBtZXRob2RPcHRpb24uaGVhZGVycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNNdWx0aXBsZSA9IF8uaXNBcnJheShvcHRpb25zLmRhdGEubW9kZWxzKTtcclxuICAgICAgICAgICAgdmFyIGNyZWF0ZURhdGEgPSBpc011bHRpcGxlID8gb3B0aW9ucy5kYXRhLm1vZGVscyA6IG9wdGlvbnMuZGF0YTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFDb2xsZWN0aW9uLndpdGhIZWFkZXJzKHRoaXMuaGVhZGVycykud2l0aEhlYWRlcnMobWV0aG9kSGVhZGVycykuY3JlYXRlKGNyZWF0ZURhdGEpXHJcbiAgICAgICAgICAgICAgICAudGhlbihvcHRpb25zLnN1Y2Nlc3MuYmluZCh0aGlzLCBjcmVhdGVEYXRhKSwgb3B0aW9ucy5lcnJvcikuY2F0Y2gob3B0aW9ucy5lcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE9wdGlvbiA9IHRoaXMub3B0aW9uc1snZGVzdHJveSddO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi51cmwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZW5kby5kYXRhLlJlbW90ZVRyYW5zcG9ydC5mbi5yZWFkLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1ldGhvZEhlYWRlcnM7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RPcHRpb24gJiYgbWV0aG9kT3B0aW9uLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZEhlYWRlcnMgPSBtZXRob2RPcHRpb24uaGVhZGVycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNNdWx0aXBsZSA9IF8uaXNBcnJheShvcHRpb25zLmRhdGEubW9kZWxzKTtcclxuICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2ggZGVzdHJveSBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFDb2xsZWN0aW9uLndpdGhIZWFkZXJzKHRoaXMuaGVhZGVycykud2l0aEhlYWRlcnMobWV0aG9kSGVhZGVycykuZGVzdHJveShvcHRpb25zLmRhdGEpXHJcbiAgICAgICAgICAgICAgICAudGhlbihvcHRpb25zLnN1Y2Nlc3MsIG9wdGlvbnMuZXJyb3IpLmNhdGNoKG9wdGlvbnMuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgICQuZXh0ZW5kKHRydWUsIGtlbmRvLmRhdGEsIHtcclxuICAgICAgICB0cmFuc3BvcnRzOiB7XHJcbiAgICAgICAgICAgIGV2ZXJsaXZlOiBldmVybGl2ZVRyYW5zcG9ydFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NoZW1hczoge1xyXG4gICAgICAgICAgICBldmVybGl2ZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuaGFzT3duUHJvcGVydHkoJ2NvdW50JykgPyBkYXRhLmNvdW50IDogZGF0YS5Db3VudDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnJlc3VsdCB8fCBFdmVybGl2ZS5fdHJhdmVyc2VBbmRSZXZpdmUoZGF0YS5SZXN1bHQpIHx8IGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogY29uc3RhbnRzLmlkRmllbGRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZUtlbmRvUXVlcnkoZGF0YSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5za2lwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuJHNraXAgPSBkYXRhLnNraXA7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5za2lwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnRha2UpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC4kdGFrZSA9IGRhdGEudGFrZTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnRha2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEuc29ydCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvcnRFeHByZXNzaW9ucyA9IGRhdGEuc29ydDtcclxuICAgICAgICAgICAgICAgIHZhciBzb3J0ID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNBcnJheShzb3J0RXhwcmVzc2lvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydEV4cHJlc3Npb25zID0gW3NvcnRFeHByZXNzaW9uc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkLmVhY2goc29ydEV4cHJlc3Npb25zLCBmdW5jdGlvbiAoaWR4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvcnRbdmFsdWUuZmllbGRdID0gdmFsdWUuZGlyID09PSAnYXNjJyA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LiRzb3J0ID0gc29ydDtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnNvcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gZmlsdGVyQnVpbGRlci5idWlsZChkYXRhLmZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuJHdoZXJlID0gZmlsdGVyO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEuZmlsdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlZ2V4T3BlcmF0aW9ucyA9IFsnc3RhcnRzd2l0aCcsICdzdGFydHNXaXRoJywgJ2VuZHN3aXRoJywgJ2VuZHNXaXRoJywgJ2NvbnRhaW5zJ107XHJcblxyXG4gICAgdmFyIGZpbHRlckJ1aWxkZXIgPSB7XHJcbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckJ1aWxkZXIuX2J1aWxkKGZpbHRlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYnVpbGQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlckJ1aWxkZXIuX2lzUmF3KGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9yYXcoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJCdWlsZGVyLl9pc1NpbXBsZShmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fc2ltcGxlKGZpbHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyQnVpbGRlci5faXNSZWdleChmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fcmVnZXgoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJCdWlsZGVyLl9pc0FuZChmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fYW5kKGZpbHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyQnVpbGRlci5faXNPcihmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fb3IoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzUmF3OiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIub3BlcmF0b3IgPT09ICdfcmF3JztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yYXc6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkVGVybSA9IHt9O1xyXG4gICAgICAgICAgICBmaWVsZFRlcm1bZmlsdGVyLmZpZWxkXSA9IGZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc1NpbXBsZTogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZpbHRlci5sb2dpYyA9PT0gJ3VuZGVmaW5lZCcgJiYgIWZpbHRlckJ1aWxkZXIuX2lzUmVnZXgoZmlsdGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHRlcm0gPSB7fSwgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IGZpbHRlckJ1aWxkZXIuX3RyYW5zbGF0ZW9wZXJhdG9yKGZpbHRlci5vcGVyYXRvcik7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdGVybVtvcGVyYXRvcl0gPSBmaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtID0gZmlsdGVyLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtmaWx0ZXIuZmllbGRdID0gdGVybTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc1JlZ2V4OiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkLmluQXJyYXkoZmlsdGVyLm9wZXJhdG9yLCByZWdleE9wZXJhdGlvbnMpICE9PSAtMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZWdleDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciByZWdleCA9IGZpbHRlckJ1aWxkZXIuX2dldFJlZ2V4KGZpbHRlcik7XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtmaWx0ZXIuZmllbGRdID0gZmlsdGVyQnVpbGRlci5fZ2V0UmVnZXhWYWx1ZShyZWdleCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFRlcm07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0UmVnZXg6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBmaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJPcGVyYXRvciA9IGZpbHRlci5vcGVyYXRvcjtcclxuICAgICAgICAgICAgc3dpdGNoIChmaWx0ZXJPcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY29udGFpbnMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiLipcIiArIHBhdHRlcm4gKyBcIi4qXCIsIFwiaVwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0c1dpdGgnOiAvLyByZW1vdmluZyB0aGUgY2FtZWwgY2FzZSBvcGVyYXRvcnMgd2lsbCBiZSBhIGJyZWFraW5nIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnRzd2l0aCc6IC8vIHRoZSBLZW5kbyBVSSBvcGVyYXRvcnMgYXJlIGluIGxvd2VyIGNhc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHBhdHRlcm4sIFwiaVwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZHNXaXRoJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZHN3aXRoJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuICsgXCIkXCIsIFwiaVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIHR5cGUuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFJlZ2V4VmFsdWU6IGZ1bmN0aW9uIChyZWdleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUXVlcnlCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UmVnZXhWYWx1ZS5jYWxsKHRoaXMsIHJlZ2V4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc0FuZDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyLmxvZ2ljID09PSAnYW5kJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hbmQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIuZmlsdGVycztcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wZXJhbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IGZpbHRlckJ1aWxkZXIuX2J1aWxkKG9wZXJhbmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckJ1aWxkZXIuX2FuZEFwcGVuZChyZXN1bHQsIHRlcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYW5kQXBwZW5kOiBmdW5jdGlvbiAoYW5kT2JqLCBuZXdPYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIFF1ZXJ5QnVpbGRlci5wcm90b3R5cGUuX2FuZEFwcGVuZC5jYWxsKHRoaXMsIGFuZE9iaiwgbmV3T2JqKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc09yOiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIubG9naWMgPT09ICdvcic7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfb3I6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIuZmlsdGVycztcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wZXJhbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IGZpbHRlckJ1aWxkZXIuX2J1aWxkKG9wZXJhbmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRlcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7JG9yOiByZXN1bHR9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3RyYW5zbGF0ZW9wZXJhdG9yOiBmdW5jdGlvbiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXEnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbmVxJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbmVcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2d0JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkZ3RcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2x0JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbHRcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2d0ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJGd0ZVwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbHRlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbHRlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciB0eXBlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBLZW5kbyBVSSBbRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9kYXRhc291cmNlKSB0aGF0IG1hbmFnZXMgYSBjZXJ0YWluIEJhY2tlbmQgU2VydmljZXMgY29udGVudCB0eXBlLlxyXG4gICAgICogS2VuZG8gVUkgW0RhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvZGF0YXNvdXJjZSkgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEtlbmRvIFVJIHdpZGdldHMgKHN1Y2ggYXMgW0xpc3RWaWV3XShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS93ZWIvbGlzdHZpZXcvb3ZlcnZpZXcpIGFuZCBbR3JpZF0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvd2ViL2dyaWQvb3ZlcnZpZXcpKSB0byBwcm92aWRlIGFuIGVhc3kgd2F5IHRvIHJlbmRlciBkYXRhIGZyb20gQmFja2VuZCBTZXJ2aWNlcy5cclxuICAgICAqICppbmNsdWRpbmcgS2VuZG8gVUkgc2NyaXB0cyBpcyByZXF1aXJlZCouXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBkYXRhIHNvdXJjZSBvcHRpb25zLiBTZWUgdGhlIEtlbmRvIFVJIGRvY3VtZW50YXRpb24gZm9yIFtEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2RhdGFzb3VyY2UpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNwb3J0LnR5cGVOYW1lIFRoZSBjb250ZW50IHR5cGUgbmFtZSBpbiBCYWNrZW5kIFNlcnZpY2VzIHRoYXQgd2lsbCBiZSBtYW5hZ2VkLlxyXG4gICAgICogQHJldHVybnMge0RhdGFTb3VyY2V9IEEgbmV3IGluc3RhbmNlIG9mIEtlbmRvIFVJIERhdGFTb3VyY2UuIFNlZSB0aGUgS2VuZG8gVUkgZG9jdW1lbnRhdGlvbiBmb3IgW0RhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvZGF0YXNvdXJjZSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBAZXhhbXBsZSBgYGBqc1xyXG4gICAgICogdmFyIGJvb2tzRGF0YVNvdXJjZSA9IEV2ZXJsaXZlLmNyZWF0ZURhdGFTb3VyY2Uoe1xyXG4gICAgICogICB0cmFuc3BvcnQ6IHtcclxuICAgICAqICAgICB0eXBlTmFtZTogJ0Jvb2tzJ1xyXG4gICAgICogICB9XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgY3JlYXRlRGF0YVNvdXJjZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gb3B0aW9ucy50eXBlTmFtZTtcclxuICAgICAgICB2YXIgZXZlcmxpdmUkID0gb3B0aW9ucy5kYXRhUHJvdmlkZXIgfHwgRXZlcmxpdmUuJDtcclxuICAgICAgICBpZiAoIWV2ZXJsaXZlJCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBpbnN0YW50aWF0ZSBhbiBFdmVybGl2ZSBpbnN0YW5jZSBpbiBvcmRlciB0byBjcmVhdGUgYSBLZW5kbyBVSSBEYXRhU291cmNlLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhICd0eXBlTmFtZScgaW4gb3JkZXIgdG8gY3JlYXRlIGEgS2VuZG8gVUkgRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUkLmdldEtlbmRvRGF0YVNvdXJjZSh0eXBlTmFtZSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBLZW5kbyBVSSBbSGllcmFyY2hpY2FsRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9oaWVyYXJjaGljYWxkYXRhc291cmNlKSB0aGF0IG1hbmFnZXMgYSBjZXJ0YWluIEJhY2tlbmQgU2VydmljZXMgY29udGVudCB0eXBlIGFuZCBjYW4gZXhwYW5kIGEgY2hhaW4gb2YgcmVsYXRpb25zLlxyXG4gICAgICogS2VuZG8gVUkgW0hpZXJhcmNoaWNhbERhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvaGllcmFyY2hpY2FsZGF0YXNvdXJjZSkgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEtlbmRvIFVJIHdpZGdldHMgKHN1Y2ggYXMgW1RyZWVWaWV3XShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS93ZWIvdHJlZXZpZXcvb3ZlcnZpZXcpKSB0byByZW5kZXIgZGF0YSBmcm9tIEJhY2tlbmQgU2VydmljZXMgaW4gYSBzdHJ1Y3R1cmVkIHdheS5cclxuICAgICAqIFRoZSBjaGFpbiBvZiByZWxhdGlvbnMgaXMgZGVmaW5lZCBieSBzcGVjaWZ5aW5nIHRoZSBmaWVsZCBuYW1lcyB0aGF0IGNvbnRhaW4gdGhlIHJlbGF0aW9uIG9uIGVhY2ggbGV2ZWwuIEZvciBleGFtcGxlIGEgZ2VuZXJpYyBoaWVyYXJjaHkgY2hhaW4gaXMgYSBjb250ZW50IHR5cGUgJ0NvbnRpbmVudHMnIHdpdGggcmVsYXRpb24gdG8gJ0NvdW50cmllcycsIHdoaWNoIGluIHR1cm4gY29udGFpbnMgYSByZWxhdGlvbiB0byAnVG93bnMnLlxyXG4gICAgICogKmluY2x1ZGluZyBLZW5kbyBVSSBzY3JpcHRzIGlzIHJlcXVpcmVkKi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIGRhdGEgc291cmNlIE9wdGlvbnMgZm9yIFtIaWVyYXJjaGljYWxEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2hpZXJhcmNoaWNhbGRhdGFzb3VyY2UpLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHlwZU5hbWUgTmFtZSBvZiB0aGUgbWFpbiBjb250ZW50IHR5cGUgZm9yIHRoZSBkYXRhIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSB7RXhwYW5kRGVmaW5pdGlvbltdfSBvcHRpb25zLmV4cGFuZCBBbiBhcnJheSBvZiBleHBhbmQgZGVmaW5pdGlvbnMuIEl0IGRlZmluZXMgdGhlIGxldmVscyBvZiBoaWVyYXJjaHkgYnkgc3BlY2lmeWluZyB0aGUgcmVsYXRpb24gZmllbGRzLiBBbiBleHBhbmQgZGVmaW5pdGlvbiBjYW4gZWl0aGVyIGJlIHRoZSBmaWVsZCBuYW1lIGFzIGEgKipzdHJpbmcqKiwgb3IgYW4gKipvYmplY3QqKiB0aGF0IGFsbG93cyBhZGRpdGlvbmFsIG9wdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gRXhwYW5kRGVmaW5pdGlvbiAtIFRoZSBmaWVsZCBuYW1lIG9mIHRoZSByZWxhdGlvbiB0aGF0IHdpbGwgYmUgZXhwYW5kZWQuIE9ubHkgc3VwcG9ydGVkIGluIG9ubGluZSBtb2RlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IEV4cGFuZERlZmluaXRpb24ucmVsYXRpb24gLSAqUmVxdWlyZWQqLiBUaGUgZmllbGQgbmFtZSBvZiB0aGUgcmVsYXRpb24gdGhhdCB3aWxsIGJlIGV4cGFuZGVkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IEV4cGFuZERlZmluaXRpb24udHlwZU5hbWUgLSAqUmVxdWlyZWQgaW4gb2ZmbGluZSBtb2RlKi4gVGhlIHR5cGUgbmFtZSBvZiB0aGUgcmVsYXRpb24gdGhhdCB3aWxsIGJlIGV4cGFuZGVkLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEV4cGFuZERlZmluaXRpb24uZmlsdGVyIC0gQW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGZpbHRlciBleHByZXNzaW9uLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEV4cGFuZERlZmluaXRpb24uc29ydCAtIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBzb3J0IGV4cHJlc3Npb24uXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi5za2lwIC0gQSBudW1iZXIgc3BlY2lmeWluZyB0aGUgc2tpcCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBFeHBhbmREZWZpbml0aW9uLnRha2UgLSBBIG51bWJlciBzcGVjaWZ5aW5nIHRoZSB0YWtlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEV4cGFuZERlZmluaXRpb24uZmllbGRzIC0gQW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGZpZWxkcyBleHByZXNzaW9uLlxyXG4gICAgICogQHJldHVybnMge0hpZXJhcmNoaWNhbERhdGFTb3VyY2V9IEEgbmV3IGluc3RhbmNlIG9mIEtlbmRvIFVJIEhpZXJhcmNoaWNhbERhdGFTb3VyY2UuIFNlZSB0aGUgS2VuZG8gVUkgZG9jdW1lbnRhdGlvbiBmb3IgW0hpZXJhcmNoaWNhbERhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvaGllcmFyY2hpY2FsZGF0YXNvdXJjZSkuXHJcbiAgICAgKiBAZXhhbXBsZSBgYGBqc1xyXG4gICAgICogdmFyIGVsID0gbmV3IEV2ZXJsaXZlKCd5b3VyLWFwaS1rZXktaGVyZScpO1xyXG4gICAgICogdmFyIGNvbnRpbmVudHMgPSBFdmVybGl2ZS5jcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlKHtcclxuICAgICAqICAgXCJ0eXBlTmFtZVwiOiBcIkNvbnRpbmVudHNcIixcclxuICAgICAqICAgXCJleHBhbmRcIjogW1wiQ291bnRyaWVzXCIsIFwiVG93bnNcIl1cclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIC4uLlxyXG4gICAgICogKFwiI3RyZWV2aWV3XCIpLmtlbmRvVHJlZVZpZXcoe1xyXG4gICAgICogICBkYXRhU291cmNlOiBjb250aW5lbnRzLFxyXG4gICAgICogICBkYXRhVGV4dEZpZWxkOiBbXCJDb250aW5lbnROYW1lXCIsIFwiQ291bnRyeU5hbWVcIiwgXCJUb3duTmFtZVwiXVxyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgdmFyIGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciB0eXBlTmFtZSA9IG9wdGlvbnMudHlwZU5hbWU7XHJcbiAgICAgICAgdmFyIGV2ZXJsaXZlJCA9IG9wdGlvbnMuZGF0YVByb3ZpZGVyIHx8IEV2ZXJsaXZlLiQ7XHJcbiAgICAgICAgaWYgKCFldmVybGl2ZSQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gaW5zdGFudGlhdGUgYW4gRXZlcmxpdmUgaW5zdGFuY2UgaW4gb3JkZXIgdG8gY3JlYXRlIGEgS2VuZG8gVUkgRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhICd0eXBlTmFtZScgaW4gb3JkZXIgdG8gY3JlYXRlIGEgS2VuZG8gVUkgRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVybGl2ZSQuZ2V0SGllcmFyY2hpY2FsRGF0YVNvdXJjZSh0eXBlTmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIEtlbmRvIFVJIERhdGFTb3VyY2UgdGhhdCBpcyBhdHRhY2hlZCB0byB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGUgU0RLIHdpdGggZGVmYXVsdCBvcHRpb25zLlxyXG4gICAgICogQG1ldGhvZCBnZXRLZW5kb0RhdGFTb3VyY2VcclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlTmFtZSBUaGUgY29ycmVzcG9uZGluZyB0eXBlIG5hbWUgZm9yIHRoZSBEYXRhU291cmNlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhc291cmNlT3B0aW9uc10gQWRkaXRpb25hbCBEYXRhU291cmNlIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyB7RGF0YVNvdXJjZX1cclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLmdldEtlbmRvRGF0YVNvdXJjZSA9IGZ1bmN0aW9uICh0eXBlTmFtZSwgZGF0YXNvdXJjZU9wdGlvbnMpIHtcclxuICAgICAgICBkYXRhc291cmNlT3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBkYXRhc291cmNlT3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKGRhdGFzb3VyY2VPcHRpb25zLmhhc093blByb3BlcnR5KCdzZXJ2ZXJHcm91cGluZycpICYmIGRhdGFzb3VyY2VPcHRpb25zLnNlcnZlckdyb3VwaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdTZXJ2ZXIgR3JvdXBpbmcgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0RXZlcmxpdmVPcHRpb25zID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnZXZlcmxpdmUnLFxyXG4gICAgICAgICAgICB0cmFuc3BvcnQ6IHtcclxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgIGRhdGFQcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfLmRlZmF1bHRzKGRlZmF1bHRFdmVybGl2ZU9wdGlvbnMsIGRhdGFzb3VyY2VPcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gbmV3IGtlbmRvLmRhdGEuRGF0YVNvdXJjZShvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHZhciBnZXRVcmxHZW5lcmF0b3JGb3JOb2RlID0gZnVuY3Rpb24gKGJhc2VVcmwsIGV4cGFuZEFycmF5KSB7XHJcbiAgICAgICAgdmFyIGV4cGFuZEZpZWxkID0gZ2V0UmVsYXRpb25GaWVsZEZvckV4cGFuZE5vZGUoZXhwYW5kQXJyYXlbZXhwYW5kQXJyYXkubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgIHZhciBwYXRoQXJyYXkgPSBleHBhbmRBcnJheS5zbGljZSgwLCBleHBhbmRBcnJheS5sZW5ndGggLSAxKTtcclxuICAgICAgICB2YXIgcGF0aFVybCA9ICcvX2V4cGFuZCc7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGF0aFVybCArPSAnLycgKyBnZXRSZWxhdGlvbkZpZWxkRm9yRXhwYW5kTm9kZShwYXRoQXJyYXlbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChwYXRoVXJsLCBleHBhbmRGaWVsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBiYXNlVXJsICsgJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5JZCAmJiBleHBhbmRGaWVsZCkgey8vaWYgd2UgYXJlIGV4cGFuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSBwYXRoVXJsICsgJy8nICsgb3B0aW9ucy5JZCArICcvJyArIGV4cGFuZEZpZWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0ocGF0aFVybCwgZXhwYW5kRmllbGQpKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGdldEhlYWRlcnNGb3JFeHBhbmROb2RlID0gZnVuY3Rpb24gKGV4cGFuZE5vZGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV4cGFuZE5vZGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1GaWx0ZXInOiBKU09OLnN0cmluZ2lmeShleHBhbmROb2RlLmZpbHRlciksXHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1Tb3J0JzogSlNPTi5zdHJpbmdpZnkoZXhwYW5kTm9kZS5zb3J0KSxcclxuICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLVNpbmdsZS1GaWVsZCc6IGV4cGFuZE5vZGUuc2luZ2xlRmllbGQsXHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1Ta2lwJzogZXhwYW5kTm9kZS5za2lwLFxyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtVGFrZSc6IGV4cGFuZE5vZGUudGFrZSxcclxuICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLUZpZWxkcyc6IEpTT04uc3RyaW5naWZ5KGV4cGFuZE5vZGUuZmllbGRzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZ2V0UmVsYXRpb25GaWVsZEZvckV4cGFuZE5vZGUgPSBmdW5jdGlvbiAoZXhwYW5kTm9kZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXhwYW5kTm9kZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kTm9kZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXhwYW5kTm9kZS5yZWxhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZE5vZGUucmVsYXRpb247XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBzcGVjaWZ5IGEgJ3JlbGF0aW9uJyBmb3IgYW4gZXhwYW5kIG5vZGUgd2hlbiB1c2luZyB0aGUgb2JqZWN0IG5vdGF0aW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIEtlbmRvIFVJIEhpZXJhcmNoaWNhbERhdGFTb3VyY2UgdGhhdCBpcyBhdHRhY2hlZCB0byB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGUgU0RLIHdpdGggZGVmYXVsdCBvcHRpb25zLlxyXG4gICAgICogQG1ldGhvZCBnZXRIaWVyYXJjaGljYWxEYXRhU291cmNlXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZU5hbWUgVGhlIGNvcnJlc3BvbmRpbmcgdHlwZSBuYW1lIGZvciB0aGUgRGF0YVNvdXJjZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhU291cmNlT3B0aW9ucyBBZGRpdGlvbmFsIERhdGFTb3VyY2Ugb3B0aW9ucyB0aGF0IGRlc2NyaWJlIHRoZSBoaWVyYXJjaGljYWwgc3RydWN0dXJlLlxyXG4gICAgICogQHJldHVybnMge0hpZXJhcmNoaWNhbERhdGFTb3VyY2V9XHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5nZXRIaWVyYXJjaGljYWxEYXRhU291cmNlID0gZnVuY3Rpb24gKHR5cGVOYW1lLCBkYXRhU291cmNlT3B0aW9ucykge1xyXG4gICAgICAgIGRhdGFTb3VyY2VPcHRpb25zID0gZGF0YVNvdXJjZU9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYgKGRhdGFTb3VyY2VPcHRpb25zLmhhc093blByb3BlcnR5KCdzZXJ2ZXJHcm91cGluZycpICYmIGRhdGFTb3VyY2VPcHRpb25zLnNlcnZlckdyb3VwaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdTZXJ2ZXIgR3JvdXBpbmcgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV4cGFuZCA9IGRhdGFTb3VyY2VPcHRpb25zLmV4cGFuZCB8fCBkYXRhU291cmNlT3B0aW9ucztcclxuICAgICAgICBkZWxldGUgZGF0YVNvdXJjZU9wdGlvbnMuZXhwYW5kO1xyXG4gICAgICAgIGlmICghdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhICd0eXBlTmFtZScgaW4gb3JkZXIgdG8gY3JlYXRlIGEgS2VuZG8gVUkgSGllcmFyY2hpY2FsRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghJC5pc0FycmF5KGV4cGFuZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc2V0ICdleHBhbmQnIGFycmF5IG9wdGlvbiBpbiBvcmRlciB0byBjcmVhdGUgYSBLZW5kbyBVSSBIaWVyYXJjaGljYWxEYXRhU291cmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZVVybCA9IHRoaXMuYnVpbGRVcmwoKSArIHR5cGVOYW1lO1xyXG5cclxuICAgICAgICB2YXIgZXhwYW5kU2NoZW1hO1xyXG4gICAgICAgIHZhciBpc09mZmxpbmVTdG9yYWdlRW5hYmxlZCA9IHRoaXMuX2lzT2ZmbGluZVN0b3JhZ2VFbmFibGVkKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGV4cGFuZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyAvL3JlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSBoaWVyYXJjaGljYWwgZGF0YSBzb3VyY2VcclxuICAgICAgICAgICAgdmFyIGV4cGFuZE5vZGUgPSBleHBhbmRbaV07XHJcbiAgICAgICAgICAgIGlmIChpc09mZmxpbmVTdG9yYWdlRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEkLmlzUGxhaW5PYmplY3QoZXhwYW5kTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIG9mZmxpbmUgaXMgZW5hYmxlZCwgZWFjaCBtZW1iZXIgb2YgdGhlIGV4cGFuZCBhcnJheSBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3QuIChFeHBhbmQgbm9kZSBpbmRleDogXCIgKyBpICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFleHBhbmROb2RlLnJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBvZmZsaW5lIGlzIGVuYWJsZWQsIGVhY2ggbWVtYmVyIG9mIHRoZSBleHBhbmQgYXJyYXkgb3B0aW9uIG11c3QgaGF2ZSBhIGByZWxhdGlvbmAgb3B0aW9uIHNldC4gIChFeHBhbmQgbm9kZSBpbmRleDogXCIgKyBpICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFleHBhbmROb2RlLnR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBvZmZsaW5lIGlzIGVuYWJsZWQsIGVhY2ggbWVtYmVyIG9mIHRoZSBleHBhbmQgYXJyYXkgb3B0aW9uIG11c3QgaGF2ZSBhIGB0eXBlTmFtZWAgb3B0aW9uIHNldC4gIChFeHBhbmQgbm9kZSBpbmRleDogXCIgKyBpICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZEV4cHJlc3Npb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIGV4cGFuZEV4cHJlc3Npb25bZXhwYW5kTm9kZS5yZWxhdGlvbl0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVGFyZ2V0VHlwZU5hbWU6IGV4cGFuZE5vZGUudHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgRmlsdGVyOiBleHBhbmROb2RlLmZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBTb3J0OiBleHBhbmROb2RlLnNvcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgVGFrZTogZXhwYW5kTm9kZS50YWtlLFxyXG4gICAgICAgICAgICAgICAgICAgIFNraXA6IGV4cGFuZE5vZGUuc2tpcCxcclxuICAgICAgICAgICAgICAgICAgICBGaWVsZHM6IGV4cGFuZE5vZGUuZmllbGRzLFxyXG4gICAgICAgICAgICAgICAgICAgIFNpbmdsZUZpZWxkOiBleHBhbmROb2RlLnNpbmdsZUZpZWxkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1FeHBhbmQnOiBKU09OLnN0cmluZ2lmeShleHBhbmRFeHByZXNzaW9uKSxcclxuICAgICAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1TaW5nbGUtRmllbGQnOiBleHBhbmROb2RlLnJlbGF0aW9uXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFR5cGUgPSB0eXBlTmFtZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHlwZSA9IGV4cGFuZFtpIC0gMV0udHlwZU5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBhbmRTY2hlbWEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IGV4cGFuZE5vZGUucmVsYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZXJsaXZlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogcGFyZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBleHBhbmRTY2hlbWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRTY2hlbWEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IGdldFJlbGF0aW9uRmllbGRGb3JFeHBhbmROb2RlKGV4cGFuZE5vZGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJldmVybGl2ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGdldFVybEdlbmVyYXRvckZvck5vZGUoYmFzZVVybCwgZXhwYW5kLnNsaWNlKDAsIGkgKyAxKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnNGb3JFeHBhbmROb2RlKGV4cGFuZE5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZXhwYW5kU2NoZW1hXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvcHRpb25zLnR5cGUgPSAnZXZlcmxpdmUnO1xyXG4gICAgICAgIG9wdGlvbnMudHJhbnNwb3J0ID0ge1xyXG4gICAgICAgICAgICB0eXBlTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgIGRhdGFQcm92aWRlcjogdGhpc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgb3B0aW9ucy5zY2hlbWEgPSBleHBhbmRTY2hlbWE7XHJcbiAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChkYXRhU291cmNlT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKHRydWUsIG9wdGlvbnMsIGRhdGFTb3VyY2VPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBrZW5kby5kYXRhLkhpZXJhcmNoaWNhbERhdGFTb3VyY2Uob3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBjcmVhdGVEYXRhU291cmNlOiBjcmVhdGVEYXRhU291cmNlLFxyXG4gICAgICAgIGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2U6IGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2VcclxuICAgIH07XHJcbn0oKSk7IiwidmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG5cclxudmFyIGRlZXBFeHRlbmQgPSByZXF1aXJlKCcuL3VuZGVyc2NvcmVEZWVwRXh0ZW5kcycpO1xyXG52YXIgY29tcGFjdE9iamVjdCA9IHJlcXVpcmUoJy4vdW5kZXJzY29yZUNvbXBhY3RPYmplY3QnKTtcclxudmFyIGlzT2JqZWN0RW1wdHkgPSByZXF1aXJlKCcuL3VuZGVyc2NvcmVJc09iamVjdEVtcHR5Jyk7XHJcblxyXG5fLm1peGluKHsnZGVlcEV4dGVuZCc6IGRlZXBFeHRlbmR9KTtcclxuXy5taXhpbih7J2NvbXBhY3RPYmplY3QnOiBjb21wYWN0T2JqZWN0fSk7XHJcbl8ubWl4aW4oeydpc0VtcHR5T2JqZWN0JzogaXNPYmplY3RFbXB0eX0pOyIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG5cclxuLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0MDU4MTkzL3JlbW92ZS1lbXB0eS1wcm9wZXJ0aWVzLWZhbHN5LXZhbHVlcy1mcm9tLW9iamVjdC13aXRoLXVuZGVyc2NvcmUtanNcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21wYWN0T2JqZWN0KG8pIHtcclxuICAgIHZhciBuZXdPYmplY3QgPSB7fTtcclxuICAgIF8uZWFjaChvLCBmdW5jdGlvbih2LCBrKSB7XHJcbiAgICAgICAgaWYodiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbmV3T2JqZWN0W2tdID0gdlxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuZXdPYmplY3Q7XHJcbn07XHJcbiIsIi8qICBDb3B5cmlnaHQgKEMpIDIwMTItMjAxNCAgS3VydCBNaWxhbSAtIGh0dHA6Ly94aW91cC5jb20gfCBTb3VyY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE4Njg5NTVcclxuICogICBcclxuICogIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKiovXHJcblxyXG4vLyBCYXNlZCBjb25jZXB0dWFsbHkgb24gdGhlIF8uZXh0ZW5kKCkgZnVuY3Rpb24gaW4gdW5kZXJzY29yZS5qcyAoIHNlZSBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvI2V4dGVuZCBmb3IgbW9yZSBkZXRhaWxzIClcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVlcEV4dGVuZChvYmopIHtcclxuICAgIHZhciBwYXJlbnRSRSA9IC8je1xccyo/X1xccyo/fS8sXHJcbiAgICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG4gICAgXy5lYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG9ialtwcm9wXSkgfHwgXy5pc0Z1bmN0aW9uKG9ialtwcm9wXSkgfHwgXy5pc051bGwoc291cmNlW3Byb3BdKSB8fCBfLmlzRGF0ZShzb3VyY2VbcHJvcF0pKSB7XHJcbiAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoXy5pc1N0cmluZyhzb3VyY2VbcHJvcF0pICYmIHBhcmVudFJFLnRlc3Qoc291cmNlW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcob2JqW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXS5yZXBsYWNlKHBhcmVudFJFLCBvYmpbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8uaXNBcnJheShvYmpbcHJvcF0pIHx8IF8uaXNBcnJheShzb3VyY2VbcHJvcF0pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNBcnJheShvYmpbcHJvcF0pIHx8ICFfLmlzQXJyYXkoc291cmNlW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGNvbWJpbmUgYW4gYXJyYXkgd2l0aCBhIG5vbi1hcnJheSAoJyArIHByb3AgKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBfLnJlamVjdChfLmRlZXBFeHRlbmQoXy5jbG9uZShvYmpbcHJvcF0pLCBzb3VyY2VbcHJvcF0pLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5pc051bGwoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoXy5pc09iamVjdChvYmpbcHJvcF0pIHx8IF8uaXNPYmplY3Qoc291cmNlW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfLmlzT2JqZWN0KG9ialtwcm9wXSkgfHwgIV8uaXNPYmplY3Qoc291cmNlW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGNvbWJpbmUgYW4gb2JqZWN0IHdpdGggYSBub24tb2JqZWN0ICgnICsgcHJvcCArICcpJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IF8uZGVlcEV4dGVuZChfLmNsb25lKG9ialtwcm9wXSksIHNvdXJjZVtwcm9wXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmo7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVwZW5kZW5jeTogdW5kZXJzY29yZS5qcyAoIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS8gKVxyXG4gKlxyXG4gKiBNaXggaXQgaW4gd2l0aCB1bmRlcnNjb3JlLmpzOlxyXG4gKiBfLm1peGluKHtkZWVwRXh0ZW5kOiBkZWVwRXh0ZW5kfSk7XHJcbiAqXHJcbiAqIENhbGwgaXQgbGlrZSB0aGlzOlxyXG4gKiB2YXIgbXlPYmogPSBfLmRlZXBFeHRlbmQoZ3JhbmRwYXJlbnQsIGNoaWxkLCBncmFuZGNoaWxkLCBncmVhdGdyYW5kY2hpbGQpXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiBLZWVwIGl0IERSWS5cclxuICogVGhpcyBmdW5jdGlvbiBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBpZiB5b3UncmUgd29ya2luZyB3aXRoIEpTT04gY29uZmlnIGRvY3VtZW50cy4gSXQgYWxsb3dzIHlvdSB0byBjcmVhdGUgYSBkZWZhdWx0XHJcbiAqIGNvbmZpZyBkb2N1bWVudCB3aXRoIHRoZSBtb3N0IGNvbW1vbiBzZXR0aW5ncywgdGhlbiBvdmVycmlkZSB0aG9zZSBzZXR0aW5ncyBmb3Igc3BlY2lmaWMgY2FzZXMuIEl0IGFjY2VwdHMgYW55XHJcbiAqIG51bWJlciBvZiBvYmplY3RzIGFzIGFyZ3VtZW50cywgZ2l2aW5nIHlvdSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHlvdXIgY29uZmlnIGRvY3VtZW50IGhpZXJhcmNoeS5cclxuICpcclxuICogU3BlY2lhbCBGZWF0dXJlcyBhbmQgQ29uc2lkZXJhdGlvbnM6XHJcbiAqIC0gcGFyZW50UkUgYWxsb3dzIHlvdSB0byBjb25jYXRlbmF0ZSBzdHJpbmdzLiBleGFtcGxlOlxyXG4gKiAgIHZhciBvYmogPSBfLmRlZXBFeHRlbmQoe3VybDogXCJ3d3cuZXhhbXBsZS5jb21cIn0sIHt1cmw6IFwiaHR0cDovLyN7X30vcGF0aC90by9maWxlLmh0bWxcIn0pO1xyXG4gKiAgIGNvbnNvbGUubG9nKG9iai51cmwpO1xyXG4gKiAgIG91dHB1dDogXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vZmlsZS5odG1sXCJcclxuICpcclxuICogLSBwYXJlbnRSRSBhbHNvIGFjdHMgYXMgYSBwbGFjZWhvbGRlciwgd2hpY2ggY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIGNoYW5nZSBvbmUgdmFsdWUgaW4gYW4gYXJyYXksIHdoaWxlXHJcbiAqICAgbGVhdmluZyB0aGUgb3RoZXJzIHVudG91Y2hlZC4gZXhhbXBsZTpcclxuICogICB2YXIgYXJyID0gXy5kZWVwRXh0ZW5kKFsxMDAsICAgIHtpZDogMTIzNH0sIHRydWUsICBcImZvb1wiLCAgWzI1MCwgNTAwXV0sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBbXCIje199XCIsIFwiI3tffVwiLCAgICAgZmFsc2UsIFwiI3tffVwiLCBcIiN7X31cIl0pO1xyXG4gKiAgIGNvbnNvbGUubG9nKGFycik7XHJcbiAqICAgb3V0cHV0OiBbMTAwLCB7aWQ6IDEyMzR9LCBmYWxzZSwgXCJmb29cIiwgWzI1MCwgNTAwXV1cclxuICpcclxuICogLSBUaGUgcHJldmlvdXMgZXhhbXBsZSBjYW4gYWxzbyBiZSB3cml0dGVuIGxpa2UgdGhpczpcclxuICogICB2YXIgYXJyID0gXy5kZWVwRXh0ZW5kKFsxMDAsICAgIHtpZDoxMjM0fSwgICB0cnVlLCAgXCJmb29cIiwgIFsyNTAsIDUwMF1dLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiI3tffVwiLCB7fSwgICAgICAgICAgZmFsc2UsIFwiI3tffVwiLCBbXV0pO1xyXG4gKiAgIGNvbnNvbGUubG9nKGFycik7XHJcbiAqICAgb3V0cHV0OiBbMTAwLCB7aWQ6IDEyMzR9LCBmYWxzZSwgXCJmb29cIiwgWzI1MCwgNTAwXV1cclxuICpcclxuICogLSBBbmQgYWxzbyBsaWtlIHRoaXM6XHJcbiAqICAgdmFyIGFyciA9IF8uZGVlcEV4dGVuZChbMTAwLCAgICB7aWQ6MTIzNH0sICAgdHJ1ZSwgIFwiZm9vXCIsICBbMjUwLCA1MDBdXSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFtcIiN7X31cIiwge30sICAgICAgICAgIGZhbHNlXSk7XHJcbiAqICAgY29uc29sZS5sb2coYXJyKTtcclxuICogICBvdXRwdXQ6IFsxMDAsIHtpZDogMTIzNH0sIGZhbHNlLCBcImZvb1wiLCBbMjUwLCA1MDBdXVxyXG4gKlxyXG4gKiAtIEFycmF5IG9yZGVyIGlzIGltcG9ydGFudC4gZXhhbXBsZTpcclxuICogICB2YXIgYXJyID0gXy5kZWVwRXh0ZW5kKFsxLCAyLCAzLCA0XSwgWzEsIDQsIDMsIDJdKTtcclxuICogICBjb25zb2xlLmxvZyhhcnIpO1xyXG4gKiAgIG91dHB1dDogWzEsIDQsIDMsIDJdXHJcbiAqXHJcbiAqIC0gWW91IGNhbiByZW1vdmUgYW4gYXJyYXkgZWxlbWVudCBzZXQgaW4gYSBwYXJlbnQgb2JqZWN0IGJ5IHNldHRpbmcgdGhlIHNhbWUgaW5kZXggdmFsdWUgdG8gbnVsbCBpbiBhIGNoaWxkIG9iamVjdC5cclxuICogICBleGFtcGxlOlxyXG4gKiAgIHZhciBvYmogPSBfLmRlZXBFeHRlbmQoe2FycjogWzEsIDIsIDMsIDRdfSwge2FycjogW1wiI3tffVwiLCBudWxsXX0pO1xyXG4gKiAgIGNvbnNvbGUubG9nKG9iai5hcnIpO1xyXG4gKiAgIG91dHB1dDogWzEsIDMsIDRdXHJcbiAqXHJcbiAqKi8iLCIvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5OTQyMDEvaXMtb2JqZWN0LWVtcHR5XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcblxyXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xyXG5cclxuICAgIC8vIG51bGwgYW5kIHVuZGVmaW5lZCBhcmUgXCJlbXB0eVwiXHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIC8vIEFzc3VtZSBpZiBpdCBoYXMgYSBsZW5ndGggcHJvcGVydHkgd2l0aCBhIG5vbi16ZXJvIHZhbHVlXHJcbiAgICAvLyB0aGF0IHRoYXQgcHJvcGVydHkgaXMgY29ycmVjdC5cclxuICAgIGlmIChvYmoubGVuZ3RoID4gMCkgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKG9iai5sZW5ndGggPT09IDApICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAvLyBPdGhlcndpc2UsIGRvZXMgaXQgaGF2ZSBhbnkgcHJvcGVydGllcyBvZiBpdHMgb3duP1xyXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgZG9lc24ndCBoYW5kbGVcclxuICAgIC8vIHRvU3RyaW5nIGFuZCB2YWx1ZU9mIGVudW1lcmF0aW9uIGJ1Z3MgaW4gSUUgPCA5XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG52YXIgYnVpbGRQcm9taXNlID0gdXRpbHMuYnVpbGRQcm9taXNlO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcmVxd2VzdCA9IGNvbW1vbi5yZXF3ZXN0O1xyXG52YXIgdXVpZCA9IGNvbW1vbi51dWlkO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxudmFyIENyeXB0b0pTID0gcmVxdWlyZSgnbm9kZS1jcnlwdG9qcy1hZXMnKS5DcnlwdG9KUztcclxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKTtcclxudmFyIEV2ZXJsaXZlRXJyb3JzID0gZXJyb3JzLkV2ZXJsaXZlRXJyb3JzO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IGVycm9ycy5FdmVybGl2ZUVycm9yO1xyXG52YXIgQXV0b1F1ZXVlID0gcmVxdWlyZSgnLi4vQXV0b1F1ZXVlJyk7XHJcblxyXG52YXIgT2ZmbGluZUZpbGVzTW9kdWxlID0gZnVuY3Rpb24gKG9mZmxpbmVGaWxlc1Byb2Nlc3NvciwgZXZlcmxpdmUsIGRvd25sb2Fkc0NvbmN1cnJlbmN5KSB7XHJcbiAgICB0aGlzLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IgPSBvZmZsaW5lRmlsZXNQcm9jZXNzb3I7XHJcbiAgICB0aGlzLl9ldmVybGl2ZSA9IGV2ZXJsaXZlO1xyXG4gICAgdGhpcy5fZG93bmxvYWRzUXVldWUgPSBuZXcgQXV0b1F1ZXVlKGRvd25sb2Fkc0NvbmN1cnJlbmN5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgT2ZmbGluZUZpbGVzTW9kdWxlXHJcbiAqIEBjbGFzc2Rlc2MgQSBjbGFzcyB0aGF0IHByb3ZpZGVzIHRoZSBtZWFucyB0byBvcGVyYXRlIHdpdGggZmlsZXMgaW4gb2ZmbGluZSBtb2RlLlxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqL1xyXG5PZmZsaW5lRmlsZXNNb2R1bGUucHJvdG90eXBlID0ge1xyXG4gICAgX2dldEZpbGVuYW1lTWV0YWRhdGE6IGZ1bmN0aW9uIChsb2NhdGlvbiwgb2ZmbGluZUZpbGVJbmZvKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICByZXF3ZXN0KHtcclxuICAgICAgICAgICAgICAgIHVybDogbG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY3Jvc3NEb21haW46IHRydWVcclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoeG1sUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50RGlzcG9zaXRpb25IZWFkZXIgPSB4bWxSZXNwb25zZS5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1EaXNwb3NpdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gL2ZpbGVuYW1lPVwiPyhbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCI/L2kuZXhlYyhjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobWF0Y2hlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmbGluZUZpbGVJbmZvLmZpbGVuYW1lID0gbWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVGaWxlSW5mby5maWxlbmFtZSA9IHBhdGguYmFzZW5hbWUoeG1sUmVzcG9uc2UucmVzcG9uc2VVUkwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoeG1sUmVzcG9uc2UucmVzcG9uc2VVUkwpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgYSBmaWxlJ3MgY29udGVudC5cclxuICAgICAqIEBtZW1iZXJvZiBPZmZsaW5lRmlsZXNNb2R1bGUucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGRvd25sb2FkT2ZmbGluZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIEEgZmlsZSBsb2NhdGlvbiBvciB0aGUgaWQgb2YgYSBmaWxlIHN0b3JlZCBpbiBCYWNrZW5kIFNlcnZpY2VzLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvdmVyd3JpdGUgQm9vbGVhbiBvcHRpb24gdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZmlsZSBzaG91bGQgYmUgb3ZlcndyaXR0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdHMgb2ZmbGluZS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGEgZmlsZSdzIGNvbnRlbnQuXHJcbiAgICAgKiBAbWVtYmVyb2YgT2ZmbGluZUZpbGVzTW9kdWxlLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBkb3dubG9hZE9mZmxpbmVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBBIGZpbGUgbG9jYXRpb24gb3IgdGhlIGlkIG9mIGEgZmlsZSBzdG9yZWQgaW4gQmFja2VuZCBTZXJ2aWNlcy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlIEJvb2xlYW4gb3B0aW9uIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGZpbGUgc2hvdWxkIGJlIG92ZXJ3cml0dGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzIG9mZmxpbmUuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgZG93bmxvYWRPZmZsaW5lOiBmdW5jdGlvbiAobG9jYXRpb24sIG92ZXJ3cml0ZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX2Rvd25sb2Fkc1F1ZXVlLmVucXVldWUoZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2ZmbGluZUZpbGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldE9mZmxpbmVGaWxlSW5mbyhsb2NhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX29mZmxpbmVGaWxlSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZsaW5lRmlsZUluZm8gPSBfb2ZmbGluZUZpbGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmV4aXN0c09mZmxpbmUobG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2V2ZXJsaXZlLmlzT25saW5lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuc3VjY2Vzc2Z1bFByb21pc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9mZmxpbmVGaWxlSW5mby5maWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRGaWxlbmFtZU1ldGFkYXRhKGxvY2F0aW9uLCBvZmZsaW5lRmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobG9jYXRpb25BZnRlclJlZGlyZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBsb2NhdGlvbkFmdGVyUmVkaXJlY3QgfHwgb2ZmbGluZUZpbGVJbmZvLmxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3NhdmVGaWxlKGxvY2F0aW9uLCBvZmZsaW5lRmlsZUluZm8uZmlsZW5hbWUsIG51bGwsIG9mZmxpbmVGaWxlSW5mby5sb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFdmVybGl2ZUVycm9yKEV2ZXJsaXZlRXJyb3JzLmNhbm5vdERvd25sb2FkT2ZmbGluZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldE9mZmxpbmVGaWxlSW5mbyhsb2NhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldE9mZmxpbmVMb2NhdGlvbihmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChjYik7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIF9zYXZlRmlsZTogZnVuY3Rpb24gKGxvY2F0aW9uLCBmaWxlbmFtZSwgaWQsIGNhY2hlS2V5KSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhY3R1YWxMb2NhdGlvbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX2Rvd25sb2FkRmlsZShsb2NhdGlvbiwgZmlsZW5hbWUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYWN0dWFsTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGFjdHVhbExvY2F0aW9uID0gX2FjdHVhbExvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5nZXRPZmZsaW5lRmlsZXNEYXRhKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvZmZsaW5lRmlsZXNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBvZmZsaW5lRmlsZXNEYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVMb2NhdGlvbjogYWN0dWFsTG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgb25saW5lTG9jYXRpb246IGNhY2hlS2V5IHx8IGxvY2F0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5zYXZlT2ZmbGluZUZpbGVzRGF0YSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsTG9jYXRpb247XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBoeXNpY2FsbHkgZGVsZXRlcyB0aGUgb2ZmbGluZSBjb3BpZXMgb2YgYWxsIGZpbGVzLlxyXG4gICAgICogQG1lbWJlcm9mIE9mZmxpbmVGaWxlc01vZHVsZS5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgcHVyZ2VBbGxcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUGh5c2ljYWxseSBkZWxldGVzIHRoZSBvZmZsaW5lIGNvcGllcyBvZiBhbGwgZmlsZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgT2ZmbGluZUZpbGVzTW9kdWxlLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBwdXJnZUFsbFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIHB1cmdlQWxsOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiB1dGlscy5idWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5maWxlU3RvcmUucmVtb3ZlRmlsZXNEaXJlY3RvcnkoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuZmlsZXNNZXRhU3RvcmUucmVtb3ZlRmlsZXNEaXJlY3RvcnkoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yLl9vZmZsaW5lRmlsZXNEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihzdWNjZXNzKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXRPZmZsaW5lTG9jYXRpb246IGZ1bmN0aW9uIChmaWxlSW5mbykge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgdXJsID0gZmlsZUluZm8ubG9jYXRpb247XHJcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZmlsZUluZm8uZmlsZW5hbWU7XHJcbiAgICAgICAgdmFyIGlkID0gZmlsZUluZm8uSWQ7XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuZ2V0T2ZmbGluZUxvY2F0aW9uKHVybCwgaWQpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvZmZsaW5lVXJsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2ZmbGluZVVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lVXJsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIHVybCBpcyBwcm92aWRlZCB0aGlzIG1lYW5zIHRoYXQgdGhlIGZpbGUgZXhpc3RzIG9ubHkgb2ZmbGluZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIFVyaSBmaWVsZCBoYXMgbm90IGJlZW4gcG9wdWxhdGVkIGJ5IHRoZSBzZXJ2ZXJcclxuICAgICAgICAgICAgICAgIGlmIChpZCAmJiAhdXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldEZpbGVVcmxGb3JJZChpZCwgZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2Rvd25sb2FkRmlsZTogZnVuY3Rpb24gKHVybCwgbmFtZSkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgLy8gVE9ETzogW29mZmxpbmVdIHRoaXMgd2lsbCBub3Qgd29yayBpbiBOYXRpdmVTY3JpcHQgYXQgdGhlIG1vbWVudFxyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGZpbGVUcmFuc2ZlciA9IG5ldyBGaWxlVHJhbnNmZXIoKTtcclxuICAgICAgICAgICAgdmFyIHNhbml0aXplZFVybCA9IHNlbGYuX3Nhbml0aXplVXJsKHVybCk7XHJcbiAgICAgICAgICAgIHZhciBmaWxlSWQgPSBwYXRoLmJhc2VuYW1lKHNhbml0aXplZFVybCk7XHJcbiAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSBwYXRoLmV4dG5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGZpbGVJZDtcclxuICAgICAgICAgICAgaWYgKHBhdGguZXh0bmFtZShzYW5pdGl6ZWRVcmwpICE9PSBleHRlbnNpb24pIHtcclxuICAgICAgICAgICAgICAgIGZpbGVuYW1lICs9IGV4dGVuc2lvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGZpbGVQYXJlbnREaXJlY3RvcnkgPSAnJztcclxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc0d1aWQodXJsKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVJZEluZGV4ID0gdXJsLmxhc3RJbmRleE9mKGZpbGVJZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmFzZVVybCA9IHVybC5zdWJzdHIoMCwgZmlsZUlkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZmlsZVBhcmVudERpcmVjdG9yeSA9IENyeXB0b0pTLk1ENShiYXNlVXJsKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yLmZpbGVTdG9yZS5nZXREYXRhRGlyZWN0b3J5KClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhRGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmpvaW5QYXRoKGRhdGFEaXIubmF0aXZlVVJMLCBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuZmlsZVN0b3JlLmZpbGVzRGlyZWN0b3J5UGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhcmVudERpcmVjdG9yeSwgZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVUcmFuc2Zlci5kb3dubG9hZCh1cmwsIGxvY2F0aW9uLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCwgdHJ1ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLl9ldmVybGl2ZS5idWlsZEF1dGhIZWFkZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBfc2FuaXRpemVVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICBpZiAoIXVybCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNhbml0aXplZFVybCA9IGVuY29kZVVSSSh1cmwpO1xyXG4gICAgICAgIHZhciBxdWVzdGlvbk1hcmtJbmRleCA9IHNhbml0aXplZFVybC5sYXN0SW5kZXhPZignPycpO1xyXG4gICAgICAgIGlmIChxdWVzdGlvbk1hcmtJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgc2FuaXRpemVkVXJsID0gc2FuaXRpemVkVXJsLnN1YnN0cigwLCBxdWVzdGlvbk1hcmtJbmRleCk7IC8vbGludXggZG9lcyBub3QgYWxsb3cgcXVlc3Rpb24gbWFya3MgaW4gaXRzIGZpbGVuYW1lc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNhbml0aXplZFVybDtcclxuICAgIH0sXHJcblxyXG4gICAgX2dldEZpbGVVcmxGb3JJZDogZnVuY3Rpb24gKGZpbGVJZCwgZmlsZW5hbWUpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuZmlsZVN0b3JlLmdldERhdGFEaXJlY3RvcnkoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YURpcmVjdG9yeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVFeHRlbnNpb24gPSBwYXRoLmV4dG5hbWUoZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmpvaW5QYXRoKGRhdGFEaXJlY3RvcnkubmF0aXZlVVJMLCBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuZmlsZVN0b3JlLmZpbGVzRGlyZWN0b3J5UGF0aCwgZmlsZUlkICsgZmlsZUV4dGVuc2lvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIGZpbGUgZXhpc3RzIG9mZmxpbmUuXHJcbiAgICAgKiBAbWVtYmVyb2YgT2ZmbGluZUZpbGVzTW9kdWxlLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBleGlzdHNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhdGlvbiBUaGUgbG9jYXRpb24gb3IgZmlsZSBpZCB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYSBmaWxlIGV4aXN0cyBvZmZsaW5lLlxyXG4gICAgICogQG1lbWJlcm9mIE9mZmxpbmVGaWxlc01vZHVsZS5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgZXhpc3RzXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYXRpb24gVGhlIGxvY2F0aW9uIG9yIGZpbGUgaWQgdG8gY2hlY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgZXhpc3RzT2ZmbGluZTogZnVuY3Rpb24gKGxvY2F0aW9uLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgc2VsZi5fZ2V0T2ZmbGluZUZpbGVJbmZvKGxvY2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbGVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldE9mZmxpbmVMb2NhdGlvbihmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9mZmxpbmVVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2ZmbGluZVVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yLmZpbGVTdG9yZS5nZXRGaWxlQnlBYnNvbHV0ZVBhdGgob2ZmbGluZVVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvZmZsaW5lRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIW9mZmxpbmVGaWxlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuaXRlbU5vdEZvdW5kLmNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3MoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBoeXNpY2FsbHkgZGVsZXRlcyB0aGUgb2ZmbGluZSBjb3B5IG9mIGEgZmlsZS5cclxuICAgICAqIEBtZW1iZXJvZiBPZmZsaW5lRmlsZXNNb2R1bGUucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHB1cmdlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYXRpb24gVGhlIGxvY2F0aW9uIG9yIGZpbGUgaWQgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBQaHlzaWNhbGx5IGRlbGV0ZXMgdGhlIG9mZmxpbmUgY29weSBvZiBhIGZpbGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgT2ZmbGluZUZpbGVzTW9kdWxlLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBwdXJnZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvY2F0aW9uIFRoZSBsb2NhdGlvbiBvciBmaWxlIGlkIHRvIGNoZWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIHB1cmdlOiBmdW5jdGlvbiAobG9jYXRpb24sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICBzZWxmLl9nZXRPZmZsaW5lRmlsZUluZm8obG9jYXRpb24pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0T2ZmbGluZUxvY2F0aW9uKGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5wdXJnZShsb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgVVJMIGZvciBhIGZpbGUgdGhhdCBpcyBzdG9yZWQgb2ZmbGluZS5cclxuICAgICAqIEBtZW1iZXJvZiBPZmZsaW5lRmlsZXNNb2R1bGUucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGdldE9mZmxpbmVMb2NhdGlvblxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvY2F0aW9uIFRoZSBsb2NhdGlvbiBvciBmaWxlIGlkIHRvIHByb2Nlc3MuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIFVSTCBmb3IgYSBmaWxlIHRoYXQgaXMgc3RvcmVkIG9mZmxpbmUuXHJcbiAgICAgKiBAbWVtYmVyb2YgT2ZmbGluZUZpbGVzTW9kdWxlLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBnZXRPZmZsaW5lTG9jYXRpb25cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhdGlvbiBUaGUgbG9jYXRpb24gb3IgZmlsZSBpZCB0byBwcm9jZXNzLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIGdldE9mZmxpbmVMb2NhdGlvbjogZnVuY3Rpb24gKGxvY2F0aW9uLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgc2VsZi5fZ2V0T2ZmbGluZUZpbGVJbmZvKGxvY2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oc2VsZi5fZ2V0T2ZmbGluZUxvY2F0aW9uLmJpbmQoc2VsZikpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmxpbmVMb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5leGlzdHNPZmZsaW5lKG9mZmxpbmVMb2NhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChleGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lTG9jYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcclxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfZ2V0T2ZmbGluZUZpbGVJbmZvOiBmdW5jdGlvbiAobG9jYXRpb24pIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNhbml0aXplZFVybCA9IHRoaXMuX3Nhbml0aXplVXJsKGxvY2F0aW9uKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzZWxmLl9ldmVybGl2ZS5GaWxlc1xyXG4gICAgICAgICAgICAgICAgLmlzU3luYyh0cnVlKVxyXG4gICAgICAgICAgICAgICAgLnVzZU9mZmxpbmUodHJ1ZSlcclxuICAgICAgICAgICAgICAgIC5nZXRCeUlkKHNhbml0aXplZFVybClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gcmVzcG9uc2UucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogZmlsZS5VcmksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlLkZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBJZDogc2FuaXRpemVkVXJsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5pdGVtTm90Rm91bmQuY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgY2hhbmdlRmlsZUV4dGVuc2lvbkJ5SWQ6IGZ1bmN0aW9uIChpZCwgZXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2VsZi5fY2hhbmdlRXh0ZW5zaW9uKGlkLCBleHRlbnNpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY2hhbmdlRXh0ZW5zaW9uOiBmdW5jdGlvbiAoaWQsIG5ld0V4dGVuc2lvbikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIGRhdGFEaXI7XHJcblxyXG4gICAgICAgIHZhciBmaWxlU3RvcmUgPSBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuZmlsZVN0b3JlO1xyXG4gICAgICAgIHZhciBmaWxlTmFtZSA9IGlkICsgbmV3RXh0ZW5zaW9uO1xyXG4gICAgICAgIHJldHVybiBmaWxlU3RvcmUuZ2V0RmlsZXNEaXJlY3RvcnkoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGlyZWN0b3J5RW50cnkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFEaXIgPSBkaXJlY3RvcnlFbnRyeTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldE9mZmxpbmVMb2NhdGlvbihpZCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChsb2NhbFBhdGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdGaWxlTmFtZSA9IHBhdGguYmFzZW5hbWUobG9jYWxQYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0ZpbGVOYW1lICE9PSBmaWxlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlU3RvcmUuZ2V0RmlsZUJ5QWJzb2x1dGVQYXRoKGxvY2FsUGF0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVTdG9yZS5yZW5hbWVGaWxlKGRhdGFEaXIsIGZpbGVFbnRyeSwgZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yLmdldE9mZmxpbmVGaWxlc0RhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9mZmxpbmVGaWxlc0RhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwZWRFbnRyeSA9IF8uZmluZFdoZXJlKG9mZmxpbmVGaWxlc0RhdGEsIHtvZmZsaW5lTG9jYXRpb246IGxvY2FsUGF0aH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXBwZWRFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdDb3VsZCBub3QgZmluZCBhIGNhY2hlZCBsb2NhdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBmaWxlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0xvY2F0aW9uID0gbWFwcGVkRW50cnkub2ZmbGluZUxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzRXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKHByZXZpb3VzTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbExvY2F0aW9uID0gcHJldmlvdXNMb2NhdGlvbi5zbGljZSgwLCBwcmV2aW91c0xvY2F0aW9uLmxlbmd0aCAtIHByZXZpb3VzRXh0ZW5zaW9uLmxlbmd0aCkgKyBuZXdFeHRlbnNpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWRFbnRyeS5vZmZsaW5lTG9jYXRpb24gPSBhY3R1YWxMb2NhdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yLnNhdmVPZmZsaW5lRmlsZXNEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2ZmbGluZUZpbGVzTW9kdWxlOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFdmVybGl2ZUVycm9yTW9kdWxlID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IEV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcjtcclxudmFyIEV2ZXJsaXZlRXJyb3JzID0gRXZlcmxpdmVFcnJvck1vZHVsZS5FdmVybGl2ZUVycm9ycztcclxudmFyIEZpbGVTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3JhZ2VzL0ZpbGVTdG9yZScpO1xyXG52YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcblxyXG52YXIgRklMRVNfTUVUQURBVEFfRklMRV9OQU1FID0gJ2ZpbGVzTWV0YWRhdGFNYXAnO1xyXG5cclxudmFyIE9mZmxpbmVGaWxlc1Byb2Nlc3NvciA9IGZ1bmN0aW9uIChzZXR1cCwgZXZlcmxpdmUpIHtcclxuICAgIHRoaXMuZmlsZVN0b3JlID0gbmV3IEZpbGVTdG9yZShzZXR1cC5maWxlcy5zdG9yYWdlUGF0aCwgc2V0dXApO1xyXG4gICAgdGhpcy5maWxlc01ldGFTdG9yZSA9IG5ldyBGaWxlU3RvcmUoc2V0dXAuZmlsZXMubWV0YVBhdGgsIHNldHVwKTtcclxuICAgIHRoaXMuX2V2ZXJsaXZlID0gZXZlcmxpdmU7XHJcbn07XHJcblxyXG5PZmZsaW5lRmlsZXNQcm9jZXNzb3IucHJvdG90eXBlID0ge1xyXG4gICAgdmFsaWRhdGVGaWxlQ3JlYXRlT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBpc1N5bmMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICghb2JqLmJhc2U2NCAmJiAhaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFdmVybGl2ZUVycm9yKEV2ZXJsaXZlRXJyb3JzLm1pc3NpbmdPckludmFsaWRGaWxlQ29udGVudCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvYmouQ29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IoRXZlcmxpdmVFcnJvcnMubWlzc2luZ0NvbnRlbnRUeXBlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9iai5GaWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBbb2ZmbGluZV0gYWRkIGFuIGFwcHJvcHJpYXRlIGVycm9yXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFdmVybGl2ZUVycm9yKEV2ZXJsaXZlRXJyb3JzLmludmFsaWRSZXF1ZXN0KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0T2ZmbGluZUZpbGVzRGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYuX29mZmxpbmVGaWxlc0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbGVzTWV0YVN0b3JlLmdldEZpbGUoRklMRVNfTUVUQURBVEFfRklMRV9OQU1FKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtZXRhZGF0YUZpbGVIYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsZXNNZXRhU3RvcmUucmVhZEZpbGVBc1RleHQobWV0YWRhdGFGaWxlSGFuZGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtZXRhZGF0YVRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YVRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVGV4dCA9ICdbXSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29mZmxpbmVGaWxlc0RhdGEgPSBKU09OLnBhcnNlKG1ldGFkYXRhVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fb2ZmbGluZUZpbGVzRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fb2ZmbGluZUZpbGVzRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2F2ZU9mZmxpbmVGaWxlc0RhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmLmdldE9mZmxpbmVGaWxlc0RhdGEoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUZpbGVzRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsZXNNZXRhU3RvcmUud3JpdGVUZXh0KEZJTEVTX01FVEFEQVRBX0ZJTEVfTkFNRSwgSlNPTi5zdHJpbmdpZnkob2ZmbGluZUZpbGVzRGF0YSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBzZXJ0RmlsZUZyb21PYmplY3Q6IGZ1bmN0aW9uIChvYmosIGlzQ3JlYXRlLCBpc1N5bmMpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmICghaXNTeW5jKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NyZWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvYmouYmFzZTY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnJlamVjdGVkUHJvbWlzZShuZXcgRXZlcmxpdmVFcnJvcihFdmVybGl2ZUVycm9ycy5taXNzaW5nT3JJbnZhbGlkRmlsZUNvbnRlbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5Db250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5yZWplY3RlZFByb21pc2UobmV3IEV2ZXJsaXZlRXJyb3IoRXZlcmxpdmVFcnJvcnMubWlzc2luZ0NvbnRlbnRUeXBlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5iYXNlNjQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuc3VjY2Vzc2Z1bFByb21pc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFvYmouYmFzZTY0KSB7XHJcbiAgICAgICAgICAgIHZhciBpZCA9IHV0aWxzLmdldElkKG9iaik7XHJcbiAgICAgICAgICAgIHZhciB1cmk7XHJcbiAgICAgICAgICAgIHZhciBkb3dubG9hZEZpbGVQcm9taXNlID0gb2JqLlVyaSA/IHV0aWxzLnN1Y2Nlc3NmdWxQcm9taXNlKG9iai5VcmkpIDpcclxuICAgICAgICAgICAgICAgIHNlbGYuX2V2ZXJsaXZlLmZpbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgLmlzU3luYyhpc1N5bmMpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0RG93bmxvYWRVcmxCeUlkKGlkKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkb3dubG9hZEZpbGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKF91cmkpIHtcclxuICAgICAgICAgICAgICAgIHVyaSA9IF91cmk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZXZlcmxpdmUub2ZmbGluZVN0b3JhZ2UuZmlsZXMuZXhpc3RzT2ZmbGluZShpZCk7XHJcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZXZlcmxpdmUub2ZmbGluZVN0b3JhZ2UuZmlsZXMuX3NhdmVGaWxlKHVyaSwgb2JqLkZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvYmouU3RvcmFnZSA9ICdpbnRlcm5hbCc7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnN1Y2Nlc3NmdWxQcm9taXNlKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi52YWxpZGF0ZUZpbGVDcmVhdGVPYmplY3Qob2JqLCBpc1N5bmMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvbmxpbmVMb2NhdGlvbiA9IG9iai5Vcmk7XHJcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHNlbGYuZ2V0RmlsZW5hbWVGb3JPYmplY3Qob2JqKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZsaW5lRmlsZUluZm87XHJcbiAgICAgICAgICAgIHZhciBiYXNlNjRDb250ZW50cyA9IG9iai5iYXNlNjQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouYmFzZTY0O1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gdXRpbHMuYjY0dG9CbG9iKGJhc2U2NENvbnRlbnRzLCBvYmouQ29udGVudFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYud3JpdGVGaWxlKGZpbGVuYW1lLCBjb250ZW50cylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmaWxlSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVGaWxlSW5mbyA9IGZpbGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldE9mZmxpbmVGaWxlc0RhdGEoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUZpbGVzRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVGaWxlc0RhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZmxpbmVMb2NhdGlvbjogb2ZmbGluZUZpbGVJbmZvLm9mZmxpbmVMb2NhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25saW5lTG9jYXRpb246IG9ubGluZUxvY2F0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogb2JqLl9pZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvYmouTGVuZ3RoID0gb2ZmbGluZUZpbGVJbmZvLnNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2F2ZU9mZmxpbmVGaWxlc0RhdGEoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBwdXJnZTogZnVuY3Rpb24gKGxvY2FsTG9jYXRpb24pIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE9mZmxpbmVGaWxlc0RhdGEoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUZpbGVzRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZmxpbmVGaWxlID0gXy53aGVyZShvZmZsaW5lRmlsZXNEYXRhLCB7b2ZmbGluZUxvY2F0aW9uOiBsb2NhbExvY2F0aW9ufSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogW29mZmxpbmVdIGNoZWNrIGlmIHRoZSBsZW5ndGggb2Ygb2ZmbGluZUZpbGUgPT09IDBcclxuICAgICAgICAgICAgICAgIHZhciBvZmZsaW5lSW5mb0luZGV4ID0gb2ZmbGluZUZpbGVzRGF0YS5pbmRleE9mKG9mZmxpbmVGaWxlWzBdKTtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZsaW5lSW5mb0luZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVGaWxlc0RhdGEuc3BsaWNlKG9mZmxpbmVJbmZvSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNhdmVPZmZsaW5lRmlsZXNEYXRhKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbGVTdG9yZS5nZXRGaWxlQnlBYnNvbHV0ZVBhdGgobG9jYWxMb2NhdGlvbik7XHJcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsZVN0b3JlLnJlbW92ZUZpbGUoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICB3cml0ZUZpbGU6IGZ1bmN0aW9uIChmaWxlbmFtZSwgY29udGVudHMsIGZvbGRlcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgb2ZmbGluZUxvY2F0aW9uO1xyXG5cclxuICAgICAgICByZXR1cm4gc2VsZi5maWxlU3RvcmUud3JpdGVUZXh0KGZpbGVuYW1lLCBjb250ZW50cywgZm9sZGVyKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobG9jYXRpb25PbkRpc2spIHtcclxuICAgICAgICAgICAgICAgIG9mZmxpbmVMb2NhdGlvbiA9IGxvY2F0aW9uT25EaXNrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2F2ZU9mZmxpbmVGaWxlc0RhdGEoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsZVN0b3JlLmdldEZpbGVTaXplKGZpbGVuYW1lLCBmb2xkZXIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVMb2NhdGlvbjogb2ZmbGluZUxvY2F0aW9uXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RmlsZW5hbWVGb3JPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKG9iai5GaWxlbmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG9iai5faWQgKyBleHRlbnNpb247XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE9mZmxpbmVMb2NhdGlvbjogZnVuY3Rpb24gKHVybCwgaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRPZmZsaW5lRmlsZXNEYXRhKClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9mZmxpbmVGaWxlc0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdXJsICYmICFpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZmxpbmVGaWxlc0RhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZUVudHJ5ID0gb2ZmbGluZUZpbGVzRGF0YVtpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsTWF0Y2hlcyA9ICh1cmwgJiYgKGZpbGVFbnRyeS5vZmZsaW5lTG9jYXRpb24gPT09IHVybCB8fCBmaWxlRW50cnkub25saW5lTG9jYXRpb24gPT09IHVybCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZE1hdGNoZXMgPSAoaWQgJiYgZmlsZUVudHJ5LmlkID09PSBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybE1hdGNoZXMgfHwgaWRNYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlRW50cnkub2ZmbGluZUxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZmxpbmVGaWxlc1Byb2Nlc3NvcjsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcbnZhciBvZmZsaW5lVHJhbnNmb3JtYXRpb25zID0gcmVxdWlyZSgnLi9vZmZsaW5lVHJhbnNmb3JtYXRpb25zJyk7XHJcbnZhciBleHBhbmRQcm9jZXNzb3IgPSByZXF1aXJlKCcuLi9FeHBhbmRQcm9jZXNzb3InKTtcclxuXHJcbnZhciBldmVybGl2ZUVycm9yTW9kdWxlID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IGV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcjtcclxudmFyIEV2ZXJsaXZlRXJyb3JzID0gZXZlcmxpdmVFcnJvck1vZHVsZS5FdmVybGl2ZUVycm9ycztcclxuXHJcbnZhciBidWlsZFByb21pc2UgPSByZXF1aXJlKCcuLi91dGlscycpLmJ1aWxkUHJvbWlzZTtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgbWluZ28gPSBjb21tb24uTWluZ287XHJcbnZhciBtb25nb1F1ZXJ5ID0gY29tbW9uLm1vbmdvUXVlcnk7XHJcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L1F1ZXJ5Jyk7XHJcblxyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuXHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxudmFyIEhlYWRlcnMgPSBjb25zdGFudHMuSGVhZGVycztcclxudmFyIG9mZmxpbmVJdGVtU3RhdGVzID0gY29uc3RhbnRzLm9mZmxpbmVJdGVtU3RhdGVzO1xyXG5cclxudmFyIHVuc3VwcG9ydGVkT2ZmbGluZUhlYWRlcnMgPSBbSGVhZGVycy5wb3dlckZpZWxkc107XHJcblxyXG52YXIgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnMgPSB7fTtcclxudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlXSA9IHRydWU7XHJcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZV0gPSB0cnVlO1xyXG51bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVdID0gdHJ1ZTtcclxudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlXSA9IHRydWU7XHJcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJhd1VwZGF0ZV0gPSB0cnVlO1xyXG51bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy5zZXRBY2xdID0gdHJ1ZTtcclxudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0T3duZXJdID0gdHJ1ZTtcclxudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ2luV2l0aFByb3ZpZGVyXSA9IHRydWU7XHJcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMaW5rV2l0aFByb3ZpZGVyXSA9IHRydWU7XHJcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJVbmxpbmtGcm9tUHJvdmlkZXJdID0gdHJ1ZTtcclxudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ2luXSA9IHRydWU7XHJcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dvdXRdID0gdHJ1ZTtcclxudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckNoYW5nZVBhc3N3b3JkXSA9IHRydWU7XHJcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJSZXNldFBhc3N3b3JkXSA9IHRydWU7XHJcblxyXG5mdW5jdGlvbiBidWlsZFVzZXJzRXJyb3JNZXNzYWdlKGRhdGFRdWVyeSkge1xyXG4gICAgdmFyIHVuc3VwcG9ydGVkVXNlclNvY2lhbFByb3ZpZGVyT3BlcmF0aW9ucyA9IFtcclxuICAgICAgICBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5XaXRoUHJvdmlkZXIsXHJcbiAgICAgICAgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxpbmtXaXRoUHJvdmlkZXIsXHJcbiAgICAgICAgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlclVubGlua0Zyb21Qcm92aWRlclxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgb3BlcmF0aW9uID0gZGF0YVF1ZXJ5Lm9wZXJhdGlvbjtcclxuICAgIGlmICh1bnN1cHBvcnRlZFVzZXJTb2NpYWxQcm92aWRlck9wZXJhdGlvbnMuaW5kZXhPZihvcGVyYXRpb24pICE9PSAtMSkge1xyXG4gICAgICAgIG9wZXJhdGlvbiArPSBkYXRhUXVlcnkuZGF0YS5Qcm92aWRlciB8fCBkYXRhUXVlcnkuZGF0YS5JZGVudGl0eS5Qcm92aWRlcjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJ1RoZSBVc2VycyBvcGVyYXRpb24gJyArIG9wZXJhdGlvbiArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBidWlsZEZpbGVzRXJyb3JNZXNzYWdlKGRhdGFRdWVyeSkge1xyXG4gICAgcmV0dXJuICdUaGUgRmlsZXMgb3BlcmF0aW9uICcgKyBkYXRhUXVlcnkub3BlcmF0aW9uICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZSc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE9mZmxpbmVRdWVyeVByb2Nlc3NvcihwZXJzaXN0ZXIsIGVuY3J5cHRpb25Qcm92aWRlciwgb2ZmbGluZUZpbGVzUHJvY2Vzc29yLCBldmVybGl2ZSwgc2V0dXApIHtcclxuICAgIHRoaXMuX2NvbGxlY3Rpb25DYWNoZSA9IHt9O1xyXG4gICAgdGhpcy5vZmZsaW5lRmlsZXNQcm9jZXNzb3IgPSBvZmZsaW5lRmlsZXNQcm9jZXNzb3I7XHJcbiAgICB0aGlzLl9wZXJzaXN0ZXIgPSBwZXJzaXN0ZXI7XHJcbiAgICB0aGlzLl9lbmNyeXB0aW9uUHJvdmlkZXIgPSBlbmNyeXB0aW9uUHJvdmlkZXI7XHJcbiAgICB0aGlzLmV2ZXJsaXZlID0gZXZlcmxpdmU7XHJcbiAgICB0aGlzLnNldHVwID0gc2V0dXA7XHJcbn1cclxuXHJcbk9mZmxpbmVRdWVyeVByb2Nlc3Nvci5wcm90b3R5cGUgPSB7XHJcbiAgICBwcm9jZXNzUXVlcnk6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgdW5zdXBwb3J0ZWRDbGllbnRPcE1lc3NhZ2UgPSB0aGlzLmdldFVuc3VwcG9ydGVkQ2xpZW50T3BNZXNzYWdlKGRhdGFRdWVyeSk7XHJcbiAgICAgICAgaWYgKHVuc3VwcG9ydGVkQ2xpZW50T3BNZXNzYWdlICYmICFkYXRhUXVlcnkuaXNTeW5jKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcih1bnN1cHBvcnRlZENsaWVudE9wTWVzc2FnZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBxdWVyeVBhcmFtcyA9IGRhdGFRdWVyeS5nZXRRdWVyeVBhcmFtZXRlcnMoKTtcclxuICAgICAgICB2YXIgdW5zdXBwb3J0ZWRPcGVyYXRvcnMgPSB1dGlscy5nZXRVbnN1cHBvcnRlZE9wZXJhdG9ycyhxdWVyeVBhcmFtcy5maWx0ZXIpO1xyXG4gICAgICAgIHZhciB1bnN1cHBvcnRlZE9wZXJhdG9yQ291bnQgPSB1bnN1cHBvcnRlZE9wZXJhdG9ycy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHVuc3VwcG9ydGVkT3BlcmF0b3JDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuc3VwcG9ydGVkT3BlcmF0b3JDb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdUaGUgb3BlcmF0b3IgJyArIHVuc3VwcG9ydGVkT3BlcmF0b3JzWzBdICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZS4nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnVGhlIG9wZXJhdG9ycyAnICsgdW5zdXBwb3J0ZWRPcGVyYXRvcnMuam9pbignLCcpICsgJ2FyZSBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZS4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcihlcnJvck1lc3NhZ2UsIEV2ZXJsaXZlRXJyb3JzLm9wZXJhdGlvbk5vdFN1cHBvcnRlZE9mZmxpbmUuY29kZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMudHJhdmVyc2VBbmRUcmFuc2Zvcm1GaWx0ZXJJZChxdWVyeVBhcmFtcy5maWx0ZXIpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGRhdGFRdWVyeS5vcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZChkYXRhUXVlcnksIHF1ZXJ5UGFyYW1zLmZpbHRlciwgcXVlcnlQYXJhbXMuc29ydCwgcXVlcnlQYXJhbXMuc2tpcCwgcXVlcnlQYXJhbXMubGltaXQsIHF1ZXJ5UGFyYW1zLnNlbGVjdCwgcXVlcnlQYXJhbXMuZXhwYW5kKTtcclxuICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkQnlJZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRCeUlkKGRhdGFRdWVyeSwgcXVlcnlQYXJhbXMuZXhwYW5kKTtcclxuICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5maWxlc0dldERvd25sb2FkVXJsQnlJZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvd25sb2FkVXJsQnlJZChkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmNvdW50OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQoZGF0YVF1ZXJ5LCBxdWVyeVBhcmFtcy5maWx0ZXIpO1xyXG4gICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJhd1VwZGF0ZTpcclxuICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZGF0YVF1ZXJ5LCBxdWVyeVBhcmFtcy5maWx0ZXIpO1xyXG4gICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmZpbGVzVXBkYXRlQ29udGVudDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUZpbGVDb250ZW50KGRhdGFRdWVyeSwgcXVlcnlQYXJhbXMuZmlsdGVyKTtcclxuICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoZGF0YVF1ZXJ5LCBxdWVyeVBhcmFtcy5maWx0ZXIpO1xyXG4gICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZVNpbmdsZTpcclxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmZpbHRlci5faWQgPSBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoZGF0YVF1ZXJ5LCBxdWVyeVBhcmFtcy5maWx0ZXIpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IoZGF0YVF1ZXJ5Lm9wZXJhdGlvbiArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXREb3dubG9hZFVybEJ5SWQ6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGlkID0gZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkO1xyXG4gICAgICAgIHZhciBvZmZsaW5lRmlsZVBhdGg7XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmLmV2ZXJsaXZlXHJcbiAgICAgICAgICAgIC5maWxlc1xyXG4gICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxyXG4gICAgICAgICAgICAuaXNTeW5jKGRhdGFRdWVyeS5pc1N5bmMpXHJcbiAgICAgICAgICAgIC5nZXRCeUlkKGlkKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IHJlcy5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ldmVybGl2ZS5vZmZsaW5lU3RvcmFnZS5maWxlcy5fZ2V0RmlsZVVybEZvcklkKGZpbGUuSWQsIGZpbGUuRmlsZW5hbWUpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZVBhdGgpIHtcclxuICAgICAgICAgICAgICAgIG9mZmxpbmVGaWxlUGF0aCA9IGZpbGVQYXRoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZXZlcmxpdmUub2ZmbGluZVN0b3JhZ2UuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5maWxlU3RvcmUuZ2V0RmlsZUJ5QWJzb2x1dGVQYXRoKGZpbGVQYXRoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXJpOiBvZmZsaW5lRmlsZVBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge31cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVuc3VwcG9ydGVkQ2xpZW50T3BNZXNzYWdlOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bnN1cHBvcnRlZE9mZmxpbmVIZWFkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSB1bnN1cHBvcnRlZE9mZmxpbmVIZWFkZXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAoZGF0YVF1ZXJ5LmdldEhlYWRlcihoZWFkZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1RoZSBoZWFkZXIgJyArIGhlYWRlciArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXRpbHMuaXNDb250ZW50VHlwZS51c2VycyhkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpICYmIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW2RhdGFRdWVyeS5vcGVyYXRpb25dKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFVzZXJzRXJyb3JNZXNzYWdlKGRhdGFRdWVyeSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaXNTaW5nbGUgPSBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMgJiYgZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkO1xyXG4gICAgICAgIHZhciBpc1VwZGF0ZUJ5RmlsdGVyID0gZGF0YVF1ZXJ5Lm9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlICYmICFpc1NpbmdsZTtcclxuICAgICAgICB2YXIgaXNSYXdVcGRhdGUgPSBkYXRhUXVlcnkub3BlcmF0aW9uID09PSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yYXdVcGRhdGU7XHJcbiAgICAgICAgaWYgKHV0aWxzLmlzQ29udGVudFR5cGUuZmlsZXMoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKSAmJiAoaXNSYXdVcGRhdGUgfHwgaXNVcGRhdGVCeUZpbHRlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkRmlsZXNFcnJvck1lc3NhZ2UoZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXRDcmVhdGVSZXN1bHQ6IGZ1bmN0aW9uIChjcmVhdGVkSXRlbXMsIHJldHVybkZ1bGxJdGVtKSB7XHJcbiAgICAgICAgaWYgKGNyZWF0ZWRJdGVtcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgaWYgKHJldHVybkZ1bGxJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF8uZXh0ZW5kKHt9LCBjcmVhdGVkSXRlbXNbMF0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShpdGVtKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBDcmVhdGVkQXQ6IHV0aWxzLmNsb25lRGF0ZShjcmVhdGVkSXRlbXNbMF0uQ3JlYXRlZEF0KSxcclxuICAgICAgICAgICAgICAgICAgICBJZDogY3JlYXRlZEl0ZW1zWzBdLl9pZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbXVsdGlwbGVDcmVhdGVSZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKGNyZWF0ZWRJdGVtcywgZnVuY3Rpb24gKGNyZWF0ZWRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5GdWxsSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtQ29weSA9IF8uZXh0ZW5kKHt9LCBjcmVhdGVkSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuaWRUcmFuc2Zvcm0oaXRlbUNvcHkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDcmVhdGVkQXQ6IHV0aWxzLmNsb25lRGF0ZShjcmVhdGVkSXRlbS5DcmVhdGVkQXQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBJZDogY3JlYXRlZEl0ZW0uX2lkXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG11bHRpcGxlQ3JlYXRlUmVzdWx0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdDogbXVsdGlwbGVDcmVhdGVSZXN1bHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NyZWF0ZUl0ZW1zKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSwgZGF0YVF1ZXJ5LmRhdGEsIGRhdGFRdWVyeS5pc1N5bmMsIGRhdGFRdWVyeS5wcmVzZXJ2ZVN0YXRlKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY3JlYXRlZEl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNGaWxlc1F1ZXJ5ID0gdXRpbHMuaXNDb250ZW50VHlwZS5maWxlcyhkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldENyZWF0ZVJlc3VsdChjcmVhdGVkSXRlbXMsIGlzRmlsZXNRdWVyeSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWFkOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBmaWx0ZXIsIHNvcnQsIHNraXAsIGxpbWl0LCBzZWxlY3QsIGV4cGFuZCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgZXhwYW5kUmVzdWx0O1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uTGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5fcHJlcGFyZUV4cGFuZChleHBhbmQsIGRhdGFRdWVyeSwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChwcmVwYXJlRXhwYW5kUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kUmVzdWx0ID0gcHJlcGFyZUV4cGFuZFJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlcGFyZUV4cGFuZFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSBwcmVwYXJlRXhwYW5kUmVzdWx0Lm1haW5RdWVyeUZpZWxkc0V4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0Q29sbGVjdGlvbihkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uLCBmaWx0ZXIsIHNvcnQsIHNraXAsIGxpbWl0LCBzZWxlY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcCB8fCBsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsID0gc2VsZi5fcmVhZEludGVybmFsKGNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTGVuZ3RoID0gYWxsLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5fc2hvdWxkQXV0b2dlbmVyYXRlSWRGb3JDb250ZW50VHlwZShkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMucmVtb3ZlSWRUcmFuc2Zvcm0ocmVzdWx0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLmlkVHJhbnNmb3JtKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZXhwYW5kUmVzdWx0KGV4cGFuZFJlc3VsdCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gc2VsZi5fdHJhbnNmb3JtT2ZmbGluZVJlc3VsdChyZXN1bHQsIGNvbGxlY3Rpb25MZW5ndGgsIGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9yZWFkSW50ZXJuYWw6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBmaWx0ZXIsIHNvcnQsIHNraXAsIGxpbWl0LCBzZWxlY3QpIHtcclxuICAgICAgICB2YXIgZmlsdGVyQ29weSA9IF8uZXh0ZW5kKHt9LCBmaWx0ZXIpO1xyXG4gICAgICAgIHZhciBhY3R1YWxGaWx0ZXIgPSB0aGlzLl9nZXRXaXRob3V0RGVsZXRlZEZpbHRlcihmaWx0ZXJDb3B5KTtcclxuICAgICAgICBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnRyYXZlcnNlQW5kVHJhbnNmb3JtRmlsdGVySWQoYWN0dWFsRmlsdGVyKTtcclxuICAgICAgICB2YXIgcXVlcnkgPSBtaW5nby5RdWVyeShhY3R1YWxGaWx0ZXIpO1xyXG4gICAgICAgIHZhciBjdXJzb3IgPSBtaW5nby5DdXJzb3IoY29sbGVjdGlvbiwgcXVlcnksIHNlbGVjdCk7XHJcbiAgICAgICAgaWYgKHNvcnQpIHtcclxuICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLnNvcnQoc29ydCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2tpcCkge1xyXG4gICAgICAgICAgICBjdXJzb3Iuc2tpcChza2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChsaW1pdCkge1xyXG4gICAgICAgICAgICBjdXJzb3IubGltaXQobGltaXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF8ubWFwKGN1cnNvci5hbGwoKSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBpdGVtKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZEJ5SWQ6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGV4cGFuZCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgZXhwYW5kUmVzdWx0O1xyXG4gICAgICAgIHJldHVybiBzZWxmLl9wcmVwYXJlRXhwYW5kKGV4cGFuZCwgZGF0YVF1ZXJ5LCBmYWxzZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHByZXBhcmVFeHBhbmRSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGV4cGFuZFJlc3VsdCA9IHByZXBhcmVFeHBhbmRSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0Q29sbGVjdGlvbihkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc2VsZi5fZ2V0QnlJZChjb2xsZWN0aW9uLCBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcihFdmVybGl2ZUVycm9ycy5pdGVtTm90Rm91bmQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLmlkVHJhbnNmb3JtKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9leHBhbmRSZXN1bHQoZXhwYW5kUmVzdWx0LCBpdGVtKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3RyYW5zZm9ybU9mZmxpbmVSZXN1bHQocmVzdWx0LCBudWxsLCBkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2dldEJ5SWQ6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZCkge1xyXG4gICAgICAgIGlmICghaWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0lkIGZpZWxkIGlzIG1hbmRhdG9yeSB3aGVuIHVzaW5nIG9mZmxpbmUgc3RvcmFnZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25baWRdKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gXy5leHRlbmQoe30sIGNvbGxlY3Rpb25baWRdKTtcclxuICAgICAgICAgICAgdmFyIGlzRGVsZXRlZCA9IGl0ZW0gJiYgaXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGlzRGVsZXRlZCA/IHVuZGVmaW5lZCA6IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfcHJlcGFyZUV4cGFuZDogZnVuY3Rpb24gKGV4cGFuZCwgZGF0YVF1ZXJ5LCBpc0FycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoZXhwYW5kKSB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRQcm9jZXNzb3IucHJlcGFyZShleHBhbmQsIGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSwgaXNBcnJheSwgZGF0YVF1ZXJ5LmZpZWxkcywgbnVsbCwgbnVsbCwgZnVuY3Rpb24gKGVyciwgcHJlcGFyZVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnRXhwYW5kRXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9IEV2ZXJsaXZlRXJyb3JzLmludmFsaWRFeHBhbmRFeHByZXNzaW9uLmNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHByZXBhcmVSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2V4cGFuZFJlc3VsdDogZnVuY3Rpb24gKHByZXBhcmVFeHBhbmRSZXN1bHQsIHJlc3VsdCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVwYXJlRXhwYW5kUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRQcm9jZXNzb3IuZXhwYW5kKHByZXBhcmVFeHBhbmRSZXN1bHQucmVsYXRpb25zVHJlZSwgcmVzdWx0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2ZmbGluZU1vZHVsZTogc2VsZlxyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdFeHBhbmRFcnJvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gRXZlcmxpdmVFcnJvcnMuaW52YWxpZEV4cGFuZEV4cHJlc3Npb24uY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXRXaXRob3V0RGVsZXRlZEZpbHRlcjogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIHZhciB3aXRob3V0RGVsZXRlZEZpbHRlciA9IHtcclxuICAgICAgICAgICAgJGFuZDogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIHdpdGhvdXREZWxldGVkRmlsdGVyLiRhbmQucHVzaChmaWx0ZXIpO1xyXG4gICAgICAgIHZhciBkZWxldGVPZmZsaW5lRmlsdGVyID0ge307XHJcbiAgICAgICAgZGVsZXRlT2ZmbGluZUZpbHRlcltjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID0geyRuZTogb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZH07XHJcbiAgICAgICAgd2l0aG91dERlbGV0ZWRGaWx0ZXIuJGFuZC5wdXNoKGRlbGV0ZU9mZmxpbmVGaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiB3aXRob3V0RGVsZXRlZEZpbHRlcjtcclxuICAgIH0sXHJcblxyXG4gICAgX2dldFVwZGF0ZUl0ZW1zUmVzdWx0OiBmdW5jdGlvbiAodXBkYXRlSXRlbXMpIHtcclxuICAgICAgICB2YXIgdXBkYXRlZEl0ZW1Db3VudCA9IHVwZGF0ZUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICB2YXIgbW9kaWZpZWRBdFJlc3VsdCA9IHVwZGF0ZWRJdGVtQ291bnQgPyB1cGRhdGVJdGVtc1swXS5Nb2RpZmllZEF0IDogbmV3IERhdGUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgTW9kaWZpZWRBdDogbW9kaWZpZWRBdFJlc3VsdCxcclxuICAgICAgICAgICAgcmVzdWx0OiB1cGRhdGVkSXRlbUNvdW50XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBmaWx0ZXIpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVJdGVtcyhkYXRhUXVlcnksIGRhdGFRdWVyeS5kYXRhLCBmaWx0ZXIsIGRhdGFRdWVyeS5pc1N5bmMpLnRoZW4oZnVuY3Rpb24gKHVwZGF0ZUl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRVcGRhdGVJdGVtc1Jlc3VsdCh1cGRhdGVJdGVtcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUl0ZW1zKGRhdGFRdWVyeSwgZmlsdGVyLCBkYXRhUXVlcnkuaXNTeW5jKTtcclxuICAgIH0sXHJcblxyXG4gICAgY291bnQ6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGZpbHRlcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzZWxmLl9nZXRDb2xsZWN0aW9uKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlclJlc3VsdCA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe3Jlc3VsdDogZmlsdGVyUmVzdWx0Lmxlbmd0aH0pO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX3NldEl0ZW1EYXRlczogZnVuY3Rpb24gKGN1cnJlbnRJdGVtLCBpdGVtVG9DcmVhdGUsIGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBtYW51YWxseSBjbG9uZSB0aGUgZGF0ZXMgaW4gb3JkZXIgdG8gZGVyZWZlcmVuY2UgdGhlbSBmcm9tIHRoZSBvcmlnaW5hbCBvYmplY3QgYXNcclxuICAgICAgICAvLyBfLmV4dGVuZHMgd2lsbCBwYXNzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBkYXRlIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2VcclxuICAgICAgICBpZiAoY3VycmVudEl0ZW0uQ3JlYXRlZEF0ICYmIGN1cnJlbnRJdGVtLkNyZWF0ZWRBdCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLkNyZWF0ZWRBdCA9IHV0aWxzLmNsb25lRGF0ZShjdXJyZW50SXRlbS5DcmVhdGVkQXQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZW1Ub0NyZWF0ZS5DcmVhdGVkQXQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLk1vZGlmaWVkQXQgJiYgY3VycmVudEl0ZW0uTW9kaWZpZWRBdCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLk1vZGlmaWVkQXQgPSB1dGlscy5jbG9uZURhdGUoY3VycmVudEl0ZW0uTW9kaWZpZWRBdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLk1vZGlmaWVkQXQgPSB1dGlscy5jbG9uZURhdGUoaXRlbVRvQ3JlYXRlLkNyZWF0ZWRBdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpdGVtVG9DcmVhdGUuQ3JlYXRlZEJ5ID0gaXRlbVRvQ3JlYXRlLkNyZWF0ZWRCeSB8fCB0aGlzLmV2ZXJsaXZlLnNldHVwLnByaW5jaXBhbElkIHx8IGNvbnN0YW50cy5ndWlkRW1wdHk7XHJcbiAgICAgICAgaXRlbVRvQ3JlYXRlLk1vZGlmaWVkQnkgPSBpdGVtVG9DcmVhdGUuTW9kaWZpZWRCeSB8fCBpdGVtVG9DcmVhdGUuQ3JlYXRlZEJ5O1xyXG4gICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ1VzZXJzJykge1xyXG4gICAgICAgICAgICBpdGVtVG9DcmVhdGUuT3duZXIgPSBpdGVtVG9DcmVhdGUuX2lkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZW1Ub0NyZWF0ZS5Pd25lciA9IGl0ZW1Ub0NyZWF0ZS5DcmVhdGVkQnkgfHwgY29uc3RhbnRzLmd1aWRFbXB0eTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9tYXBDcmVhdGVJdGVtOiBmdW5jdGlvbiAoY3VycmVudEl0ZW0sIGNvbGxlY3Rpb24sIGlzU3luYywgcHJlc2VydmVTdGF0ZSwgY29udGVudFR5cGUpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBpdGVtVG9DcmVhdGUgPSBfLmV4dGVuZCh7fSwgY3VycmVudEl0ZW0pO1xyXG4gICAgICAgIGl0ZW1Ub0NyZWF0ZS5faWQgPSBpdGVtVG9DcmVhdGUuSWQgfHwgdXRpbHMudXVpZCgpO1xyXG4gICAgICAgIGRlbGV0ZSBpdGVtVG9DcmVhdGUuSWQ7XHJcblxyXG4gICAgICAgIHZhciBleGlzdGluZ0l0ZW0gPSBzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGl0ZW1Ub0NyZWF0ZS5faWQpO1xyXG4gICAgICAgIHZhciBpdGVtRXhpc3RzID0gISFleGlzdGluZ0l0ZW07XHJcbiAgICAgICAgdmFyIHN0YXRlO1xyXG4gICAgICAgIGlmIChpdGVtRXhpc3RzICYmICghaXNTeW5jICYmICFwcmVzZXJ2ZVN0YXRlKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBbb2ZmbGluZV0gcmV0dXJuIHRoZSBzYW1lIGVycm9yIGFzIHRoZSBzZXJ2ZXIgZG9lc1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignQW4gaXRlbSB3aXRoIHRoZSBzcGVjaWZpZWQgaWQgYWxyZWFkeSBleGlzdHMnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaXNTeW5jICYmIHByZXNlcnZlU3RhdGUgJiYgaXRlbUV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBleGlzdGluZ0l0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gaXNTeW5jID8gdW5kZWZpbmVkIDogb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZDsgLy8gc2V0IHRoZSBzdGF0ZSB0byBjcmVhdGVkIG9ubHkgaWYgbm90IHN5bmNpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0l0ZW1SZXN1bHQoKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3NldEl0ZW1EYXRlcyhjdXJyZW50SXRlbSwgaXRlbVRvQ3JlYXRlLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHNlbGYuX3NldEl0ZW0oY29sbGVjdGlvbiwgXy5leHRlbmQoe30sIGl0ZW1Ub0NyZWF0ZSksIHN0YXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1Ub0NyZWF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh1dGlscy5pc0NvbnRlbnRUeXBlLmZpbGVzKGNvbnRlbnRUeXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vZmZsaW5lRmlsZXNQcm9jZXNzb3IudXBzZXJ0RmlsZUZyb21PYmplY3QoaXRlbVRvQ3JlYXRlLCB0cnVlLCBpc1N5bmMpLnRoZW4ocHJvY2Vzc0l0ZW1SZXN1bHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzSXRlbVJlc3VsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX2NyZWF0ZUl0ZW1zOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGl0ZW1zLCBpc1N5bmMsIHByZXNlcnZlU3RhdGUpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbGxlY3Rpb24oY29udGVudFR5cGUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXNGb3JDcmVhdGUgPSBfLmlzQXJyYXkoaXRlbXMpID8gaXRlbXMgOiBbaXRlbXNdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZWRJdGVtcyA9IF8ubWFwKGl0ZW1zRm9yQ3JlYXRlLCBmdW5jdGlvbiAoY3VycmVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbWFwQ3JlYXRlSXRlbShjdXJyZW50SXRlbSwgY29sbGVjdGlvbiwgaXNTeW5jLCBwcmVzZXJ2ZVN0YXRlLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcnN2cC5hbGwoY3JlYXRlZEl0ZW1zKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcGVyc2lzdERhdGEoY29udGVudFR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWRzIGFyZSBnZW5lcmF0ZWQgcmVnYXJkbGVzcyBvZiB0aGUgYXV0b0dlbmVyYXRlSWQgb3B0aW9uLiBIb3dldmVyIHRoZSBJZCdzIGFyZSBvbWl0dGVkIHdoZW4gcmV0dXJuaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGl0ZW1zIHRvIHRoZSBjbGllbnQgaWYgYXV0b0dlbmVyYXRlSWQgaXMgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGUoY29udGVudFR5cGUpICYmICFpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEl0ZW1zID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5yZW1vdmVJZFRyYW5zZm9ybShpdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9hcHBseVVwZGF0ZU9wZXJhdGlvbjogZnVuY3Rpb24gKG9yaWdpbmFsVXBkYXRlRXhwcmVzc2lvbiwgaXRlbVRvVXBkYXRlLCBjb2xsZWN0aW9uLCBpc1N5bmMsIG1vZGlmaWVkQXQpIHtcclxuICAgICAgICB2YXIgZGJPcGVyYXRvcnMgPSB1dGlscy5nZXREYk9wZXJhdG9ycyhvcmlnaW5hbFVwZGF0ZUV4cHJlc3Npb24sIHRydWUpO1xyXG4gICAgICAgIHZhciBoYXNEYk9wZXJhdG9yID0gZGJPcGVyYXRvcnMubGVuZ3RoICE9PSAwO1xyXG5cclxuICAgICAgICB2YXIgdXBkYXRlRXhwcmVzc2lvbjtcclxuICAgICAgICBpZiAoaGFzRGJPcGVyYXRvcikge1xyXG4gICAgICAgICAgICB1cGRhdGVFeHByZXNzaW9uID0gb3JpZ2luYWxVcGRhdGVFeHByZXNzaW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUV4cHJlc3Npb24gPSB7XHJcbiAgICAgICAgICAgICAgICAkc2V0OiBvcmlnaW5hbFVwZGF0ZUV4cHJlc3Npb25cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVwZGF0ZUV4cHJlc3Npb25Gb3JVc2VyID0ge1xyXG4gICAgICAgICAgICBNb2RpZmllZEJ5OiB0aGlzLmV2ZXJsaXZlLnNldHVwLnByaW5jaXBhbElkIHx8IGNvbnN0YW50cy5ndWlkRW1wdHlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHVwZGF0ZUV4cHJlc3Npb24uJHNldCA9IF8uZXh0ZW5kKHVwZGF0ZUV4cHJlc3Npb25Gb3JVc2VyLCB1cGRhdGVFeHByZXNzaW9uLiRzZXQpO1xyXG5cclxuICAgICAgICBpZiAoaXNTeW5jKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUV4cHJlc3Npb24uJHNldC5Nb2RpZmllZEF0ID0gdXRpbHMuY2xvbmVEYXRlKG9yaWdpbmFsVXBkYXRlRXhwcmVzc2lvbi5Nb2RpZmllZEF0IHx8IG1vZGlmaWVkQXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbW9uZ29RdWVyeShpdGVtVG9VcGRhdGUsIHt9LCB1cGRhdGVFeHByZXNzaW9uLCB7c3RyaWN0OiB0cnVlfSk7IC8vIFNldHRpbmcgc3RyaWN0IHRvIHRydWUgc28gb25seSBleGFjdCBtYXRjaGVzIHdvdWxkIGJlIHVwZGF0ZWRcclxuXHJcbiAgICAgICAgaXRlbVRvVXBkYXRlLl9pZCA9IGl0ZW1Ub1VwZGF0ZS5faWQgfHwgdXBkYXRlRXhwcmVzc2lvbi5faWQgfHwgdXBkYXRlRXhwcmVzc2lvbi5JZDtcclxuICAgICAgICBkZWxldGUgaXRlbVRvVXBkYXRlLklkO1xyXG5cclxuICAgICAgICB2YXIgbmV3U3RhdGU7XHJcbiAgICAgICAgaWYgKGlzU3luYykge1xyXG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1Ub1VwZGF0ZVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkKSB7XHJcbiAgICAgICAgICAgIG5ld1N0YXRlID0gb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdTdGF0ZSA9IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc2V0SXRlbShjb2xsZWN0aW9uLCBpdGVtVG9VcGRhdGUsIG5ld1N0YXRlKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlRmlsZUNvbnRlbnQ6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgaXNTeW5jID0gZGF0YVF1ZXJ5LmlzU3luYztcclxuICAgICAgICB2YXIgdXBkYXRlRXhwcmVzc2lvbiA9IGRhdGFRdWVyeS5kYXRhO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgaXRlbUlkID0gZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkO1xyXG4gICAgICAgIHZhciB1cGRhdGVJdGVtcztcclxuICAgICAgICB2YXIgdHlwZU5hbWUgPSBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbGxlY3Rpb24odHlwZU5hbWUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlSXRlbUZvclVwZGF0ZSA9IHNlbGYuX2dldEJ5SWQoY29sbGVjdGlvbiwgaXRlbUlkKTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW1zID0gW3NpbmdsZUl0ZW1Gb3JVcGRhdGVdO1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlSXRlbUZvclVwZGF0ZS5iYXNlNjQgPSB1cGRhdGVFeHByZXNzaW9uLmJhc2U2NDtcclxuICAgICAgICAgICAgICAgIHNpbmdsZUl0ZW1Gb3JVcGRhdGUuRmlsZW5hbWUgPSB1cGRhdGVFeHByZXNzaW9uLkZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlSXRlbUZvclVwZGF0ZS5Db250ZW50VHlwZSA9IHVwZGF0ZUV4cHJlc3Npb24uQ29udGVudFR5cGU7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgc2luZ2xlSXRlbUZvclVwZGF0ZS5Vcmk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX292ZXJ3cml0ZUZpbGUoaXRlbUlkLCBzaW5nbGVJdGVtRm9yVXBkYXRlLCBpc1N5bmMpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hcHBseVVwZGF0ZU9wZXJhdGlvbih1cGRhdGVFeHByZXNzaW9uLCBzaW5nbGVJdGVtRm9yVXBkYXRlLCBjb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2V0SXRlbShjb2xsZWN0aW9uLCBzaW5nbGVJdGVtRm9yVXBkYXRlLCBjb25zdGFudHMub2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcGVyc2lzdERhdGEodHlwZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0VXBkYXRlSXRlbXNSZXN1bHQodXBkYXRlSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBfb3ZlcndyaXRlRmlsZTogZnVuY3Rpb24gKGl0ZW1JZCwgaXRlbUZvclVwZGF0ZSwgaXNTeW5jKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gc2VsZi5ldmVybGl2ZS5vZmZsaW5lU3RvcmFnZS5maWxlcy5wdXJnZShpdGVtSWQpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLm9mZmxpbmVGaWxlc1Byb2Nlc3Nvci51cHNlcnRGaWxlRnJvbU9iamVjdChpdGVtRm9yVXBkYXRlLCB0cnVlLCBpc1N5bmMpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgfSxcclxuXHJcbiAgICBfdXBkYXRlSXRlbXM6IGZ1bmN0aW9uIChkYXRhUXVlcnksIHVwZGF0ZUV4cHJlc3Npb24sIGZpbHRlciwgaXNTeW5jKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX2dldENvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlSXRlbXM7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucyAmJiBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW5nbGVJdGVtRm9yVXBkYXRlID0gc2VsZi5fZ2V0QnlJZChjb2xsZWN0aW9uLCBpdGVtSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW1zID0gW3NpbmdsZUl0ZW1Gb3JVcGRhdGVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNDb250ZW50VHlwZS5maWxlcyhjb2xsZWN0aW9uTmFtZSkgJiYgdXBkYXRlRXhwcmVzc2lvbi4kc2V0ICYmIHVwZGF0ZUV4cHJlc3Npb24uJHNldC5GaWxlbmFtZSB8fCB1cGRhdGVFeHByZXNzaW9uLkZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHVwZGF0ZUV4cHJlc3Npb24uRmlsZW5hbWUgfHwgdXBkYXRlRXhwcmVzc2lvbi4kc2V0LkZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZXZlcmxpdmUub2ZmbGluZVN0b3JhZ2UuZmlsZXMuY2hhbmdlRmlsZUV4dGVuc2lvbkJ5SWQoaXRlbUlkLCBleHRlbnNpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYXBwbHlVcGRhdGVPcGVyYXRpb24odXBkYXRlRXhwcmVzc2lvbiwgc2luZ2xlSXRlbUZvclVwZGF0ZSwgY29sbGVjdGlvbiwgaXNTeW5jLCBkYXRhUXVlcnkuTW9kaWZpZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3BlcnNpc3REYXRhKGNvbGxlY3Rpb25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUl0ZW1zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYXBwbHlVcGRhdGVPcGVyYXRpb24odXBkYXRlRXhwcmVzc2lvbiwgc2luZ2xlSXRlbUZvclVwZGF0ZSwgY29sbGVjdGlvbiwgaXNTeW5jLCBkYXRhUXVlcnkuTW9kaWZpZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtcyA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlSXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Ub1VwZGF0ZSA9IHVwZGF0ZUl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUV4aXN0cyA9ICEhc2VsZi5fZ2V0QnlJZChjb2xsZWN0aW9uLCBpdGVtVG9VcGRhdGUuX2lkLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtRXhpc3RzICYmICFpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFtvZmZsaW5lXSByZXR1cm4gdGhlIGNvcnJlY3QgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKEV2ZXJsaXZlRXJyb3JzLml0ZW1Ob3RGb3VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FwcGx5VXBkYXRlT3BlcmF0aW9uKHVwZGF0ZUV4cHJlc3Npb24sIGl0ZW1Ub1VwZGF0ZSwgY29sbGVjdGlvbiwgaXNTeW5jLCBkYXRhUXVlcnkuTW9kaWZpZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZXJzaXN0RGF0YShjb2xsZWN0aW9uTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVJdGVtcztcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXRBbGxDb2xsZWN0aW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3BlcnNpc3Rlci5nZXRBbGxEYXRhKGZ1bmN0aW9uIChhbGxEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goYWxsRGF0YSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcnlwdGVkRGF0YSA9IHNlbGYuX2VuY3J5cHRpb25Qcm92aWRlci5kZWNyeXB0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBhbGxEYXRhW2tleV0gPSBKU09OLnBhcnNlKGRlY3J5cHRlZERhdGEgfHwgJ3t9JywgdXRpbHMucGFyc2VVdGlsaXRpZXMuZ2V0UmV2aXZlcigpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoYWxsRGF0YSk7XHJcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXRDb2xsZWN0aW9uOiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHBlcnNpc3RlciBpZiB0aGVyZSBpcyBubyBkYXRhIGluIHRoZSBjb2xsZWN0aW9uIGNhY2hlIGZvciB0aGlzIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2NvbGxlY3Rpb25DYWNoZVtjb250ZW50VHlwZV0pIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3BlcnNpc3Rlci5nZXREYXRhKGNvbnRlbnRUeXBlLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNyeXB0ZWREYXRhUmF3ID0gc2VsZi5fZW5jcnlwdGlvblByb3ZpZGVyLmRlY3J5cHQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3J5cHRlZERhdGEgPSBKU09OLnBhcnNlKGRlY3J5cHRlZERhdGFSYXcgfHwgJ3t9JywgdXRpbHMucGFyc2VVdGlsaXRpZXMuZ2V0UmV2aXZlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdID0gZGVjcnlwdGVkRGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdKTtcclxuICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHNlbGYuX2NvbGxlY3Rpb25DYWNoZVtjb250ZW50VHlwZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9zZXRJdGVtOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaXRlbSwgc3RhdGUpIHtcclxuICAgICAgICBpZiAoIXN0YXRlKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID0gc3RhdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb2xsZWN0aW9uW2l0ZW0uX2lkXSA9IGl0ZW07XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBfZ2V0RGlydHlJdGVtczogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICB2YXIgZmlsdGVyID0ge307XHJcbiAgICAgICAgZmlsdGVyW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPSB7JGV4aXN0czogdHJ1ZX07XHJcbiAgICAgICAgdmFyIHF1ZXJ5ID0gbWluZ28uUXVlcnkoZmlsdGVyKTtcclxuICAgICAgICB2YXIgY3Vyc29yID0gbWluZ28uQ3Vyc29yKGNvbGxlY3Rpb24sIHF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4gY3Vyc29yLmFsbCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcGVyc2lzdERhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVEYXRhID0gc2VsZi5fY29sbGVjdGlvbkNhY2hlW2NvbnRlbnRUeXBlXSB8fCB7fTtcclxuICAgICAgICAgICAgc2VsZi5fdHJhbnNmb3JtUGVyc2lzdGVkRGF0YShjb250ZW50VHlwZSwgY29udGVudFR5cGVEYXRhKTtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlRGF0YVJhdyA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnRUeXBlRGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZURhdGFSYXdFbmNyeXB0ZWQgPSBzZWxmLl9lbmNyeXB0aW9uUHJvdmlkZXIuZW5jcnlwdChjb250ZW50VHlwZURhdGFSYXcpO1xyXG4gICAgICAgICAgICBzZWxmLl9wZXJzaXN0ZXIuc2F2ZURhdGEoY29udGVudFR5cGUsIGNvbnRlbnRUeXBlRGF0YVJhd0VuY3J5cHRlZCwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGU6IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgIHJldHVybiAhKHRoaXMuc2V0dXAgJiYgdGhpcy5zZXR1cC50eXBlU2V0dGluZ3MgJiYgdGhpcy5zZXR1cC50eXBlU2V0dGluZ3NbY29udGVudFR5cGVdICYmIHRoaXMuc2V0dXAudHlwZVNldHRpbmdzW2NvbnRlbnRUeXBlXS5hdXRvR2VuZXJhdGVJZCA9PT0gZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY2xlYXJJdGVtOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaXRlbSkge1xyXG4gICAgICAgIGRlbGV0ZSBjb2xsZWN0aW9uW2l0ZW0uX2lkXTtcclxuICAgIH0sXHJcblxyXG4gICAgX21hcFJlbW92ZUl0ZW06IGZ1bmN0aW9uIChpdGVtVG9SZW1vdmUsIGNvbGxlY3Rpb24sIGlzU3luYywgY29sbGVjdGlvbk5hbWUpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzQ29udGVudFR5cGUuZmlsZXMoY29sbGVjdGlvbk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ldmVybGl2ZS5vZmZsaW5lU3RvcmFnZS5maWxlcy5wdXJnZShpdGVtVG9SZW1vdmUuX2lkKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtVG9SZW1vdmUuX2lkID0gaXRlbVRvUmVtb3ZlLl9pZCB8fCBpdGVtVG9SZW1vdmUuSWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1FeGlzdHMgPSAhIXNlbGYuX2dldEJ5SWQoY29sbGVjdGlvbiwgaXRlbVRvUmVtb3ZlLl9pZC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXRlbUV4aXN0cyAmJiAhaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0Nhbm5vdCBkZWxldGUgaXRlbSAtIGl0ZW0gd2l0aCBpZCAnICsgaXRlbVRvUmVtb3ZlLl9pZCArICcgZG9lcyBub3QgZXhpc3QuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaGFzIGV4aXN0ZWQgb25seSBvZmZsaW5lIG9yIHRoZSBkYXRhIGlzIHN5bmNpbmdcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgaXRlbSB3YXMgZGVsZXRlZCBieSB0aGUgY29uZmxpY3QgcmVzb2x1dGlvbiBzdHJhdGVneVxyXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZUZyb21NZW1vcnkgPSBpdGVtVG9SZW1vdmVbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCB8fCBpc1N5bmM7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlRnJvbU1lbW9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NsZWFySXRlbShjb2xsZWN0aW9uLCBpdGVtVG9SZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZXRJdGVtKGNvbGxlY3Rpb24sIGl0ZW1Ub1JlbW92ZSwgb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVtb3ZlSXRlbXM6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGZpbHRlciwgaXNTeW5jKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX2dldENvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXNUb1JlbW92ZSA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uLCBmaWx0ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkSXRlbXNQcm9taXNlcyA9IF8ubWFwKGl0ZW1zVG9SZW1vdmUsIGZ1bmN0aW9uIChpdGVtVG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbWFwUmVtb3ZlSXRlbShpdGVtVG9SZW1vdmUsIGNvbGxlY3Rpb24sIGlzU3luYywgY29sbGVjdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJzdnAuYWxsKHJlbW92ZWRJdGVtc1Byb21pc2VzKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGl0ZW1zVG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZXJzaXN0RGF0YShjb2xsZWN0aW9uTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtc1RvUmVtb3ZlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaXRlbXNUb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3RyYW5zZm9ybU9mZmxpbmVSZXN1bHQoaXRlbXNUb1JlbW92ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2FwcGx5VHJhbnNmb3JtYXRpb25zOiBmdW5jdGlvbiAodHJhbnNmb3JtZWRSZXN1bHQsIHRyYW5zZm9ybWF0aW9ucykge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdCkpIHtcclxuICAgICAgICAgICAgXy5lYWNoKHRyYW5zZm9ybWF0aW9ucywgZnVuY3Rpb24gKHRyYW5zZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQubWFwKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRSZXN1bHQucmVzdWx0W2tleV0gPSB0cmFuc2Zvcm1hdGlvbih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgXy5lYWNoKHRyYW5zZm9ybWF0aW9ucywgZnVuY3Rpb24gKHRyYW5zZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQgPSB0cmFuc2Zvcm1hdGlvbih0cmFuc2Zvcm1lZFJlc3VsdC5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF90cmFuc2Zvcm1PZmZsaW5lUmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0U2V0LCBjb3VudCwgZGF0YVF1ZXJ5LCBhZGRpdGlvbmFsVHJhbnNmb3JtYXRpb25zKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFNldCxcclxuICAgICAgICAgICAgY291bnQ6IGNvdW50IHx8IChyZXN1bHRTZXQgfHwgW10pLmxlbmd0aFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICgoY291bnQgIT09IHVuZGVmaW5lZCAmJiBjb3VudCAhPT0gbnVsbCkgfHwgQXJyYXkuaXNBcnJheShyZXN1bHRTZXQpKSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVzdWx0LmNvdW50ID0gY291bnQgfHwgcmVzdWx0U2V0Lmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2gob2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybSk7XHJcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2gob2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5yZW1vdmVNYXJrZXJzVHJhbnNmb3JtKTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGFRdWVyeSkge1xyXG4gICAgICAgICAgICB2YXIgaW5jbHVkZUNvdW50ID0gZGF0YVF1ZXJ5LmdldEhlYWRlcihIZWFkZXJzLmluY2x1ZGVDb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChpbmNsdWRlQ291bnQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdHJhbnNmb3JtZWRSZXN1bHQuY291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzaW5nbGVGaWVsZEV4cHJlc3Npb24gPSBkYXRhUXVlcnkuZ2V0SGVhZGVyKEhlYWRlcnMuc2luZ2xlRmllbGQpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNpbmdsZUZpZWxkRXhwcmVzc2lvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuc2luZ2xlRmllbGRUcmFuc2Zvcm0uYmluZCh0aGlzLCBzaW5nbGVGaWVsZEV4cHJlc3Npb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxUcmFuc2Zvcm1hdGlvbnMpIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25zID0gdHJhbnNmb3JtYXRpb25zLmNvbmNhdChhZGRpdGlvbmFsVHJhbnNmb3JtYXRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2FwcGx5VHJhbnNmb3JtYXRpb25zKHRyYW5zZm9ybWVkUmVzdWx0LCB0cmFuc2Zvcm1hdGlvbnMpO1xyXG5cclxuICAgICAgICBpZiAodHJhbnNmb3JtZWRSZXN1bHQuY291bnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdHJhbnNmb3JtZWRSZXN1bHQuY291bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRSZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIF90cmFuc2Zvcm1QZXJzaXN0ZWREYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGNvbnRlbnRUeXBlRGF0YSkge1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1GaWVsZHMgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnVXNlcnMnKSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUZpZWxkcyA9IHRyYW5zZm9ybUZpZWxkcy5jb25jYXQoWydQYXNzd29yZCcsICdTZWNyZXRRdWVzdGlvbklkJywgJ1NlY3JldEFuc3dlciddKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1GaWVsZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIF8uZWFjaChjb250ZW50VHlwZURhdGEsIGZ1bmN0aW9uIChjb250ZW50VHlwZU9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5yZW1vdmVGaWVsZHNUcmFuc2Zvcm0oY29udGVudFR5cGVPYmplY3QsIHRyYW5zZm9ybUZpZWxkcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcHVyZ2VBbGw6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uQ2FjaGUgPSB7fTtcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICBzZWxmLl9wZXJzaXN0ZXIucHVyZ2VBbGwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZXZlcmxpdmUuc2V0dXAuY2FjaGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXZlcmxpdmUuY2FjaGUuY2xlYXJBbGwoc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGVycm9yKTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIHB1cmdlOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3BlcnNpc3Rlci5wdXJnZShjb250ZW50VHlwZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZXZlcmxpdmUuc2V0dXAuY2FjaGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXZlcmxpdmUuY2FjaGUuY2xlYXIoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBlcnJvcik7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZsaW5lUXVlcnlQcm9jZXNzb3I7IiwidmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L0RhdGFRdWVyeScpO1xyXG52YXIgZXZlcmxpdmVFcnJvck1vZHVsZSA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSBldmVybGl2ZUVycm9yTW9kdWxlLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBFdmVybGl2ZUVycm9ycyA9IGV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcnM7XHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxudmFyIG9mZmxpbmVJdGVtU3RhdGVzID0gY29uc3RhbnRzLm9mZmxpbmVJdGVtU3RhdGVzO1xyXG52YXIgUmVxdWVzdE9wdGlvbnNCdWlsZGVyID0gcmVxdWlyZSgnLi4vcXVlcnkvUmVxdWVzdE9wdGlvbnNCdWlsZGVyJyk7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIFJlcXVlc3QgPSByZXF1aXJlKCcuLi9SZXF1ZXN0Jyk7XHJcbnZhciBvZmZsaW5lVHJhbnNmb3JtYXRpb25zID0gcmVxdWlyZSgnLi9vZmZsaW5lVHJhbnNmb3JtYXRpb25zJyk7XHJcbnZhciBidWlsZFByb21pc2UgPSByZXF1aXJlKCcuLi91dGlscycpLmJ1aWxkUHJvbWlzZTtcclxudmFyIE9mZmxpbmVRdWVyeVByb2Nlc3NvciA9IHJlcXVpcmUoJy4vT2ZmbGluZVF1ZXJ5UHJvY2Vzc29yJyk7XHJcbnZhciBPZmZsaW5lRmlsZXNQcm9jZXNzb3IgPSByZXF1aXJlKCcuL09mZmxpbmVGaWxlc1Byb2Nlc3NvcicpO1xyXG52YXIgT2ZmbGluZUZpbGVzTW9kdWxlID0gcmVxdWlyZSgnLi9PZmZsaW5lRmlsZXNNb2R1bGUnKTtcclxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcblxyXG52YXIgc3luY0xvY2F0aW9uID0ge1xyXG4gICAgc2VydmVyOiAnc2VydmVyJyxcclxuICAgIGNsaWVudDogJ2NsaWVudCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgT2ZmbGluZU1vZHVsZVxyXG4gKiBAY2xhc3NEZXNjIEEgY2xhc3MgcHJvdmlkaW5nIGFjY2VzcyB0byB0aGUgdmFyaW91cyBvZmZsaW5lIHN0b3JhZ2UgZmVhdHVyZXMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHtAbGluayBPZmZsaW5lTW9kdWxlfSBjbGFzcy5cclxuICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gKiBAbWVtYmVyIHtPZmZsaW5lTW9kdWxlfSBvZmZsaW5lU3RvcmFnZVxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9mZmxpbmVNb2R1bGUoZXZlcmxpdmUsIG9wdGlvbnMsIHBlcnNpc3RlciwgZW5jcnlwdGlvblByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlcmxpdmUgPSBldmVybGl2ZTtcclxuICAgICAgICB0aGlzLnNldHVwID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLl9pc1N5bmNocm9uaXppbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbmNyeXB0aW9uUHJvdmlkZXIgPSBlbmNyeXB0aW9uUHJvdmlkZXI7XHJcblxyXG4gICAgICAgIHRoaXMuX29mZmxpbmVGaWxlc1Byb2Nlc3NvciA9IG5ldyBPZmZsaW5lRmlsZXNQcm9jZXNzb3IodGhpcy5zZXR1cCwgdGhpcy5fZXZlcmxpdmUpO1xyXG4gICAgICAgIHRoaXMuX3F1ZXJ5UHJvY2Vzc29yID0gbmV3IE9mZmxpbmVRdWVyeVByb2Nlc3NvcihwZXJzaXN0ZXIsIGVuY3J5cHRpb25Qcm92aWRlcixcclxuICAgICAgICAgICAgdGhpcy5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yLCB0aGlzLl9ldmVybGl2ZSwgdGhpcy5zZXR1cCk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtPZmZsaW5lRmlsZXNNb2R1bGVde0BsaW5rIE9mZmxpbmVGaWxlc01vZHVsZX0gY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCBmaWxlcyBpbiBvZmZsaW5lIG1vZGUuXHJcbiAgICAgICAgICogQG1lbWJlciB7T2ZmbGluZUZpbGVzTW9kdWxlfSBmaWxlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsZXMgPSBuZXcgT2ZmbGluZUZpbGVzTW9kdWxlKHRoaXMuX29mZmxpbmVGaWxlc1Byb2Nlc3NvcixcclxuICAgICAgICAgICAgdGhpcy5fZXZlcmxpdmUsIHRoaXMuc2V0dXAuZmlsZXMubWF4Q29uY3VycmVudERvd25sb2Fkcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdldFN5bmNGaWx0ZXJGb3JJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZ2V0U3luY0ZpbHRlck5vTW9kaWZpZWRBdChpdGVtKTtcclxuICAgICAgICBmaWx0ZXIuTW9kaWZpZWRBdCA9IGl0ZW0uTW9kaWZpZWRBdDtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZ2V0U3luY0ZpbHRlck5vTW9kaWZpZWRBdCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSWQ6IGl0ZW0uSWRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBPZmZsaW5lTW9kdWxlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBkYXRhIGZyb20gdGhlIG9mZmxpbmUgc3RvcmFnZS5cclxuICAgICAgICAgKiBAbWV0aG9kIHB1cmdlQWxsXHJcbiAgICAgICAgICogQG5hbWUgcHVyZ2VBbGxcclxuICAgICAgICAgKiBAbWVtYmVyT2YgT2ZmbGluZU1vZHVsZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgZGF0YSBmcm9tIHRoZSBvZmZsaW5lIHN0b3JhZ2UuXHJcbiAgICAgICAgICogQG1ldGhvZCBwdXJnZUFsbFxyXG4gICAgICAgICAqIEBuYW1lIHB1cmdlQWxsXHJcbiAgICAgICAgICogQG1lbWJlck9mIE9mZmxpbmVNb2R1bGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1cmdlQWxsOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UHJvY2Vzc29yLnB1cmdlQWxsKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZSBmcm9tIHRoZSBvZmZsaW5lIHN0b3JhZ2UuXHJcbiAgICAgICAgICogQG1ldGhvZCBwdXJnZVxyXG4gICAgICAgICAqIEBuYW1lIHB1cmdlXHJcbiAgICAgICAgICogQG1lbWJlck9mIE9mZmxpbmVNb2R1bGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IHR5cGUgdG8gcHVyZ2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGRhdGEgZm9yIGEgc3BlY2lmaWMgY29udGVudCB0eXBlIGZyb20gdGhlIG9mZmxpbmUgc3RvcmFnZS5cclxuICAgICAgICAgKiBAbWV0aG9kIHB1cmdlXHJcbiAgICAgICAgICogQG5hbWUgcHVyZ2VcclxuICAgICAgICAgKiBAbWVtYmVyT2YgT2ZmbGluZU1vZHVsZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgdHlwZSB0byBwdXJnZS5cclxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVyZ2U6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UHJvY2Vzc29yLnB1cmdlKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcHJvY2Vzc1F1ZXJ5OiBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UHJvY2Vzc29yLnByb2Nlc3NRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldE9mZmxpbmU6IGZ1bmN0aW9uIChvZmZsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dXAub2ZmbGluZSA9IG9mZmxpbmU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNPbmxpbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnNldHVwLm9mZmxpbmU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3ByZXBhcmVTeW5jRGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlc0ZvclN5bmMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlc1N5bmNEYXRhID0ge307XHJcbiAgICAgICAgICAgIHZhciBjb25mbGljdHMgPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlc0ZvclN5bmMsIGZ1bmN0aW9uIChjb250ZW50VHlwZSwgdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzeW5jSXRlbXMgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLmlkVHJhbnNmb3JtKGNvbnRlbnRUeXBlLm9mZmxpbmVJdGVtc1RvU3luYyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3luY0RhdGEgPSBzZWxmLl9nZXRTeW5jSXRlbVN0YXRlcyh0eXBlTmFtZSwgc3luY0l0ZW1zLCBjb250ZW50VHlwZS5zZXJ2ZXJJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHMucHVzaChzeW5jRGF0YS5jb25mbGljdHMpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVzU3luY0RhdGFbdHlwZU5hbWVdID0gc3luY0RhdGEuaXRlbXNGb3JTeW5jO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHM6IGNvbmZsaWN0cyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlc1N5bmNEYXRhOiBjb250ZW50VHlwZXNTeW5jRGF0YVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yZXNvbHZlQ29uZmxpY3RzOiBmdW5jdGlvbiAoc3luY0RhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlSZXNvbHV0aW9uU3RyYXRlZ3koc3luY0RhdGEuY29uZmxpY3RzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9tZXJnZVJlc29sdmVkQ29uZmxpY3RzKHN5bmNEYXRhLmNvbmZsaWN0cywgc3luY0RhdGEuY29udGVudFR5cGVzU3luY0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3luY0RhdGEuY29udGVudFR5cGVzU3luY0RhdGE7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc1N5bmNocm9uaXppbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzU3luY2hyb25pemluZztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZmlyZVN5bmNTdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLl9pc1N5bmNocm9uaXppbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pc1N5bmNocm9uaXppbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2ZXJsaXZlLl9lbWl0dGVyLmVtaXQoJ3N5bmNTdGFydCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZmlyZVN5bmNFbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNTeW5jaHJvbml6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZXJsaXZlLl9lbWl0dGVyLmVtaXQoJ3N5bmNFbmQnLCB0aGlzLl9zeW5jUmVzdWx0SW5mbyk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jUmVzdWx0SW5mbztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZWFjaFN5bmNJdGVtOiBmdW5jdGlvbiAoaXRlbXMsIGdldEZpbHRlckZ1bmN0aW9uLCBjb250ZW50VHlwZU5hbWUsIG9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUZpbHRlciA9IGdldEZpbHRlckZ1bmN0aW9uKGl0ZW0ucmVtb3RlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gZXJyb3IgZm9yIHRoaXMgaXRlbSB3ZSBkbyBub3Qgd2FudCB0byB0cnkgYW5kIHN5bmMgaXQgYWdhaW5cclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRJdGVtID0gaXRlbS5yZXN1bHRpbmdJdGVtO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQ3VzdG9tID0gaXRlbS5pc0N1c3RvbTtcclxuICAgICAgICAgICAgICAgIHZhciByZXNvbHV0aW9uVHlwZSA9IGl0ZW0ucmVzb2x1dGlvblR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoXy5zb21lKHNlbGYuX3N5bmNSZXN1bHRJbmZvLmZhaWxlZEl0ZW1zW2NvbnRlbnRUeXBlTmFtZV0sIHtpdGVtSWQ6IHJlc3VsdEl0ZW0uSWR9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ocmVzdWx0SXRlbSwgaXRlbUZpbHRlciwgaXNDdXN0b20sIHJlc29sdXRpb25UeXBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGU6IGZ1bmN0aW9uIChjb2xsZWN0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlQcm9jZXNzb3IuX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGUoY29sbGVjdGlvbk5hbWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hZGRDcmVhdGVkRmlsZVRvU3luY1Byb21pc2VzOiBmdW5jdGlvbiAocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIHN5bmNQcm9taXNlcywgY29sbGVjdGlvbk5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgXy5lYWNoKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVzQ29sbGVjdGlvbiA9IHNlbGYuX2V2ZXJsaXZlLmZpbGVzO1xyXG4gICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW0uSWRdID0gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maWxlcy5nZXRPZmZsaW5lTG9jYXRpb24oaXRlbS5JZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fdHJhbnNmZXJGaWxlKGZhbHNlLCBpdGVtLCBsb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogaXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uc2VydmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lcmdlZFdpdGhTZXJ2ZXJSZXNwb25zZUl0ZW0gPSBfLmV4dGVuZCh7fSwgaXRlbSwgcmVzLnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkl0ZW1Qcm9jZXNzZWQobWVyZ2VkV2l0aFNlcnZlclJlc3BvbnNlSXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5zZXJ2ZXIsIG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVzQ29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGVTaW5nbGUobWVyZ2VkV2l0aFNlcnZlclJlc3BvbnNlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogaXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uc2VydmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogaXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uY2xpZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3RyYW5zZmVyRmlsZTogZnVuY3Rpb24gKGlzVXBkYXRlLCBpdGVtLCBsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2RrID0gdGhpcy5fZXZlcmxpdmU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXBsb2FkVXJsID0gc2RrLmZpbGVzLmdldFVwbG9hZFVybCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVFeGlzdHNQcm9taXNlID0gdXRpbHMuc3VjY2Vzc2Z1bFByb21pc2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlRXhpc3RzUHJvbWlzZSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrLmZpbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHlPZmZsaW5lKGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEJ5SWQoaXRlbS5JZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZmlsZUV4aXN0c1Byb21pc2UudGhlbihmdW5jdGlvbiAoZmlsZUV4aXN0c09uU2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhblVwZGF0ZSA9IGlzVXBkYXRlICYmIGZpbGVFeGlzdHNPblNlcnZlcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZFVybCArPSAnLycgKyBpdGVtLklkICsgJy9Db250ZW50JztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlVHJhbnNmZXIgPSBuZXcgRmlsZVRyYW5zZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVLZXkgPSBjb25zdGFudHMuZmlsZVVwbG9hZEtleTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUtleTogZmlsZUtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogY2FuVXBkYXRlID8gJ1BVVCcgOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBpdGVtLkNvbnRlbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogaXRlbS5GaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2RrLmJ1aWxkQXV0aEhlYWRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGl0ZW0sIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSAhPT0gJ2Jhc2U2NCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXhlZEtleSA9IGNvbnN0YW50cy5maWxlVXBsb2FkS2V5ICsgY29uc3RhbnRzLmZpbGVVcGxvYWREZWxpbWl0ZXIgKyBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtc1twcmVmaXhlZEtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmaWxlVHJhbnNmZXIudXBsb2FkKGxvY2F0aW9uLCB1cGxvYWRVcmwsIGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZFJlc3VsdCA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLnBhcnNlSlNPTihyZXN1bHQucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkUmVzdWx0LlJlc3VsdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShwYXJzZWRSZXN1bHQuUmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBwYXJzZWRSZXN1bHQuUmVzdWx0WzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXJzZWRSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0LCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWRkQ3JlYXRlZE9iamVjdFRvU3luY1Byb21pc2VzOiBmdW5jdGlvbiAoc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIGNvbnRlbnRUeXBlRGF0YSwgY29sbGVjdGlvbk5hbWUsIGlkcykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YUNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAuY3JlYXRlKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUgPSBfLm1hcChyZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLklkID0gcmVzLnJlc3VsdFtpbmRleF0uSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLkNyZWF0ZWRBdCA9IGl0ZW0uTW9kaWZpZWRBdCA9IHJlcy5yZXN1bHRbaW5kZXhdLkNyZWF0ZWRBdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRpbmdJdGVtID0gXy5maW5kKGNvbnRlbnRUeXBlRGF0YS5jcmVhdGVkSXRlbXMsIGZ1bmN0aW9uIChjcmVhdGVkSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVkSXRlbS5yZXN1bHRpbmdJdGVtLklkID09PSBpdGVtLklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdGluZ0l0ZW0uaXNDdXN0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkl0ZW1Qcm9jZXNzZWQoaXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5jbGllbnQsIG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5zZXJ2ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFDb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNyZWF0ZShyZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2gocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIGZ1bmN0aW9uIChjcmVhdGVkSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkl0ZW1Qcm9jZXNzZWQoY3JlYXRlZEl0ZW0sIGNvbGxlY3Rpb25OYW1lLCBzeW5jTG9jYXRpb24uc2VydmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLmNsaWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkcyAmJiBpZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0ge0lkOiB7JGluOiBpZHN9fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQ29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kZXN0cm95KGZpbHRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5jbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBfLmVhY2gocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBzeW5jUHJvbWlzZXNbaXRlbS5JZF0gPSBwcm9taXNlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWRkQ3JlYXRlZEl0ZW1zRm9yU3luYzogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSA9IF8ucGx1Y2soY29udGVudFR5cGVEYXRhLmNyZWF0ZWRJdGVtcywgJ3Jlc3VsdGluZ0l0ZW0nKTtcclxuICAgICAgICAgICAgdmFyIGlkcztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaG91bGRBdXRvZ2VuZXJhdGVJZEZvckNvbnRlbnRUeXBlKGNvbGxlY3Rpb25OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgaWRzID0gXy5wbHVjayhyZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSwgJ0lkJyk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMucmVtb3ZlSWRUcmFuc2Zvcm0ocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNDb250ZW50VHlwZS5maWxlcyhjb2xsZWN0aW9uTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDcmVhdGVkRmlsZVRvU3luY1Byb21pc2VzKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLCBzeW5jUHJvbWlzZXMsIGNvbGxlY3Rpb25OYW1lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDcmVhdGVkT2JqZWN0VG9TeW5jUHJvbWlzZXMoc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIGNvbnRlbnRUeXBlRGF0YSwgY29sbGVjdGlvbk5hbWUsIGlkcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWRkVXBkYXRlZEl0ZW1zRm9yU3luYzogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgZ2V0RmlsdGVyT3BlcmF0aW9uLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uLCBpdGVtVXBkYXRlT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25OYW1lID0gZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgICAgIHNlbGYuX2VhY2hTeW5jSXRlbShjb250ZW50VHlwZURhdGEubW9kaWZpZWRJdGVtcywgZ2V0RmlsdGVyT3BlcmF0aW9uLCBjb2xsZWN0aW9uTmFtZSwgaXRlbVVwZGF0ZU9wZXJhdGlvbik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FkZERlbGV0ZWRJdGVtc0ZvclN5bmM6IGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIGdldEZpbHRlck9wZXJhdGlvbiwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgaXRlbURlbGV0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICAgICAgc2VsZi5fZWFjaFN5bmNJdGVtKGNvbnRlbnRUeXBlRGF0YS5kZWxldGVkSXRlbXMsIGdldEZpbHRlck9wZXJhdGlvbiwgY29sbGVjdGlvbk5hbWUsIGl0ZW1EZWxldGVPcGVyYXRpb24pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9vblN5bmNSZXNwb25zZTogZnVuY3Rpb24gKHJlcywgaXRlbSwgY29sbGVjdGlvbk5hbWUsIG9wZXJhdGlvbiwgaXNDdXN0b21JdGVtKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXMucmVzdWx0ICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF8uZXh0ZW5kKHt9LCBFdmVybGl2ZUVycm9ycy5zeW5jQ29uZmxpY3QsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uID09PSBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkl0ZW1Qcm9jZXNzZWQoaXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5zZXJ2ZXIsIG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEl0ZW0gPSBfLmV4dGVuZCh7fSwgaXRlbSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNb2RpZmllZEF0OiByZXMuTW9kaWZpZWRBdFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWRJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uSWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N5bmM6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXJ5KHVwZGF0ZVF1ZXJ5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXN0b21JdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nSXRlbSA9IF8uZmluZChzZWxmLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRJdGVtc1tjb2xsZWN0aW9uTmFtZV0sIGZ1bmN0aW9uIChzeW5jZWRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jZWRJdGVtLml0ZW1JZCA9PT0gaXRlbS5JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ0l0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25JdGVtUHJvY2Vzc2VkKGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCBzeW5jTG9jYXRpb24uY2xpZW50LCBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkl0ZW1Qcm9jZXNzZWQoaXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5zZXJ2ZXIsIG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXJnZUJ5SWQoY29sbGVjdGlvbk5hbWUsIGl0ZW0uSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1c3RvbUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkl0ZW1Qcm9jZXNzZWQoaXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5jbGllbnQsIG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9wdXJnZUJ5SWQ6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgaXRlbUlkKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVByb2Nlc3Nvci5fZ2V0Q29sbGVjdGlvbihjb250ZW50VHlwZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbGxlY3Rpb25baXRlbUlkXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcXVlcnlQcm9jZXNzb3IuX3BlcnNpc3REYXRhKGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN5bmM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mbyA9IHNlbGYuX3N5bmNSZXN1bHRJbmZvIHx8IHtcclxuICAgICAgICAgICAgICAgIHN5bmNlZEl0ZW1zOiB7fSxcclxuICAgICAgICAgICAgICAgIHN5bmNlZFRvU2VydmVyOiAwLFxyXG4gICAgICAgICAgICAgICAgc3luY2VkVG9DbGllbnQ6IDAsXHJcbiAgICAgICAgICAgICAgICBmYWlsZWRJdGVtczoge30sXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkIC8vIGFkZGVkIGZvciB2aXNpYmlsaXR5XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPbmxpbmUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0Nhbm5vdCBzeW5jaHJvbml6ZSB3aGlsZSBvZmZsaW5lJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYuX2ZpcmVTeW5jU3RhcnQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9hcHBseVN5bmMoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3luY1Jlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3RzV2hpbGVTeW5jID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHN5bmNSZXN1bHRzLCBmdW5jdGlvbiAoc3luY1Jlc3VsdCwgaXRlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzeW5jUmVzdWx0ICYmIHN5bmNSZXN1bHQuc3RhdGUgPT09ICdyZWplY3RlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzeW5jUmVzdWx0LnJlYXNvbiAmJiBzeW5jUmVzdWx0LnJlYXNvbi5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5zeW5jQ29uZmxpY3QuY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0c1doaWxlU3luYy5wdXNoKHN5bmNSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBzYXZlIHRpbWUgYW5kIHRyYWZmaWMgd2UgYXJlIHVzaW5nIGEgc2luZ2xlIGNyZWF0ZSByZXF1ZXN0IGZvciBhbGwgaXRlbXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHdoeSBpZiB0aGVyZSBpcyBhbiBlcnJvciB3ZSBuZWVkIHRvIHNwbGl0IHRoZSBpdGVtcyB3ZSB0cmllZCB0byBjcmVhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgc2V0IHRoZSBzYW1lIGVycm9yIGZvciBhbGwgaXRlbXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25JdGVtRmFpbGVkKHN5bmNSZXN1bHQsIGl0ZW1JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0c1doaWxlU3luYy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3luYygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpcmVTeW5jRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3luY1Jlc3VsdEluZm8uZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZmlyZVN5bmNFbmQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9oYW5kbGVLZWVwU2VydmVyOiBmdW5jdGlvbiAodHlwZU5hbWUsIGNvbmZsaWN0aW5nSXRlbSwgb2ZmbGluZVN5bmNPcGVyYXRpb25zLCBjb250ZW50VHlwZVN5bmNEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJJdGVtID0gY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW07XHJcbiAgICAgICAgICAgIHZhciBjbGllbnRJdGVtID0gY29uZmxpY3RpbmdJdGVtLmNsaWVudEl0ZW07XHJcbiAgICAgICAgICAgIHZhciBzeW5jUXVlcnk7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJJdGVtICYmIGNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaXRlbSBvZmZsaW5lXHJcbiAgICAgICAgICAgICAgICBzeW5jUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcnZlckl0ZW0uSWRcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNlcnZlckl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZlckl0ZW0gJiYgIWNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBpdGVtIG9mZmxpbmVcclxuICAgICAgICAgICAgICAgIHN5bmNRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzZXJ2ZXJJdGVtXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghc2VydmVySXRlbSAmJiBjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgaXRlbSBvZmZsaW5lXHJcbiAgICAgICAgICAgICAgICBzeW5jUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNsaWVudEl0ZW0uSWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdCb3RoIHNlcnZlckl0ZW0gYW5kIGNsaWVudEl0ZW0gYXJlIG5vdCBzZXQgd2hlbiBzeW5jaW5nIGRhdGEgd2l0aCBcIktlZXBTZXJ2ZXJcIiByZXNvbHV0aW9uIHN0cmF0ZWd5LicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW5jUXVlcnkuaXNTeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgb2ZmbGluZVN5bmNPcGVyYXRpb25zLnB1c2gobmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnByb2Nlc3NRdWVyeShzeW5jUXVlcnkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN5bmNRdWVyeS5vcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uSXRlbVByb2Nlc3NlZChzZXJ2ZXJJdGVtLCB0eXBlTmFtZSwgc3luY0xvY2F0aW9uLmNsaWVudCwgb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmaWxlcyBjb250ZW50IHR5cGUgaXMgc3BlY2lhbCBhbmQgbmVlZHMgdG8gZW5hYmxlIHRoZSBmaWxlIGNvbnRlbnRzIG9mZmxpbmUsIHNvIHdlIGNhbm5vdCBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzQ29udGVudFR5cGUuZmlsZXModHlwZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEubW9kaWZpZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IGNvbmZsaWN0aW5nSXRlbS5zZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdXRpb25UeXBlOiBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uLktlZXBTZXJ2ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25JdGVtUHJvY2Vzc2VkKHNlcnZlckl0ZW0sIHR5cGVOYW1lLCBzeW5jTG9jYXRpb24uY2xpZW50LCBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uSXRlbVByb2Nlc3NlZChjbGllbnRJdGVtLCB0eXBlTmFtZSwgc3luY0xvY2F0aW9uLmNsaWVudCwgb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzeW5jUXVlcnkub3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQgPSBzZXJ2ZXJJdGVtLklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkID0gc2VydmVySXRlbS5JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkID0gY2xpZW50SXRlbS5JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvcGVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogc3luY1F1ZXJ5LmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5jbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2hhbmRsZUtlZXBDbGllbnQ6IGZ1bmN0aW9uIChjb25mbGljdGluZ0l0ZW0sIGNvbnRlbnRUeXBlU3luY0RhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlcnZlckl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbTtcclxuICAgICAgICAgICAgdmFyIGNsaWVudEl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uY2xpZW50SXRlbTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdGluZ0l0ZW07XHJcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0gJiYgY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbSA9IF8uZXh0ZW5kKGNsaWVudEl0ZW0sIHtNb2RpZmllZEF0OiBuZXcgRGF0ZShzZXJ2ZXJJdGVtLk1vZGlmaWVkQXQpfSk7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gY29udGVudFR5cGVTeW5jRGF0YS5tb2RpZmllZEl0ZW1zO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZlckl0ZW0gJiYgIWNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW0gPSBzZXJ2ZXJJdGVtO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IGNvbnRlbnRUeXBlU3luY0RhdGEuZGVsZXRlZEl0ZW1zO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzZXJ2ZXJJdGVtICYmIGNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW0gPSBjbGllbnRJdGVtO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IGNvbnRlbnRUeXBlU3luY0RhdGEuY3JlYXRlZEl0ZW1zO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0JvdGggc2VydmVySXRlbSBhbmQgY2xpZW50SXRlbSBhcmUgbm90IHNldCB3aGVuIHN5bmNpbmcgZGF0YSB3aXRoIFwiS2VlcENsaWVudFwiIHJlc29sdXRpb24gc3RyYXRlZ3kuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IHJlc3VsdGluZ0l0ZW0sXHJcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uVHlwZTogY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvbi5LZWVwQ2xpZW50XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9oYW5kbGVDdXN0b206IGZ1bmN0aW9uIChjb25mbGljdGluZ0l0ZW0sIHR5cGVOYW1lLCBvZmZsaW5lU3luY09wZXJhdGlvbnMsIGNvbnRlbnRUeXBlU3luY0RhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlcnZlckl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbTtcclxuICAgICAgICAgICAgdmFyIGNsaWVudEl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uY2xpZW50SXRlbTtcclxuICAgICAgICAgICAgdmFyIGN1c3RvbUl0ZW0gPSBfLm9taXQoY29uZmxpY3RpbmdJdGVtLnJlc3VsdC5pdGVtLCAnQ3JlYXRlZEF0JywgJ01vZGlmaWVkQXQnKTtcclxuICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0gJiYgY3VzdG9tSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZUl0ZW1PZmZsaW5lUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VydmVySXRlbSAvLyBjcmVhdGUgdGhlIHNlcnZlciBpdGVtIG9mZmxpbmUgYW5kIGl0IHdpbGwgYmUgdXBkYXRlZCB3aGVuIHN5bmMgZmluaXNoZXNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNyZWF0ZUl0ZW1PZmZsaW5lUXVlcnkucHJlc2VydmVTdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVJdGVtT2ZmbGluZVF1ZXJ5LmlzU3luYyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgb2ZmbGluZVN5bmNPcGVyYXRpb25zLnB1c2godGhpcy5wcm9jZXNzUXVlcnkoY3JlYXRlSXRlbU9mZmxpbmVRdWVyeSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX29uSXRlbVByb2Nlc3NlZChzZXJ2ZXJJdGVtLCB0eXBlTmFtZSwgc3luY0xvY2F0aW9uLmNsaWVudCwgb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJJdGVtICYmIGN1c3RvbUl0ZW0gJiYgIWNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUl0ZW0uSWQgPSBzZXJ2ZXJJdGVtLklkO1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5tb2RpZmllZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogY3VzdG9tSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICBpc0N1c3RvbTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VydmVySXRlbSAmJiAhY3VzdG9tSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5kZWxldGVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICBpc0N1c3RvbTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNlcnZlckl0ZW0gJiYgY3VzdG9tSXRlbSAmJiBjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlSXRlbU9mZmxpbmVRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdXN0b21JdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjbGllbnRJdGVtLklkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgb2ZmbGluZVN5bmNPcGVyYXRpb25zLnB1c2godGhpcy5wcm9jZXNzUXVlcnkodXBkYXRlSXRlbU9mZmxpbmVRdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tSXRlbS5JZCA9IGNsaWVudEl0ZW0uSWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5jcmVhdGVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBjdXN0b21JdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUl0ZW0uSWQgPSBzZXJ2ZXJJdGVtLklkO1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5tb2RpZmllZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogY3VzdG9tSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICBpc0N1c3RvbTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfbWVyZ2VSZXNvbHZlZENvbmZsaWN0czogZnVuY3Rpb24gKGNvbmZsaWN0cywgc3luY0RhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9mZmxpbmVTeW5jT3BlcmF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBfLmVhY2goY29uZmxpY3RzLCBmdW5jdGlvbiAoY29uZmxpY3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IGNvbmZsaWN0LmNvbnRlbnRUeXBlTmFtZTtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChjb25mbGljdC5jb25mbGljdGluZ0l0ZW1zLCBmdW5jdGlvbiAoY29uZmxpY3RpbmdJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlU3luY0RhdGEgPSBzeW5jRGF0YVt0eXBlTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb25mbGljdGluZ0l0ZW0ucmVzdWx0LnJlc29sdXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvbi5LZWVwU2VydmVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlS2VlcFNlcnZlcih0eXBlTmFtZSwgY29uZmxpY3RpbmdJdGVtLCBvZmZsaW5lU3luY09wZXJhdGlvbnMsIGNvbnRlbnRUeXBlU3luY0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvbi5LZWVwQ2xpZW50OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlS2VlcENsaWVudChjb25mbGljdGluZ0l0ZW0sIGNvbnRlbnRUeXBlU3luY0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvbi5DdXN0b206XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNDb250ZW50VHlwZS5maWxlcyh0eXBlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gRXZlcmxpdmVFcnJvcnMuY3VzdG9tRmlsZVN5bmNOb3RTdXBwb3J0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoZXJyLm1lc3NhZ2UsIGVyci5jb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVDdXN0b20oY29uZmxpY3RpbmdJdGVtLCB0eXBlTmFtZSwgb2ZmbGluZVN5bmNPcGVyYXRpb25zLCBjb250ZW50VHlwZVN5bmNEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uU2tpcDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByc3ZwLmFsbChvZmZsaW5lU3luY09wZXJhdGlvbnMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRTeW5jSXRlbVN0YXRlczogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBvZmZsaW5lSXRlbXMsIHNlcnZlckl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZVN5bmNEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgaXRlbXNGb3JTeW5jOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEl0ZW1zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEl0ZW1zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkSXRlbXM6IFtdXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY29uZmxpY3RzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVOYW1lOiBjb250ZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zOiBbXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgXy5lYWNoKG9mZmxpbmVJdGVtcywgZnVuY3Rpb24gKG9mZmxpbmVJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VydmVySXRlbSA9IF8uZmluZFdoZXJlKHNlcnZlckl0ZW1zLCB7SWQ6IG9mZmxpbmVJdGVtLklkfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVySXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJJdGVtLklkID09PSBvZmZsaW5lSXRlbS5JZCAmJiBvZmZsaW5lSXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNldHVwLmNvbmZsaWN0cy5zdHJhdGVneSA9PT0gY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LkN1c3RvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25JdGVtRmFpbGVkKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uY2xpZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXZlcmxpdmVFcnJvcihFdmVybGl2ZUVycm9ycy5zeW5jRXJyb3IpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb2ZmbGluZUl0ZW0uSWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vbkl0ZW1GYWlsZWQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5zZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFdmVybGl2ZUVycm9yKEV2ZXJsaXZlRXJyb3JzLnN5bmNFcnJvciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzZXJ2ZXJJdGVtLklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vbkl0ZW1GYWlsZWQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLmNsaWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEV2ZXJsaXZlRXJyb3IoRXZlcmxpdmVFcnJvcnMuc3luY0Vycm9yKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29udGVudFR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNlcnZlckl0ZW0uSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpZW50SXRlbUNoYW5nZWQgPSAhIW9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1VwZGF0ZUNvbmZsaWN0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnRJdGVtQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNVcGRhdGVDb25mbGljdCA9IHNlcnZlckl0ZW0uTW9kaWZpZWRBdC5nZXRUaW1lKCkgIT09IG9mZmxpbmVJdGVtLk1vZGlmaWVkQXQuZ2V0VGltZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogd2hlbiBhbiBpdGVtIGlzIHJlbW92ZWQgb2ZmbGluZSBpdHMgTW9kaWZpZWRBdCBmaWVsZCBpcyBub3Qgc2V0LCBjaGVjayBpZiBpdCBuZWVkcyB0byBiZSBzZXQgb3Igd2UgY2FuIHVzZSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVXBkYXRlQ29uZmxpY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5jb25mbGljdHMuY29uZmxpY3RpbmdJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpdGVtIHdhcyBtb2RpZmllZCBvbiB0aGUgc2VydmVyIGFuZCBkZWxldGVkIGxvY2FsbHkgd2UgaGF2ZSBhIGNvbmZsaWN0IGFuZCBzZXQgdGhlIGNsaWVudCBpdGVtIHRvIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpdCBpcyBhIHNpbXBsZSBtb2RpZmljYXRpb24gY29uZmxpY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudEl0ZW06IG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQgPyBudWxsIDogb2ZmbGluZUl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJJdGVtOiBzZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5pdGVtc0ZvclN5bmMuZGVsZXRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogb2ZmbGluZUl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5pdGVtc0ZvclN5bmMubW9kaWZpZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBzZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IG9mZmxpbmVJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaW4gbWVtb3J5IGhhcyBiZWVuIG1vZGlmaWVkLCBidXQgdGhlIGl0ZW0gb24gdGhlIHNlcnZlciBoYXMgYmVlbiBkZWxldGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuY29uZmxpY3RzLmNvbmZsaWN0aW5nSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJdGVtOiBvZmZsaW5lSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckl0ZW06IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuaXRlbXNGb3JTeW5jLmNyZWF0ZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBvZmZsaW5lSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUeXBlU3luY0RhdGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldFJlc29sdXRpb25UeXBlRm9ySXRlbTogZnVuY3Rpb24gKHJlc29sdXRpb25UeXBlLCBjb25mbGljdGluZ0l0ZW0pIHtcclxuICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtLnJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdXRpb25UeXBlOiByZXNvbHV0aW9uVHlwZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hcHBseVJlc29sdXRpb25TdHJhdGVneTogZnVuY3Rpb24gKGNvbmZsaWN0cykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb25mbGljdFJlc29sdXRpb25TdHJhdGVneSA9IHNlbGYuc2V0dXAuY29uZmxpY3RzLnN0cmF0ZWd5O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3RSZXNvbHV0aW9uUHJvbWlzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZsaWN0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25mbGljdCA9IGNvbmZsaWN0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmxpY3QuY29uZmxpY3RpbmdJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb25mbGljdFJlc29sdXRpb25TdHJhdGVneSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuU2VydmVyV2luczpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY29uZmxpY3QuY29uZmxpY3RpbmdJdGVtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2V0UmVzb2x1dGlvblR5cGVGb3JJdGVtLmJpbmQoc2VsZiwgY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvbi5LZWVwU2VydmVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5DdXN0b206XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbVN0cmF0ZWd5ID0gc2VsZi5zZXR1cC5jb25mbGljdHMuaW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXN0b21TdHJhdGVneSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFdmVybGl2ZUVycm9yKCdJbXBsZW1lbnRhdGlvbiBvZiB0aGUgY29uZmxpY3QgcmVzb2x1dGlvbiBzdHJhdGVneSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ211c3QgYmUgcHJvdmlkZWQgd2hlbiBzZXQgdG8gQ3VzdG9tJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RSZXNvbHV0aW9uUHJvbWlzZXMucHVzaChuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVN0cmF0ZWd5KGNvbmZsaWN0cywgcmVzb2x2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IoJ0ludmFsaWQgcmVzb2x1dGlvbiBzdHJhdGVneSBwcm92aWRlZCcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByc3ZwLmFsbChjb25mbGljdFJlc29sdXRpb25Qcm9taXNlcylcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldFN5bmNQcm9taXNlQmF0Y2g6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgYmF0Y2hJZHMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb250ZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lkJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRpbic6IGJhdGNoSWRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZCxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGFwcGx5T2ZmbGluZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogcmVqZWN0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdE9wdGlvbnNGcm9tUXVlcnkgPSBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbZGF0YVF1ZXJ5Lm9wZXJhdGlvbl07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSBnZXRSZXF1ZXN0T3B0aW9uc0Zyb21RdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChzZWxmLl9ldmVybGl2ZS5zZXR1cCwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXREaXJ0eUl0ZW1zOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlQcm9jZXNzb3IuX2dldERpcnR5SXRlbXMoY29sbGVjdGlvbik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldFN5bmNQcm9taXNlRm9yQ29sbGVjdGlvbjogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBiYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSBjb25zdGFudHMuc3luY0JhdGNoU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZsaW5lSXRlbXNUb1N5bmMgPSBzZWxmLl9nZXREaXJ0eUl0ZW1zKGNvbGxlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFsbElkc0ZvclN5bmM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG91bGRBdXRvZ2VuZXJhdGVJZEZvckNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgYWxsSWRzRm9yU3luYyA9IF8ucGx1Y2sob2ZmbGluZUl0ZW1zVG9TeW5jLCAnX2lkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhbGxJZHNGb3JTeW5jID0gXy5wbHVjayhfLnJlamVjdChvZmZsaW5lSXRlbXNUb1N5bmMsIGZ1bmN0aW9uIChvZmZsaW5lSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lSXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkO1xyXG4gICAgICAgICAgICAgICAgfSksICdfaWQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGJhdGNoQ291bnQgPSBNYXRoLmNlaWwoYWxsSWRzRm9yU3luYy5sZW5ndGggLyBiYXRjaFNpemUpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYXRjaFNraXBTaXplID0gaSAqIGJhdGNoU2l6ZTtcclxuICAgICAgICAgICAgICAgIHZhciBiYXRjaElkcyA9IGFsbElkc0ZvclN5bmMuc2xpY2UoYmF0Y2hTa2lwU2l6ZSwgYmF0Y2hTa2lwU2l6ZSArIGJhdGNoU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3luY0dldFNlcnZlckl0ZW1zUHJvbWlzZSA9IHRoaXMuX2dldFN5bmNQcm9taXNlQmF0Y2goY29udGVudFR5cGUsIGJhdGNoSWRzKTtcclxuICAgICAgICAgICAgICAgIGJhdGNoZXMucHVzaChzeW5jR2V0U2VydmVySXRlbXNQcm9taXNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJzdnAuYWxsKGJhdGNoZXMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc2VydmVySXRlbXNTeW5jUmVzcG9uc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVySXRlbXM6IFtdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHNlcnZlckl0ZW1zU3luY1Jlc3BvbnNlcywgZnVuY3Rpb24gKHNlcnZlckl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXJ2ZXJJdGVtcyA9IF8udW5pb24ocmVzdWx0LnNlcnZlckl0ZW1zLCBzZXJ2ZXJJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5vZmZsaW5lSXRlbXNUb1N5bmMgPSBvZmZsaW5lSXRlbXNUb1N5bmM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9vbkl0ZW1GYWlsZWQ6IGZ1bmN0aW9uIChzeW5jUmVzdWx0LCBpdGVtSWQpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBzeW5jUmVzdWx0LnJlYXNvbiA/IHN5bmNSZXN1bHQucmVhc29uIDogc3luY1Jlc3VsdDtcclxuICAgICAgICAgICAgdmFyIHRhcmdldFR5cGUgPSByZXN1bHRzLmNvbnRlbnRUeXBlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGdldEZhaWxlZEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwaWNrZWRPYmplY3QgPSBfLnBpY2socmVzdWx0cywgJ3N0b3JhZ2UnLCAndHlwZScsICdlcnJvcicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiB0YXJnZXRUeXBlXHJcbiAgICAgICAgICAgICAgICB9LCBwaWNrZWRPYmplY3QpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhaWxlZEl0ZW1zID0gW107XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLnR5cGUgPT09IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQgJiYgcmVzdWx0cy5pdGVtcykge1xyXG4gICAgICAgICAgICAgICAgZmFpbGVkSXRlbXMgPSBfLm1hcChyZXN1bHRzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRGYWlsZWRJdGVtKGl0ZW0uSWQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmYWlsZWRJdGVtcy5wdXNoKGdldEZhaWxlZEl0ZW0oaXRlbUlkKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYuX3N5bmNSZXN1bHRJbmZvLmZhaWxlZEl0ZW1zW3RhcmdldFR5cGVdID0gc2VsZi5fc3luY1Jlc3VsdEluZm8uZmFpbGVkSXRlbXNbdGFyZ2V0VHlwZV0gfHwgW107XHJcbiAgICAgICAgICAgIF8uZWFjaChmYWlsZWRJdGVtcywgZnVuY3Rpb24gKGZhaWxlZEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3N5bmNSZXN1bHRJbmZvLmZhaWxlZEl0ZW1zW3RhcmdldFR5cGVdLnB1c2goZmFpbGVkSXRlbSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9maXJlSXRlbVByb2Nlc3NlZChmYWlsZWRJdGVtKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX29uSXRlbVByb2Nlc3NlZDogZnVuY3Rpb24gKGl0ZW0sIGNvbnRlbnRUeXBlLCBzeW5jU3RvcmFnZSwgc3luY1R5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHN5bmNJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtLklkLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogc3luY1R5cGUsXHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jU3RvcmFnZSxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fc3luY1Jlc3VsdEluZm8uc3luY2VkSXRlbXNbY29udGVudFR5cGVdID0gdGhpcy5fc3luY1Jlc3VsdEluZm8uc3luY2VkSXRlbXNbY29udGVudFR5cGVdIHx8IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRJdGVtc1tjb250ZW50VHlwZV0ucHVzaChzeW5jSW5mbyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3luY0luZm8uc3RvcmFnZSA9PSBzeW5jTG9jYXRpb24uc2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRUb1NlcnZlcisrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3luY1Jlc3VsdEluZm8uc3luY2VkVG9DbGllbnQrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fZmlyZUl0ZW1Qcm9jZXNzZWQoc3luY0luZm8pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9maXJlSXRlbVByb2Nlc3NlZDogZnVuY3Rpb24gKHN5bmNJbmZvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZXJsaXZlLl9lbWl0dGVyLmVtaXQoJ2l0ZW1Qcm9jZXNzZWQnLCBzeW5jSW5mbyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldENsaWVudFdpbnNTeW5jRGF0YTogZnVuY3Rpb24gKGNvbGxlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHN5bmNEYXRhID0ge307XHJcbiAgICAgICAgICAgIF8uZWFjaChjb2xsZWN0aW9ucywgZnVuY3Rpb24gKGNvbGxlY3Rpb24sIHR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN5bmNEYXRhW3R5cGVOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bmNEYXRhW3R5cGVOYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEl0ZW1zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRJdGVtczogW11cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkaXJ0eUl0ZW1zID0gc2VsZi5fZ2V0RGlydHlJdGVtcyhjb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtc0ZvclN5bmMgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLmlkVHJhbnNmb3JtKGRpcnR5SXRlbXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIF8uZWFjaChpdGVtc0ZvclN5bmMsIGZ1bmN0aW9uIChpdGVtRm9yU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaXRlbUZvclN5bmNbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jRGF0YVt0eXBlTmFtZV0uY3JlYXRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IGl0ZW1Gb3JTeW5jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGl0ZW1Gb3JTeW5jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY0RhdGFbdHlwZU5hbWVdLm1vZGlmaWVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogaXRlbUZvclN5bmMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogaXRlbUZvclN5bmNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNEYXRhW3R5cGVOYW1lXS5kZWxldGVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogaXRlbUZvclN5bmMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogaXRlbUZvclN5bmNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbUZvclN5bmNbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzeW5jRGF0YTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0TW9kaWZpZWRGaWxlc0ZvclN5bmNDbGllbnRXaW5zOiBmdW5jdGlvbiAoaXRlbUlkLCBpdGVtLCBjb2xsZWN0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBzZGsgPSBzZWxmLl9ldmVybGl2ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZsaW5lRmlsZXMgPSBzZWxmLmZpbGVzO1xyXG4gICAgICAgICAgICAgICAgb2ZmbGluZUZpbGVzLmdldE9mZmxpbmVMb2NhdGlvbihpdGVtSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3RyYW5zZmVyRmlsZSh0cnVlLCBpdGVtLCBsb2NhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuUmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiByZXN1bHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLnNlcnZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLnNlcnZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZGsuZmlsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXBkYXRlU2luZ2xlKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5JZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uc2VydmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob25saW5lUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ubGluZVJlc3VsdCA9IG9ubGluZVJlc3BvbnNlLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5Nb2RpZmllZEF0ID0gb25saW5lUmVzdWx0Lk1vZGlmaWVkQXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uSXRlbVByb2Nlc3NlZChpdGVtLCBjb2xsZWN0aW9uTmFtZSwgc3luY0xvY2F0aW9uLnNlcnZlciwgb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2RrLmZpbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZVNpbmdsZShpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtLklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5zZXJ2ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRNb2RpZmllZEl0ZW1Gb3JTeW5jQ2xpZW50V2luczogZnVuY3Rpb24gKGRhdGFDb2xsZWN0aW9uLCBpdGVtLCBjb2xsZWN0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlU2luZ2xlKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkl0ZW1Qcm9jZXNzZWQoaXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5zZXJ2ZXIsIG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRJdGVtID0gXy5leHRlbmQoe30sIGl0ZW0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vZGlmaWVkQXQ6IHJlcy5Nb2RpZmllZEF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWRJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5JZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3luYzogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NRdWVyeSh1cGRhdGVRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLnNlcnZlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtLklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5jbGllbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5JZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hZGRNb2RpZmllZEl0ZW1zRm9yU3luY0NsaWVudFdpbnM6IGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fYWRkVXBkYXRlZEl0ZW1zRm9yU3luYyhjb250ZW50VHlwZURhdGEsIGdldFN5bmNGaWx0ZXJOb01vZGlmaWVkQXQsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbS5JZDtcclxuICAgICAgICAgICAgICAgIGlmICghaXRlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1doZW4gdXBkYXRpbmcgYW4gaXRlbSBpdCBtdXN0IGhhdmUgYW4gSWQgZmllbGQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNDb250ZW50VHlwZS5maWxlcyhjb2xsZWN0aW9uTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jUHJvbWlzZXNbaXRlbUlkXSA9IHNlbGYuX2dldE1vZGlmaWVkRmlsZXNGb3JTeW5jQ2xpZW50V2lucyhpdGVtSWQsIGl0ZW0sIGNvbGxlY3Rpb25OYW1lKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW1JZF0gPSBzZWxmLl9nZXRNb2RpZmllZEl0ZW1Gb3JTeW5jQ2xpZW50V2lucyhkYXRhQ29sbGVjdGlvbiwgaXRlbSwgY29sbGVjdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWRkRGVsZXRlZEl0ZW1zRm9yU3luY0NsaWVudFdpbnM6IGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fYWRkRGVsZXRlZEl0ZW1zRm9yU3luYyhjb250ZW50VHlwZURhdGEsIGdldFN5bmNGaWx0ZXJOb01vZGlmaWVkQXQsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaXRlbSwgaXRlbUZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bmNQcm9taXNlc1tpdGVtLklkXSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbS5JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdXaGVuIGRlbGV0aW5nIGFuIGl0ZW0gaXQgbXVzdCBoYXZlIGFuIElkIGZpZWxkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseU9mZmxpbmUoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGVzdHJveVNpbmdsZShpdGVtRmlsdGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uSXRlbVByb2Nlc3NlZChpdGVtLCBjb2xsZWN0aW9uTmFtZSwgc3luY0xvY2F0aW9uLnNlcnZlciwgb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3B1cmdlQnlJZChjb2xsZWN0aW9uTmFtZSwgaXRlbS5JZCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChfLmV4dGVuZCh7fSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLmNsaWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChfLmV4dGVuZCh7fSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uc2VydmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbUlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYXBwbHlDbGllbnRXaW5zOiBmdW5jdGlvbiAoY29sbGVjdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgc3luY0RhdGEgPSB0aGlzLl9nZXRDbGllbnRXaW5zU3luY0RhdGEoY29sbGVjdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgc3luY1Byb21pc2VzID0ge307XHJcblxyXG4gICAgICAgICAgICBfLmVhY2goc3luY0RhdGEsIGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIHR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YUNvbGxlY3Rpb24gPSBzZWxmLl9ldmVybGl2ZS5kYXRhKHR5cGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZURhdGEuY3JlYXRlZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZENyZWF0ZWRJdGVtc0ZvclN5bmMoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLm1vZGlmaWVkSXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkTW9kaWZpZWRJdGVtc0ZvclN5bmNDbGllbnRXaW5zKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGF0YS5kZWxldGVkSXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkRGVsZXRlZEl0ZW1zRm9yU3luY0NsaWVudFdpbnMoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcnN2cC5oYXNoU2V0dGxlZChzeW5jUHJvbWlzZXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9tb2RpZnlGaWxlU3RhbmRhcmRTeW5jOiBmdW5jdGlvbiAoc3luY1Byb21pc2VzLCBpdGVtSWQsIGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCByZXNvbHV0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmlsZXNDb2xsZWN0aW9uID0gc2VsZi5fZXZlcmxpdmUuZmlsZXM7XHJcbiAgICAgICAgICAgIHN5bmNQcm9taXNlc1tpdGVtSWRdID0gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2ZmbGluZUxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5maWxlcy5nZXRPZmZsaW5lTG9jYXRpb24oaXRlbUlkKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChsb2NhdGlvbk9uRGlzaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZsaW5lTG9jYXRpb24gPSBsb2NhdGlvbk9uRGlzaztcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVzQ29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmlzU3luYyh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRCeUlkKGl0ZW1JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGUgPSByZXNwb25zZS5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLk1vZGlmaWVkQXQuZ2V0VGltZSgpICE9PSBpdGVtLk1vZGlmaWVkQXQuZ2V0VGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXy5leHRlbmQoe30sIG5ldyBFdmVybGl2ZUVycm9yKEV2ZXJsaXZlRXJyb3JzLnN5bmNDb25mbGljdCksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZsaW5lTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x1dGlvblR5cGUgPT09IGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uS2VlcFNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5maWxlcy5fc2F2ZUZpbGUoaXRlbS5VcmksIGl0ZW0uRmlsZW5hbWUsIGl0ZW0uSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5wdXJnZShvZmZsaW5lTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc29sdXRpb25UeXBlID09PSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uLktlZXBDbGllbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3RyYW5zZmVyRmlsZSh0cnVlLCBpdGVtLCBvZmZsaW5lTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZXZlcmxpdmUuZmlsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51c2VPZmZsaW5lKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXBkYXRlU2luZ2xlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX21vZGlmeUNvbnRlbnRUeXBlU3RhbmRhcmRTeW5jOiBmdW5jdGlvbiAoc3luY1Byb21pc2VzLCBpdGVtSWQsIGRhdGFDb2xsZWN0aW9uLCBpdGVtLCBpdGVtRmlsdGVyLCBjb2xsZWN0aW9uTmFtZSwgaXNDdXN0b20pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW1JZF0gPSBkYXRhQ29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgLmlzU3luYyh0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcclxuICAgICAgICAgICAgICAgIC51cGRhdGUoaXRlbSwgaXRlbUZpbHRlcilcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb25TeW5jUmVzcG9uc2UocmVzLCBpdGVtLCBjb2xsZWN0aW9uTmFtZSwgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlLCBpc0N1c3RvbSk7XHJcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLnNlcnZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hcHBseVN0YW5kYXJkU3luYzogZnVuY3Rpb24gKGNvbGxlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IHt9O1xyXG4gICAgICAgICAgICBfLmVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbY29udGVudFR5cGVdID0gc2VsZi5fZ2V0U3luY1Byb21pc2VGb3JDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcnN2cC5oYXNoKHByb21pc2VzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnRUeXBlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wcmVwYXJlU3luY0RhdGEoY29udGVudFR5cGVzKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3luY0RhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcmVzb2x2ZUNvbmZsaWN0cyhzeW5jRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnRUeXBlU3luY0RhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3luY1Byb21pc2VzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlU3luY0RhdGEsIGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIGNvbGxlY3Rpb25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhQ29sbGVjdGlvbiA9IHNlbGYuX2V2ZXJsaXZlLmRhdGEoY29sbGVjdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLmNyZWF0ZWRJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZENyZWF0ZWRJdGVtc0ZvclN5bmMoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGF0YS5tb2RpZmllZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkVXBkYXRlZEl0ZW1zRm9yU3luYyhjb250ZW50VHlwZURhdGEsIGdldFN5bmNGaWx0ZXJGb3JJdGVtLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaXRlbUZpbHRlciwgaXNDdXN0b20sIHJlc29sdXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZCA9IGl0ZW0uSWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0NvbnRlbnRUeXBlLmZpbGVzKGNvbGxlY3Rpb25OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9tb2RpZnlGaWxlU3RhbmRhcmRTeW5jKHN5bmNQcm9taXNlcywgaXRlbUlkLCBpdGVtLCBjb2xsZWN0aW9uTmFtZSwgcmVzb2x1dGlvblR5cGUsIGlzQ3VzdG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9tb2RpZnlDb250ZW50VHlwZVN0YW5kYXJkU3luYyhzeW5jUHJvbWlzZXMsIGl0ZW1JZCwgZGF0YUNvbGxlY3Rpb24sIGl0ZW0sIGl0ZW1GaWx0ZXIsIGNvbGxlY3Rpb25OYW1lLCBpc0N1c3RvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZURhdGEuZGVsZXRlZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkRGVsZXRlZEl0ZW1zRm9yU3luYyhjb250ZW50VHlwZURhdGEsIGdldFN5bmNGaWx0ZXJGb3JJdGVtLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaXRlbUZpbHRlciwgaXNDdXN0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jUHJvbWlzZXNbaXRlbS5JZF0gPSBkYXRhQ29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseU9mZmxpbmUoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kZXN0cm95KGl0ZW1GaWx0ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vblN5bmNSZXNwb25zZShyZXMsIGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmUsIGlzQ3VzdG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5JZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uc2VydmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnN2cC5oYXNoU2V0dGxlZChzeW5jUHJvbWlzZXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FwcGx5U3luYzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlQcm9jZXNzb3IuX2dldEFsbENvbGxlY3Rpb25zKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNldHVwLmNvbmZsaWN0cy5zdHJhdGVneSA9PT0gY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LkNsaWVudFdpbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2FwcGx5Q2xpZW50V2lucyhjb2xsZWN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2FwcGx5U3RhbmRhcmRTeW5jKGNvbGxlY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYWxsIHRoZSBvZmZsaW5lIGl0ZW1zIHRoYXQgaGF2ZSBub3QgYmVlbiBzeW5jZWQgb25saW5lLlxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0SXRlbXNGb3JTeW5jXHJcbiAgICAgICAgICogQG5hbWUgZ2V0SXRlbXNGb3JTeW5jXHJcbiAgICAgICAgICogQG1lbWJlck9mIE9mZmxpbmVNb2R1bGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbGwgdGhlIG9mZmxpbmUgaXRlbXMgdGhhdCBoYXZlIG5vdCBiZWVuIHN5bmNlZCBvbmxpbmUuXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRJdGVtc0ZvclN5bmNcclxuICAgICAgICAgKiBAbmFtZSBnZXRJdGVtc0ZvclN5bmNcclxuICAgICAgICAgKiBAbWVtYmVyT2YgT2ZmbGluZU1vZHVsZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0SXRlbXNGb3JTeW5jOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZGlydHlJdGVtc0ZvclN5bmMgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9xdWVyeVByb2Nlc3Nvci5fZ2V0QWxsQ29sbGVjdGlvbnMoKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBjb2xsZWN0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcnR5SXRlbXMgPSBzZWxmLl9nZXREaXJ0eUl0ZW1zKGNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlydHlJdGVtc0ZvclN5bmNbY29sbGVjdGlvbk5hbWVdID0gXy5tYXAoZGlydHlJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUZvclN5bmMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IF8uZXh0ZW5kKHt9LCBpdGVtKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBpdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbUZvclN5bmMuaXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtRm9yU3luYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYihkaXJ0eUl0ZW1zRm9yU3luYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3JDYik7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBPZmZsaW5lTW9kdWxlO1xyXG59KSgpO1xyXG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBwZXJzaXN0ZXJzID0gcmVxdWlyZSgnLi9vZmZsaW5lUGVyc2lzdGVycycpO1xyXG52YXIgTG9jYWxTdG9yYWdlUGVyc2lzdGVyID0gcGVyc2lzdGVycy5Mb2NhbFN0b3JhZ2VQZXJzaXN0ZXI7XHJcbnZhciBGaWxlU3lzdGVtUGVyc2lzdGVyID0gcGVyc2lzdGVycy5GaWxlU3lzdGVtUGVyc2lzdGVyO1xyXG52YXIgT2ZmbGluZVN0b3JhZ2VNb2R1bGUgPSByZXF1aXJlKCcuL09mZmxpbmVTdG9yYWdlTW9kdWxlJyk7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBpc05hdGl2ZVNjcmlwdCA9IHJlcXVpcmUoJy4uL2V2ZXJsaXZlLnBsYXRmb3JtJykuaXNOYXRpdmVTY3JpcHQ7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIENyeXB0b2dyYXBoaWNQcm92aWRlciA9IHJlcXVpcmUoJy4uL2VuY3J5cHRpb24vQ3J5cHRvZ3JhcGhpY1Byb3ZpZGVyJyk7XHJcblxyXG52YXIgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyA9IHtcclxuICAgIGF1dG9TeW5jOiB0cnVlLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIGNvbmZsaWN0czoge1xyXG4gICAgICAgIHN0cmF0ZWd5OiBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ2xpZW50V2lucyxcclxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogbnVsbFxyXG4gICAgfSxcclxuICAgIG9mZmxpbmU6IGZhbHNlLFxyXG4gICAgc3RvcmFnZToge1xyXG4gICAgICAgIG5hbWU6ICcnLFxyXG4gICAgICAgIHByb3ZpZGVyOiBpc05hdGl2ZVNjcmlwdCA/IGNvbnN0YW50cy5TdG9yYWdlUHJvdmlkZXIuRmlsZVN5c3RlbSA6IGNvbnN0YW50cy5TdG9yYWdlUHJvdmlkZXIuTG9jYWxTdG9yYWdlLFxyXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBudWxsLFxyXG4gICAgICAgIHN0b3JhZ2VQYXRoOiBjb25zdGFudHMuRGVmYXVsdFN0b3JhZ2VQYXRoXHJcbiAgICB9LFxyXG4gICAgdHlwZVNldHRpbmdzOiB7fSxcclxuICAgIGVuY3J5cHRpb246IHtcclxuICAgICAgICBwcm92aWRlcjogY29uc3RhbnRzLkVuY3J5cHRpb25Qcm92aWRlci5EZWZhdWx0LFxyXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBudWxsLFxyXG4gICAgICAgIGtleTogJydcclxuICAgIH0sXHJcbiAgICBmaWxlczoge1xyXG4gICAgICAgIHN0b3JhZ2VQYXRoOiBjb25zdGFudHMuRGVmYXVsdEZpbGVzU3RvcmFnZVBhdGgsXHJcbiAgICAgICAgbWV0YVBhdGg6IGNvbnN0YW50cy5EZWZhdWx0RmlsZXNNZXRhZGF0YVBhdGgsXHJcbiAgICAgICAgbWF4Q29uY3VycmVudERvd25sb2FkczogY29uc3RhbnRzLk1heENvbmN1cnJlbnREb3dubG9hZFRhc2tzXHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWdpZXMgPSB7fTtcclxuXHJcbiAgICBjb25mbGljdFJlc29sdXRpb25TdHJhdGVnaWVzW2NvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5DbGllbnRXaW5zXSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBsb2NhbCwgc2VydmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShsb2NhbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWdpZXNbY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LlNlcnZlcldpbnNdID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGxvY2FsLCBzZXJ2ZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICByZXNvbHZlKHNlcnZlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbml0U3RvcmFnZVBlcnNpc3RlciA9IGZ1bmN0aW9uIGluaXRTdG9yYWdlUGVyc2lzdGVyKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgc3RvcmFnZUtleSA9IG9wdGlvbnMuc3RvcmFnZS5uYW1lIHx8ICdldmVybGl2ZU9mZmxpbmVTdG9yYWdlXycgKyB0aGlzLnNldHVwLmFwaUtleTtcclxuICAgICAgICB2YXIgcGVyc2lzdGVyID0gcGVyc2lzdGVycy5nZXRQZXJzaXN0ZXIoc3RvcmFnZUtleSwgb3B0aW9ucyk7XHJcbiAgICAgICAgb3B0aW9ucy5zdG9yYWdlLmltcGxlbWVudGF0aW9uID0gcGVyc2lzdGVyO1xyXG4gICAgICAgIHJldHVybiBwZXJzaXN0ZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbml0RW5jcnlwdGlvblByb3ZpZGVyID0gZnVuY3Rpb24gaW5pdEVuY3J5cHRpb25Qcm92aWRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGVuY3J5cHRvcjtcclxuICAgICAgICB2YXIgZW5jcnlwdGlvblByb3ZpZGVyID0gb3B0aW9ucy5lbmNyeXB0aW9uLnByb3ZpZGVyO1xyXG4gICAgICAgIHZhciBlbmNyeXB0aW9uSW1wbGVtZW50YXRpb24gPSBvcHRpb25zLmVuY3J5cHRpb24uaW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgaWYgKF8uaXNPYmplY3QoZW5jcnlwdGlvbkltcGxlbWVudGF0aW9uKSAmJiBlbmNyeXB0aW9uUHJvdmlkZXIgPT09IGNvbnN0YW50cy5FbmNyeXB0aW9uUHJvdmlkZXIuQ3VzdG9tKSB7XHJcbiAgICAgICAgICAgIGVuY3J5cHRvciA9IGVuY3J5cHRpb25JbXBsZW1lbnRhdGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGVuY3J5cHRpb25Qcm92aWRlcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuRW5jcnlwdGlvblByb3ZpZGVyLkRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jcnlwdG9yID0gbmV3IENyeXB0b2dyYXBoaWNQcm92aWRlcihvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLkVuY3J5cHRpb25Qcm92aWRlci5DdXN0b206XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0N1c3RvbSBlbmNyeXB0aW9uIHByb3ZpZGVyIHJlcXVpcmVzIGFuIGltcGxlbWVudGF0aW9uIG9iamVjdCcpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBwcm92aWRlciAnICsgZW5jcnlwdGlvblByb3ZpZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0aW9ucy5lbmNyeXB0aW9uLmltcGxlbWVudGF0aW9uID0gZW5jcnlwdG9yO1xyXG4gICAgICAgIHJldHVybiBlbmNyeXB0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkT2ZmbGluZVN0b3JhZ2VPcHRpb25zKHNka09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgc3RvcmFnZU9wdGlvbnMgPSBzZGtPcHRpb25zLm9mZmxpbmUgfHwgc2RrT3B0aW9ucy5vZmZsaW5lU3RvcmFnZTtcclxuICAgICAgICB2YXIgb3B0aW9ucztcclxuICAgICAgICBpZiAoc3RvcmFnZU9wdGlvbnMgPT09IHRydWUpIHsgLy8gZXhwbGljaXQgY2hlY2sgZm9yIHNob3J0aGFuZCBpbml0aWFsaXphdGlvblxyXG4gICAgICAgICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHN0b3JhZ2VPcHRpb25zKSkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhzdG9yYWdlT3B0aW9ucywgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3RvcmFnZSA9IF8uZGVmYXVsdHMoc3RvcmFnZU9wdGlvbnMuc3RvcmFnZSwgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucy5zdG9yYWdlKTtcclxuICAgICAgICAgICAgb3B0aW9ucy5lbmNyeXB0aW9uID0gXy5kZWZhdWx0cyhzdG9yYWdlT3B0aW9ucy5lbmNyeXB0aW9uLCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zLmVuY3J5cHRpb24pO1xyXG4gICAgICAgICAgICBvcHRpb25zLmNvbmZsaWN0cyA9IF8uZGVmYXVsdHMoc3RvcmFnZU9wdGlvbnMuY29uZmxpY3RzLCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zLmNvbmZsaWN0cyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsZXMgPSBfLmRlZmF1bHRzKHN0b3JhZ2VPcHRpb25zLmZpbGVzLCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zLmZpbGVzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIXN0b3JhZ2VPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBzZGtPcHRpb25zLm9mZmxpbmVTdG9yYWdlID0gb3B0aW9ucztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0aW9ucy5jYWNoZUVuYWJsZWQgPSBzZGtPcHRpb25zLmNhY2hpbmcgJiYgc2RrT3B0aW9ucy5jYWNoaW5nLmVuYWJsZWQ7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJ1aWxkT2ZmbGluZVN0b3JhZ2VNb2R1bGUgPSBmdW5jdGlvbiBidWlsZE9mZmxpbmVTdG9yYWdlTW9kdWxlKHNka09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGJ1aWxkT2ZmbGluZVN0b3JhZ2VPcHRpb25zKHNka09wdGlvbnMpO1xyXG4gICAgICAgIHZhciBwZXJzaXN0ZXIgPSBpbml0U3RvcmFnZVBlcnNpc3Rlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBlbmNyeXB0aW9uUHJvdmlkZXIgPSBpbml0RW5jcnlwdGlvblByb3ZpZGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVN0b3JhZ2VNb2R1bGUodGhpcywgb3B0aW9ucywgcGVyc2lzdGVyLCBlbmNyeXB0aW9uUHJvdmlkZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgaW5pdE9mZmxpbmVTdG9yYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlID0gYnVpbGRPZmZsaW5lU3RvcmFnZU1vZHVsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGluaXRPZmZsaW5lU3RvcmFnZTogaW5pdE9mZmxpbmVTdG9yYWdlLFxyXG4gICAgICAgIGJ1aWxkT2ZmbGluZVN0b3JhZ2VPcHRpb25zOiBidWlsZE9mZmxpbmVTdG9yYWdlT3B0aW9uc1xyXG4gICAgfVxyXG59KCkpOyIsInZhciBCYXNlUGVyc2lzdGVyID0gcmVxdWlyZSgnLi9wZXJzaXN0ZXJzL0Jhc2VQZXJzaXN0ZXInKTtcclxudmFyIExvY2FsU3RvcmFnZVBlcnNpc3RlciA9IHJlcXVpcmUoJy4vcGVyc2lzdGVycy9Mb2NhbFN0b3JhZ2VQZXJzaXN0ZXInKTtcclxudmFyIEZpbGVTeXN0ZW1QZXJzaXN0ZXIgPSByZXF1aXJlKCcuL3BlcnNpc3RlcnMvRmlsZVN5c3RlbVBlcnNpc3RlcicpO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQmFzZVBlcnNpc3RlcjogQmFzZVBlcnNpc3RlcixcclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3RlcjogTG9jYWxTdG9yYWdlUGVyc2lzdGVyLFxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3RlcjogRmlsZVN5c3RlbVBlcnNpc3RlcixcclxuICAgIGdldFBlcnNpc3RlcjogZnVuY3Rpb24gKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcGVyc2lzdGVyO1xyXG5cclxuICAgICAgICB2YXIgc3RvcmFnZVByb3ZpZGVyID0gb3B0aW9ucy5zdG9yYWdlLnByb3ZpZGVyO1xyXG4gICAgICAgIHZhciBzdG9yYWdlUHJvdmlkZXJJbXBsZW1lbnRhdGlvbiA9IG9wdGlvbnMuc3RvcmFnZS5pbXBsZW1lbnRhdGlvbjtcclxuICAgICAgICBpZiAoXy5pc09iamVjdChzdG9yYWdlUHJvdmlkZXJJbXBsZW1lbnRhdGlvbikgJiYgc3RvcmFnZVByb3ZpZGVyID09PSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkN1c3RvbSkge1xyXG4gICAgICAgICAgICBwZXJzaXN0ZXIgPSBzdG9yYWdlUHJvdmlkZXJJbXBsZW1lbnRhdGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHN0b3JhZ2VQcm92aWRlcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkxvY2FsU3RvcmFnZTpcclxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZXIgPSBuZXcgTG9jYWxTdG9yYWdlUGVyc2lzdGVyKHN0b3JhZ2VLZXksIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkZpbGVTeXN0ZW06XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVyID0gbmV3IEZpbGVTeXN0ZW1QZXJzaXN0ZXIoc3RvcmFnZUtleSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5TdG9yYWdlUHJvdmlkZXIuQ3VzdG9tOlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdDdXN0b20gc3RvcmFnZSBwcm92aWRlciByZXF1aXJlcyBhbiBpbXBsZW1lbnRhdGlvbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0b3JhZ2UgdHlwZSAnICsgc3RvcmFnZVByb3ZpZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBlcnNpc3RlcjtcclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxudmFyIG9mZmxpbmVJdGVtU3RhdGVNYXJrZXIgPSBjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXI7XHJcblxyXG52YXIgdHJhdmVyc2VBbmRBcHBseSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3BlcmF0aW9uLCBhZGRpdGlvbmFsT3B0aW9ucykge1xyXG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gXy5tYXAodmFsdWUsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24oaXRlbSwgYWRkaXRpb25hbE9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gb3BlcmF0aW9uKHZhbHVlLCBhZGRpdGlvbmFsT3B0aW9ucyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgaWRUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2lkICYmICF2YWx1ZS5JZCkge1xyXG4gICAgICAgIHZhbHVlLklkID0gdmFsdWUuX2lkO1xyXG4gICAgICAgIGRlbGV0ZSB2YWx1ZS5faWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxudmFyIHJlbW92ZUlkVHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRzKSB7XHJcbiAgICB2YXIgdmVyaWZ5U3RhdGVDcmVhdGVkID0gb3B0cy52ZXJpZnlTdGF0ZUNyZWF0ZWQ7XHJcbiAgICB2YXIgc2hvdWxkTW9kaWZ5T2JqZWN0ID0gdmVyaWZ5U3RhdGVDcmVhdGVkID8gdmFsdWVbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gY29uc3RhbnRzLm9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQgOiB0cnVlO1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgKHZhbHVlLl9pZCB8fCB2YWx1ZS5JZCkgJiYgc2hvdWxkTW9kaWZ5T2JqZWN0KSB7XHJcbiAgICAgICAgZGVsZXRlIHZhbHVlLl9pZDtcclxuICAgICAgICBkZWxldGUgdmFsdWUuSWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxudmFyIHJlbW92ZU1hcmtlclRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgZGVsZXRlIHZhbHVlW29mZmxpbmVJdGVtU3RhdGVNYXJrZXJdO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxudmFyIG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMgPSB7XHJcbiAgICByZW1vdmVJZFRyYW5zZm9ybTogZnVuY3Rpb24gKHZhbHVlLCB2ZXJpZnlTdGF0ZUNyZWF0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJhdmVyc2VBbmRBcHBseSh2YWx1ZSwgcmVtb3ZlSWRUcmFuc2Zvcm0sIHt2ZXJpZnlTdGF0ZUNyZWF0ZWQ6IHZlcmlmeVN0YXRlQ3JlYXRlZH0pO1xyXG4gICAgfSxcclxuICAgIGlkVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdHJhdmVyc2VBbmRBcHBseSh2YWx1ZSwgaWRUcmFuc2Zvcm1hdGlvbik7XHJcbiAgICB9LFxyXG4gICAgc2luZ2xlRmllbGRUcmFuc2Zvcm06IGZ1bmN0aW9uIChzaW5nbGVGaWVsZEV4cHJlc3Npb24sIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW3NpbmdsZUZpZWxkRXhwcmVzc2lvbl07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRyYXZlcnNlQW5kVHJhbnNmb3JtRmlsdGVySWQ6IGZ1bmN0aW9uIChmaWx0ZXJPYmopIHtcclxuICAgICAgICBpZiAoZmlsdGVyT2JqICYmIGZpbHRlck9iai5JZCkge1xyXG4gICAgICAgICAgICBmaWx0ZXJPYmouX2lkID0gZmlsdGVyT2JqLklkO1xyXG4gICAgICAgICAgICBkZWxldGUgZmlsdGVyT2JqLklkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBmaWx0ZXJPYmopIHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlck9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdE1lbWJlciA9IGZpbHRlck9ialtwcm9wXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0TWVtYmVyID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMudHJhdmVyc2VBbmRUcmFuc2Zvcm1GaWx0ZXJJZChvYmplY3RNZW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbW92ZU1hcmtlcnNUcmFuc2Zvcm06IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0cmF2ZXJzZUFuZEFwcGx5KHZhbHVlLCByZW1vdmVNYXJrZXJUcmFuc2Zvcm0pO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZUZpZWxkc1RyYW5zZm9ybTogZnVuY3Rpb24gKHZhbHVlLCBmaWVsZHMpIHtcclxuICAgICAgICBfLmVhY2goZmllbGRzLCBmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2ZpZWxkXTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi8uLi9jb21tb24nKTtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxuXHJcbnZhciBCYXNlUGVyc2lzdGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBCYXNlUGVyc2lzdGVyXHJcbiAgICAgKiBAY2xhc3NkZXNjIEFuIGFic3RyYWN0aW9uIGxheWVyIGZvciBhbGwgcGVyc2lzdGVycy4gRXZlcnkgcGVyc2lzdGVyIGNhbiB3cml0ZS9yZWFkXHJcbiAgICAgKiBkYXRhIHRvL2Zyb20gYSBzcGVjaWZpYyBwbGFjZS4gVGhlIGRhdGEgaXMgc2F2ZWQgYXMga2V5LXZhbHVlIHBhaXJzIHdoZXJlIHRoZSBrZXlzIGFyZVxyXG4gICAgICogY29udGVudCB0eXBlcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmFzZVBlcnNpc3RlcihrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY29udGVudFR5cGVzU3RvcmVLZXkgPSB0aGlzLmtleSArICdAQ29udGVudFR5cGVzJztcclxuICAgIH1cclxuXHJcbiAgICBCYXNlUGVyc2lzdGVyLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFsbCB0aGUgc2F2ZWQgZGF0YS5cclxuICAgICAgICAgKiBAbWV0aG9kIGdldEFsbERhdGFcclxuICAgICAgICAgKiBAbWVtYmVyb2YgQmFzZVBlcnNpc3RlclxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBrZXlzIGFyZSB0aGUgY29udGVudCB0eXBlcyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSBpdGVtcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBbGxEYXRhOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fZ2V0Q29udGVudFR5cGVzKGZ1bmN0aW9uIChjb250ZW50VHlwZXMpIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChjb250ZW50VHlwZXMsIGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2NvbnRlbnRUeXBlXSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmdldERhdGEoY29udGVudFR5cGUsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByc3ZwLmhhc2gocHJvbWlzZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xyXG4gICAgICAgICAgICB9LCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2F2ZWQgZGF0YSBmb3IgYSBzcGVjaWZpYyBjb250ZW50IHR5cGUuXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXREYXRhXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IHR5cGUgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBCYXNlUGVyc2lzdGVyXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJldHJpZXZlZCBkYXRhLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldERhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtZXRob2QgZ2V0RGF0YSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYXZlcyBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZS5cclxuICAgICAgICAgKiBAbWV0aG9kIHNhdmVEYXRhXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IGZvciB3aGljaCB0byBzYXZlIHRoZSBkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZCBjb250ZW50IHR5cGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzYXZlRGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBkYXRhLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBzYXZlRGF0YSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIHBlcnNpc3RlZCBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZS5cclxuICAgICAgICAgKiBAbWV0aG9kIHB1cmdlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IHR5cGUgZm9yIHdoaWNoIHRvIGNsZWFyIHRoZSBkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBCYXNlUGVyc2lzdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVyZ2U6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtZXRob2QgY2xlYXIgaXMgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIGFsbCBwZXJzaXN0ZWQgZGF0YSBpbiB0aGUgb2ZmbGluZSBzdG9yZS5cclxuICAgICAgICAgKiBAbWV0aG9kIHB1cmdlQWxsXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXJnZUFsbDogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgbWV0aG9kIGNsZWFyQWxsIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRLZXk6IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXkgKyAnXycgKyBjb250ZW50VHlwZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0Q29udGVudFR5cGVzOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtZXRob2QgX2dldENvbnRlbnRUeXBlcyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBCYXNlUGVyc2lzdGVyO1xyXG59KCkpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlUGVyc2lzdGVyOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBGaWxlU3RvcmUgPSByZXF1aXJlKCcuLi8uLi9zdG9yYWdlcy9GaWxlU3RvcmUnKTtcclxudmFyIEJhc2VQZXJzaXN0ZXIgPSByZXF1aXJlKCcuL0Jhc2VQZXJzaXN0ZXInKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbicpO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuLi8uLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XHJcblxyXG52YXIgRmlsZVN5c3RlbVBlcnNpc3RlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBGaWxlU3lzdGVtUGVyc2lzdGVyXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAZXh0ZW5kcyBCYXNlUGVyc2lzdGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEZpbGVTeXN0ZW1QZXJzaXN0ZXIoa2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgQmFzZVBlcnNpc3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuZmlsZVN0b3JlID0gbmV3IEZpbGVTdG9yZShvcHRpb25zLnN0b3JhZ2Uuc3RvcmFnZVBhdGgsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHV0aWwuaW5oZXJpdHMoRmlsZVN5c3RlbVBlcnNpc3RlciwgQmFzZVBlcnNpc3Rlcik7XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuZ2V0QWxsRGF0YSA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSB0aGlzLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyKGVycm9yKTtcclxuICAgICAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnN1cGVyXy5wcm90b3R5cGUuZ2V0QWxsRGF0YS5jYWxsKHRoaXMsIHN1Y2Nlc3MsIGVycm9ySGFuZGxlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSB0aGlzLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyKGVycm9yKTtcclxuICAgICAgICB0aGlzLmdldEZpbGVIYW5kbGUoY29udGVudFR5cGUsIGZ1bmN0aW9uIChmaWxlRW50cnkpIHtcclxuICAgICAgICAgICAgc2VsZi5fcmVhZEZpbGVDb250ZW50KGZpbGVFbnRyeSwgc3VjY2VzcywgZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICB9LCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLnNhdmVEYXRhID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBkYXRhLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gdGhpcy5fZmlsZVN5c3RlbUVycm9ySGFuZGxlcihlcnJvcik7XHJcbiAgICAgICAgdGhpcy5nZXRGaWxlSGFuZGxlKGNvbnRlbnRUeXBlLCBmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3dyaXRlRmlsZUNvbnRlbnQoZmlsZUVudHJ5LCBkYXRhLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9zYXZlQ29udGVudFR5cGVzKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvckhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xyXG4gICAgICAgIH0sIGVycm9ySGFuZGxlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLnB1cmdlID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gdGhpcy5fZmlsZVN5c3RlbUVycm9ySGFuZGxlcihlcnJvcik7XHJcbiAgICAgICAgdGhpcy5nZXRGaWxlSGFuZGxlKGNvbnRlbnRUeXBlLCBmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuZmlsZVN0b3JlLnJlbW92ZUZpbGUoZmlsZUVudHJ5KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IpO1xyXG4gICAgICAgIH0sIGVycm9ySGFuZGxlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLnB1cmdlQWxsID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuZmlsZVN0b3JlLnJlbW92ZUZpbGVzRGlyZWN0b3J5KClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlcyA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZ2V0RGF0YSh0aGlzLmNvbnRlbnRUeXBlc1N0b3JlS2V5LCBmdW5jdGlvbiAoc2F2ZWRDb250ZW50VHlwZXNSYXcpIHtcclxuICAgICAgICAgICAgdmFyIHNhdmVkQ29udGVudFR5cGVzID0gSlNPTi5wYXJzZShzYXZlZENvbnRlbnRUeXBlc1JhdyB8fCAnW10nKTtcclxuICAgICAgICAgICAgc3VjY2VzcyhzYXZlZENvbnRlbnRUeXBlcyk7XHJcbiAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fc2F2ZUNvbnRlbnRUeXBlcyA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fZ2V0Q29udGVudFR5cGVzKGZ1bmN0aW9uIChzYXZlZENvbnRlbnRUeXBlcykge1xyXG4gICAgICAgICAgICBpZiAoIV8uY29udGFpbnMoc2F2ZWRDb250ZW50VHlwZXMsIGNvbnRlbnRUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgc2F2ZWRDb250ZW50VHlwZXMucHVzaChjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYuZ2V0RmlsZUhhbmRsZShzZWxmLmNvbnRlbnRUeXBlc1N0b3JlS2V5LCBmdW5jdGlvbiAoY29udGVudFR5cGVzRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fd3JpdGVGaWxlQ29udGVudChjb250ZW50VHlwZXNGaWxlLCBKU09OLnN0cmluZ2lmeShzYXZlZENvbnRlbnRUeXBlcyksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5nZXRGaWxlSGFuZGxlID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgcGF0aCA9IHNlbGYuX2dldEZpbGVQYXRoKGNvbnRlbnRUeXBlKTtcclxuICAgICAgICB0aGlzLmZpbGVTdG9yZS5nZXRGaWxlc0RpcmVjdG9yeSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbGVTdG9yZS5nZXRGaWxlKHBhdGgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZUhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlSGFuZGxlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX3JlYWRGaWxlQ29udGVudCA9IGZ1bmN0aW9uIChmaWxlRW50cnksIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5maWxlU3RvcmUucmVhZEZpbGVBc1RleHQoZmlsZUVudHJ5KS50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MoY29udGVudCk7XHJcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fd3JpdGVGaWxlQ29udGVudCA9IGZ1bmN0aW9uIChmaWxlRW50cnksIGNvbnRlbnQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5maWxlU3RvcmUud3JpdGVUZXh0VG9GaWxlKGZpbGVFbnRyeSwgY29udGVudClcclxuICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcclxuICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldEZpbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEtleShjb250ZW50VHlwZSk7XHJcbiAgICAgICAgLy9yZXR1cm4gdXRpbHMuam9pblBhdGgodGhpcy5maWxlU3RvcmUuZmlsZXNEaXJlY3RvcnlQYXRoLCB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlU3RvcmUuZ2V0RXJyb3JIYW5kbGVyKGNhbGxiYWNrKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEZpbGVTeXN0ZW1QZXJzaXN0ZXI7XHJcbn0oKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVTeXN0ZW1QZXJzaXN0ZXI7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbicpO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxudmFyIExvY2FsU3RvcmUgPSByZXF1aXJlKCcuLi8uLi9zdG9yYWdlcy9Mb2NhbFN0b3JlJyk7XHJcbnZhciBCYXNlUGVyc2lzdGVyID0gcmVxdWlyZSgnLi9CYXNlUGVyc2lzdGVyJyk7XHJcblxyXG52YXIgTG9jYWxTdG9yYWdlUGVyc2lzdGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXJcclxuICAgICAqIEBleHRlbmRzIEJhc2VQZXJzaXN0ZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTG9jYWxTdG9yYWdlUGVyc2lzdGVyKGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgIEJhc2VQZXJzaXN0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9sb2NhbFN0b3JlID0gbmV3IExvY2FsU3RvcmUob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgdXRpbC5pbmhlcml0cyhMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIsIEJhc2VQZXJzaXN0ZXIpO1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fZ2V0S2V5KGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgdmFyIHN0b3JlZEl0ZW0gPSB0aGlzLl9nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3Moc3RvcmVkSXRlbSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuc2F2ZURhdGEgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlS2V5ID0gdGhpcy5fZ2V0S2V5KGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0SXRlbShjb250ZW50VHlwZUtleSwgZGF0YSk7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5wdXJnZSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dldENvbnRlbnRUeXBlcyhmdW5jdGlvbiAoY29udGVudFR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZXMgPSBfLndpdGhvdXQoY29udGVudFR5cGVzLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9zZXRDb250ZW50VHlwZXNDb2xsZWN0aW9uKGNvbnRlbnRUeXBlcyk7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgIH0sIGVycm9yKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5wdXJnZUFsbCA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2dldENvbnRlbnRUeXBlcyhmdW5jdGlvbiAoY29udGVudFR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goY29udGVudFR5cGVzLCBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGVLZXkgPSBzZWxmLl9nZXRLZXkoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZUl0ZW0oY29udGVudFR5cGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlSXRlbShzZWxmLmNvbnRlbnRUeXBlc1N0b3JlS2V5KTtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLl9nZXRJdGVtID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0b3JlLmdldEl0ZW0oa2V5KTtcclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fc2V0SXRlbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmUuc2V0SXRlbShrZXksIHZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdG9yZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldEtleSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgIHRoaXMuX2FkZFR5cGVUb0NvbGxlY3Rpb25zQ2FjaGUoY29udGVudFR5cGUpO1xyXG4gICAgICAgIHJldHVybiBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIuc3VwZXJfLnByb3RvdHlwZS5fZ2V0S2V5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlcyA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbFN0b3JhZ2VTdHJpbmcgPSB0aGlzLl9nZXRJdGVtKHRoaXMuY29udGVudFR5cGVzU3RvcmVLZXkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlU3RyaW5nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3VjY2VzcyhkYXRhKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fc2V0Q29udGVudFR5cGVzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0SXRlbSh0aGlzLmNvbnRlbnRUeXBlc1N0b3JlS2V5LCBKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9uKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX2FkZFR5cGVUb0NvbGxlY3Rpb25zQ2FjaGUgPSBmdW5jdGlvbiAodHlwZU5hbWUpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fZ2V0Q29udGVudFR5cGVzKGZ1bmN0aW9uIChjb250ZW50VHlwZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGNvbnRlbnRUeXBlcywgdHlwZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZXMucHVzaCh0eXBlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9zZXRDb250ZW50VHlwZXNDb2xsZWN0aW9uKGNvbnRlbnRUeXBlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIExvY2FsU3RvcmFnZVBlcnNpc3RlcjtcclxufSgpKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTG9jYWxTdG9yYWdlUGVyc2lzdGVyOyIsInZhciBidWlsZFByb21pc2UgPSByZXF1aXJlKCcuLi91dGlscycpLmJ1aWxkUHJvbWlzZTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIFBsYXRmb3JtID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuUGxhdGZvcm07XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIGpzdHogPSBjb21tb24uanN0ejtcclxudmFyIF8gPSBjb21tb24uXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEN1cnJlbnREZXZpY2VcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gcHVzaEhhbmRsZXJcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICB2YXIgQ3VycmVudERldmljZSA9IGZ1bmN0aW9uIChwdXNoSGFuZGxlcikge1xyXG5cclxuICAgICAgICBpZiAoIXdpbmRvdy5jb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignRXJyb3I6IGN1cnJlbnREZXZpY2UoKSBjYW4gb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBoeWJyaWQgbW9iaWxlIGFwcCwgYWZ0ZXIgXFwnZGV2aWNlcmVhZHlcXCcgZXZlbnQgaGFzIGJlZW4gZmlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9wdXNoSGFuZGxlciA9IHB1c2hIYW5kbGVyO1xyXG4gICAgICAgIHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2luaXRFcnJvckNhbGxiYWNrID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy9TdWZmaXggZm9yIHRoZSBnbG9iYWwgY2FsbGJhY2sgZnVuY3Rpb25zXHJcbiAgICAgICAgdGhpcy5fZ2xvYmFsRnVuY3Rpb25TdWZmaXggPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wdXNoVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5lbXVsYXRvck1vZGUgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgQ3VycmVudERldmljZS5lbnN1cmVQdXNoSXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaXNQdXNoTm90aWZpY2F0aW9uUGx1Z2luQXZhaWxhYmxlID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wbHVnaW5zICYmIHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24pO1xyXG5cclxuICAgICAgICBpZiAoIWlzUHVzaE5vdGlmaWNhdGlvblBsdWdpbkF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcihcIlRoZSBwdXNoIG5vdGlmaWNhdGlvbiBwbHVnaW4gaXMgbm90IGF2YWlsYWJsZS4gRW5zdXJlIHRoYXQgdGhlIHB1c2hOb3RpZmljYXRpb24gcGx1Z2luIGlzIGluY2x1ZGVkIFwiICtcclxuICAgICAgICAgICAgXCJhbmQgdXNlIGFmdGVyIGBkZXZpY2VyZWFkeWAgZXZlbnQgaGFzIGJlZW4gZmlyZWQuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEN1cnJlbnREZXZpY2UucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucy4gVGhpcyBtZXRob2QgcmVxdWVzdHMgYSBwdXNoIHRva2VuIGZyb20gdGhlIGRldmljZSB2ZW5kb3IgYW5kIGVuYWJsZXMgdGhlIHB1c2ggbm90aWZpY2F0aW9uIGZ1bmN0aW9uYWxpdHkgb24gdGhlIGRldmljZS4gT25jZSB0aGlzIGlzIGRvbmUsIHlvdSBjYW4gcmVnaXN0ZXIgdGhlIGRldmljZSBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzaW5nIHRoZSByZWdpc3RlcigpIG1ldGhvZC5cclxuICAgICAgICAgKiBAbWV0aG9kIGVuYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbmFtZSBlbmFibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtQdXNoU2V0dGluZ3N9IHB1c2hTZXR0aW5ncyBBbiBvYmplY3Qgc3BlY2lmeWluZyB2YXJpb3VzIHNldHRpbmdzIGZvciB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBjdXJyZW50IGRldmljZSBmb3IgcHVzaCBub3RpZmljYXRpb25zLiBUaGlzIG1ldGhvZCByZXF1ZXN0cyBhIHB1c2ggdG9rZW4gZnJvbSB0aGUgZGV2aWNlIHZlbmRvciBhbmQgZW5hYmxlcyB0aGUgcHVzaCBub3RpZmljYXRpb24gZnVuY3Rpb25hbGl0eSBvbiB0aGUgZGV2aWNlLiBPbmNlIHRoaXMgaXMgZG9uZSwgeW91IGNhbiByZWdpc3RlciB0aGUgZGV2aWNlIGluIEV2ZXJsaXZlIHVzaW5nIHRoZSByZWdpc3RlcigpIG1ldGhvZC5cclxuICAgICAgICAgKiBAbWV0aG9kIGVuYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbmFtZSBlbmFibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtQdXNoU2V0dGluZ3N9IHB1c2hTZXR0aW5ncyBBbiBvYmplY3Qgc3BlY2lmeWluZyB2YXJpb3VzIHNldHRpbmdzIGZvciB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVuYWJsZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIChwdXNoU2V0dGluZ3MsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzID0gdGhpcy5fY2xlYW5QbGF0Zm9ybXNQdXNoU2V0dGluZ3MocHVzaFNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoXy5iaW5kKHRoaXMuX2luaXRpYWxpemUsIHRoaXMpLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZXMgcHVzaCBub3RpZmljYXRpb25zIGZvciB0aGUgY3VycmVudCBkZXZpY2UuIFRoaXMgbWV0aG9kIGludmFsaWRhdGVzIGFueSBwdXNoIHRva2VucyB0aGF0IHdlcmUgb2J0YWluZWQgZm9yIHRoZSBkZXZpY2UgZnJvbSB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi5cclxuICAgICAgICAgKiBAbWV0aG9kIGRpc2FibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG5hbWUgZGlzYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZXMgcHVzaCBub3RpZmljYXRpb25zIGZvciB0aGUgY3VycmVudCBkZXZpY2UuIFRoaXMgbWV0aG9kIGludmFsaWRhdGVzIGFueSBwdXNoIHRva2VucyB0aGF0IHdlcmUgb2J0YWluZWQgZm9yIHRoZSBkZXZpY2UgZnJvbSB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi5cclxuICAgICAgICAgKiBAbWV0aG9kIGRpc2FibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG5hbWUgZGlzYWJsZU5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGlzYWJsZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnJlZ2lzdGVyKCkudGhlbihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmVtdWxhdG9yTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1c2hOb3RpZmljYXRpb24gPSB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bnJlZ2lzdGVyT3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhdGZvcm1UeXBlID0gc2VsZi5fZ2V0UGxhdGZvcm1UeXBlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uV2luZG93c1Bob25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJPcHRpb25zID0geydjaGFubmVsTmFtZSc6IHNlbGYucHVzaFNldHRpbmdzLndwOC5jaGFubmVsTmFtZX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hOb3RpZmljYXRpb24udW5yZWdpc3RlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyT3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHB1c2ggcmVnaXN0cmF0aW9uIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbmFtZSBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcHVzaCByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFJlZ2lzdHJhdGlvbjogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLl9nZXREZXZpY2VJZCgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hIYW5kbGVyLmRldmljZXMuZ2V0QnlJZCgnSGFyZHdhcmVJZC8nICsgZGV2aWNlSWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlcnMgdGhlIGN1cnJlbnQgZGV2aWNlIGZvciBwdXNoIG5vdGlmaWNhdGlvbnMgaW4ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fS4gVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBvbmx5IGFmdGVyIFtlbmFibGVOb3RpZmljYXRpb25zKClde0BsaW5rIGN1cnJlbnREZXZpY2UuZW5hYmxlTm90aWZpY2F0aW9uc30gaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG9ubHkgYWZ0ZXIgW2VuYWJsZU5vdGlmaWNhdGlvbnMoKV17QGxpbmsgY3VycmVudERldmljZS5lbmFibGVOb3RpZmljYXRpb25zfSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VzdG9tUGFyYW1ldGVycyBDdXN0b20gcGFyYW1ldGVycyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChjdXN0b21QYXJhbWV0ZXJzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uID0ge307XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21QYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5QYXJhbWV0ZXJzID0gY3VzdG9tUGFyYW1ldGVycztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVsYXRlUmVnaXN0cmF0aW9uT2JqZWN0KGRldmljZVJlZ2lzdHJhdGlvbikudGhlbihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcHVzaEhhbmRsZXIuZGV2aWNlcy5jcmVhdGUoZGV2aWNlUmVnaXN0cmF0aW9uLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZnJvbSBwdXNoIG5vdGlmaWNhdGlvbnMgaW4ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fS4gQWZ0ZXIgdGhpcyBjYWxsIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHksIHt7c2l0ZS5ic319IHdpbGwgbm8gbG9uZ2VyIHNlbmQgbm90aWZpY2F0aW9ucyB0byB0aGlzIGRldmljZS4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgcHJldmVudCB0aGUgZGV2aWNlIGZyb20gcmVjZWl2aW5nIG5vdGlmaWNhdGlvbnMgYW5kIGRvZXMgbm90IGludmFsaWRhdGUgcHVzaCB0b2tlbnMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZnJvbSBwdXNoIG5vdGlmaWNhdGlvbnMgaW4ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fS4gQWZ0ZXIgdGhpcyBjYWxsIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHksIHt7c2l0ZS5ic319IHdpbGwgbm8gbG9uZ2VyIHNlbmQgbm90aWZpY2F0aW9ucyB0byB0aGlzIGRldmljZS4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgcHJldmVudCB0aGUgZGV2aWNlIGZyb20gcmVjZWl2aW5nIG5vdGlmaWNhdGlvbnMgYW5kIGRvZXMgbm90IGludmFsaWRhdGUgcHVzaCB0b2tlbnMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGRldmljZUlkID0gZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZS51dWlkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hIYW5kbGVyLmRldmljZXMuZGVzdHJveVNpbmdsZSh7SWQ6ICdIYXJkd2FyZUlkLycgKyBkZXZpY2VJZH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uIElmIHVuZGVmaW5lZCwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uIElmIHVuZGVmaW5lZCwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZVJlZ2lzdHJhdGlvbjogZnVuY3Rpb24gKGN1c3RvbVBhcmFtZXRlcnMsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgaWYgKGN1c3RvbVBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlBhcmFtZXRlcnMgPSBjdXN0b21QYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9wdWxhdGVSZWdpc3RyYXRpb25PYmplY3QoZGV2aWNlUmVnaXN0cmF0aW9uKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5JZCA9ICdIYXJkd2FyZUlkLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlUmVnaXN0cmF0aW9uLkhhcmR3YXJlSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wdXNoSGFuZGxlci5kZXZpY2VzLnVwZGF0ZVNpbmdsZShkZXZpY2VSZWdpc3RyYXRpb24sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHByb3ZpZGVzIGEgZGlmZmVyZW50IG9wZXJhdGlvbiBvbiBlYWNoIHN1cHBvcnRlZCBwbGF0Zm9ybTpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC0gT24gaU9TOiBDaGVja3MgaWYgTm90aWZpY2F0aW9ucyBpcyBlbmFibGVkIGZvciB0aGlzIGFwcGxpY2F0aW9uIGluIHRoZSBkZXZpY2UncyBOb3RpZmljYXRpb24gQ2VudGVyLlxyXG4gICAgICAgICAqIC0gT24gV2luZG93cyBQaG9uZTogQ2hlY2tzIGlmIHRoZSBhcHBsaWNhdGlvbiBoYXMgYW4gYWN0aXZlIG9wZW4gY2hhbm5lbCBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBNaWNyb3NvZnQgUHVzaCBOb3RpZmljYXRpb24gU2VydmljZS4gVGhlIG91dGNvbWUgZG9lcyBub3QgZGVwZW5kIG9uIHRoZSBkZXZpY2UncyBub3RpZmljYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgICogLSBPbiBBbmRyb2lkOiBDaGVja3MgaWYgdGhlIGFwcGxpY2F0aW9uIGhhcyBlc3RhYmxpc2hlZCBhIGNvbm5lY3Rpb24gd2l0aCBHb29nbGUgQ2xvdWQgTWVzc2FnaW5nLiBUaGUgb3V0Y29tZSBkb2VzIG5vdCBkZXBlbmQgb24gdGhlIGRldmljZSdzIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cclxuICAgICAgICAgKiBAbWV0aG9kIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXHJcbiAgICAgICAgICogQG5hbWUgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgcGFzc2VkIHRvIHRoZSBQdXNoIE5vdGlmaWNhdGlvbiBwbHVnaW4ncyBhcmVOb3RpZmljYXRpb25zRW5hYmxlZCBtZXRob2RcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGlPUzogQ2hlY2tzIGlmIHRoZSBOb3RpZmljYXRpb25zIGFyZSBlbmFibGVkIGZvciB0aGlzIEFwcGxpY2F0aW9uIGluIHRoZSBEZXZpY2UncyBOb3RpZmljYXRpb24gQ2VudGVyLlxyXG4gICAgICAgICAqIFdpbmRvd3MgUGhvbmU6IENoZWNrcyBpZiB0aGUgQXBwbGljYXRpb24gaGFzIGFuIGFjdGl2ZSBvcGVuZWQgQ2hhbm5lbCBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBOb3RpZmljYXRpb24gU2VydmljZS4gTm90IHJlbHlpbmcgb24gdGhlIGRldmljZSBub3RpZmljYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgICogQW5kcm9pZDogQ2hlY2tzIGlmIHRoZSBBcHBsaWNhdGlvbiBoYXMgZXN0YWJsaXNoZWQgY29ubmVjdGlvbiB3aXRoIHRoZSBOb3RpZmljYXRpb24gU2VydmljZS4gTm90IHJlbHlpbmcgb24gdGhlIGRldmljZSBub3RpZmljYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgICogQG1ldGhvZCBhcmVOb3RpZmljYXRpb25zRW5hYmxlZFxyXG4gICAgICAgICAqIEBuYW1lIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYW4gb2JqZWN0IHBhc3NlZCB0byB0aGUgUHVzaCBOb3RpZmljYXRpb24gcGx1Z2luJ3MgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWQgbWV0aG9kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzZnVsIGNoZWNrLiBQYXNzZXMgYSBzaW5nbGUgYm9vbGVhbiB2YWx1ZTogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZXJyb3IgaW4gdGhlIHB1c2ggcGx1Z2luIGhhcyBvY2N1cnJlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhcmVOb3RpZmljYXRpb25zRW5hYmxlZDogZnVuY3Rpb24gKG9wdGlvbnMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIHB1c2hOb3RpZmljYXRpb24gPSB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLmFyZU5vdGlmaWNhdGlvbnNFbmFibGVkKHN1Y2Nlc3NDYiwgZXJyb3JDYiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH0sIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2luaXRpYWxpemVJbnRlcmFjdGl2ZVB1c2g6IGZ1bmN0aW9uIChpT1NTZXR0aW5ncywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHB1c2hQbHVnaW4gPSB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uO1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVyYWN0aXZlU2V0dGluZ3MgPSBpT1NTZXR0aW5ncy5pbnRlcmFjdGl2ZVNldHRpbmdzO1xyXG4gICAgICAgICAgICB2YXIgbm90aWZpY2F0aW9uVHlwZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGlPU1NldHRpbmdzLmFsZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25UeXBlcy5wdXNoKHB1c2hQbHVnaW4uVXNlck5vdGlmaWNhdGlvblR5cGVzLkFsZXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaU9TU2V0dGluZ3MuYmFkZ2UpIHtcclxuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblR5cGVzLnB1c2gocHVzaFBsdWdpbi5Vc2VyTm90aWZpY2F0aW9uVHlwZXMuQmFkZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpT1NTZXR0aW5ncy5zb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uVHlwZXMucHVzaChwdXNoUGx1Z2luLlVzZXJOb3RpZmljYXRpb25UeXBlcy5Tb3VuZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBnZXRBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IF8uZmluZChpbnRlcmFjdGl2ZVNldHRpbmdzLmFjdGlvbnMsIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLmlkZW50aWZpZXIgPT09IGFjdGlvbklkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IF8ubWFwKGludGVyYWN0aXZlU2V0dGluZ3MuY2F0ZWdvcmllcywgZnVuY3Rpb24gKGNhdGVnb3J5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGNhdGVnb3J5LmlkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0ZvckRlZmF1bHRDb250ZXh0OiBfLm1hcChjYXRlZ29yeS5hY3Rpb25zRm9yRGVmYXVsdENvbnRleHQsIGdldEFjdGlvbiksXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Zvck1pbmltYWxDb250ZXh0OiBfLm1hcChjYXRlZ29yeS5hY3Rpb25zRm9yTWluaW1hbENvbnRleHQsIGdldEFjdGlvbilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBwdXNoUGx1Z2luLnJlZ2lzdGVyVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgd2hpY2ggd2lsbCBpbW1lZGlhdGVseSByZXR1cm4gKEFQTnMgaXMgbm90IGNvbnRhY3RlZCBmb3IgdGhpcylcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgaW4gY2FzZSB0aGUgY29uZmlndXJhdGlvbiBpcyBpbmNvcnJlY3RcclxuICAgICAgICAgICAgICAgIGVycm9yLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNraW5nIHBlcm1pc3Npb24gZm9yIHRoZXNlIGZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZXM6IG5vdGlmaWNhdGlvblR5cGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRoZXNlIGNhdGVnb3JpZXNcclxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9Jbml0aWFsaXplcyB0aGUgcHVzaCBmdW5jdGlvbmFsaXR5IG9uIHRoZSBkZXZpY2UuXHJcbiAgICAgICAgX2luaXRpYWxpemU6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemluZykge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IobmV3IEV2ZXJsaXZlRXJyb3IoJ1B1c2ggbm90aWZpY2F0aW9ucyBhcmUgY3VycmVudGx5IGluaXRpYWxpemluZy4nKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lbXVsYXRvck1vZGUgJiYgKCF3aW5kb3cubmF2aWdhdG9yIHx8ICF3aW5kb3cubmF2aWdhdG9yLmdsb2JhbGl6YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcihuZXcgRXZlcmxpdmVFcnJvcignVGhlIGdsb2JhbGl6YXRpb24gcGx1Z2luIGlzIG5vdCBpbml0aWFsaXplZC4nKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lbXVsYXRvck1vZGUgJiYgKCF3aW5kb3cucGx1Z2lucyB8fCAhd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgcHVzaCBub3RpZmljYXRpb25zIHBsdWdpbiBpcyBub3QgaW5pdGlhbGl6ZWQuJykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9pbml0U3VjY2Vzc0NhbGxiYWNrID0gc3VjY2VzcztcclxuICAgICAgICAgICAgdGhpcy5faW5pdEVycm9yQ2FsbGJhY2sgPSBlcnJvcjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3ModGhpcy5wdXNoVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5lbXVsYXRvck1vZGUpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKCdmYWtlX3B1c2hfdG9rZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIDEwMDBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHRoaXMuX2dsb2JhbEZ1bmN0aW9uU3VmZml4O1xyXG4gICAgICAgICAgICBpZiAoIXN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgc3VmZml4ID0gRGF0ZS5ub3coKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsRnVuY3Rpb25TdWZmaXggPSBzdWZmaXg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwdXNoTm90aWZpY2F0aW9uID0gd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIHZhciBwbGF0Zm9ybVR5cGUgPSB0aGlzLl9nZXRQbGF0Zm9ybVR5cGUoKTtcclxuICAgICAgICAgICAgaWYgKHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uaU9TKSB7XHJcbiAgICAgICAgICAgICAgICAvL0luaXRpYWxpemUgZ2xvYmFsIEFQTiBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwbkNhbGxiYWNrTmFtZSA9ICdhcG5DYWxsYmFja18nICsgc3VmZml4O1xyXG4gICAgICAgICAgICAgICAgRXZlcmxpdmUuUHVzaENhbGxiYWNrc1thcG5DYWxsYmFja05hbWVdID0gXy5iaW5kKHRoaXMuX29uTm90aWZpY2F0aW9uQVBOLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0NvbnN0cnVjdCByZWdpc3RyYXRpb24gb3B0aW9ucyBvYmplY3QgYW5kIHZhbGlkYXRlIGlPUyBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwblJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB0aGlzLnB1c2hTZXR0aW5ncy5pT1M7XHJcbiAgICAgICAgICAgICAgICBhcG5SZWdpc3RyYXRpb25PcHRpb25zLmVjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyBhcG5DYWxsYmFja05hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZWdpc3RlciBmb3IgQVBOXHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9zdWNjZXNzZnVsUmVnaXN0cmF0aW9uQVBOLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fZmFpbGVkUmVnaXN0cmF0aW9uQVBOLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBhcG5SZWdpc3RyYXRpb25PcHRpb25zXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uQW5kcm9pZCkge1xyXG4gICAgICAgICAgICAgICAgLy9Jbml0aWFsaXplIGdsb2JhbCBHQ00gY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIHZhciBnY21DYWxsYmFja05hbWUgPSAnZ2NtQ2FsbGJhY2tfJyArIHN1ZmZpeDtcclxuICAgICAgICAgICAgICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3NbZ2NtQ2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9vbk5vdGlmaWNhdGlvbkdDTSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9Db25zdHJ1Y3QgcmVnaXN0cmF0aW9uIG9wdGlvbnMgb2JqZWN0IGFuZCB2YWxpZGF0ZSB0aGUgQW5kcm9pZCBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgdmFyIGdjbVJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB0aGlzLnB1c2hTZXR0aW5ncy5hbmRyb2lkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVBbmRyb2lkU2V0dGluZ3MoZ2NtUmVnaXN0cmF0aW9uT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBnY21SZWdpc3RyYXRpb25PcHRpb25zLmVjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyBnY21DYWxsYmFja05hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZWdpc3RlciBmb3IgR0NNXHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9zdWNjZXNzU2VudFJlZ2lzdHJhdGlvbkdDTSwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMuX2Vycm9yU2VudFJlZ2lzdHJhdGlvbkdDTSwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgZ2NtUmVnaXN0cmF0aW9uT3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtLldpbmRvd3NQaG9uZSkge1xyXG4gICAgICAgICAgICAgICAgLy9Jbml0aWFsaXplIGdsb2JhbCBXUDggY2FsbGJhY2tzLlxyXG4gICAgICAgICAgICAgICAgdmFyIHdwOENhbGxiYWNrTmFtZSA9ICd3cDhDYWxsYmFja18nICsgc3VmZml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHdwOFJlZ2lzdHJhdGlvblN1Y2Nlc3NDYWxsYmFja05hbWUgPSAnd3A4UmVnaXN0cmF0aW9uU3VjY2Vzc0NhbGxiYWNrXycgKyBzdWZmaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgd3A4UmVnaXN0cmF0aW9uRXJyb3JDYWxsYmFja05hbWUgPSAnd3A4UmVnaXN0cmF0aW9uRXJyb3JDYWxsYmFja18nICsgc3VmZml4O1xyXG5cclxuICAgICAgICAgICAgICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3Nbd3A4Q2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9vbk5vdGlmaWNhdGlvbldQOCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW3dwOFJlZ2lzdHJhdGlvblN1Y2Nlc3NDYWxsYmFja05hbWVdID0gXy5iaW5kKHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3NXUCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW3dwOFJlZ2lzdHJhdGlvbkVycm9yQ2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ29uc3RydWN0IHJlZ2lzdHJhdGlvbiBvcHRpb25zIG9iamVjdCBhbmQgdmFsaWRhdGUgdGhlIFdQOCAgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgIHZhciB3cDhSZWdpc3RyYXRpb25PcHRpb25zID0gdGhpcy5wdXNoU2V0dGluZ3Mud3A4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVXUDhTZXR0aW5ncyh3cDhSZWdpc3RyYXRpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMuZWNiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIHdwOENhbGxiYWNrTmFtZTtcclxuICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMudWNjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyB3cDhSZWdpc3RyYXRpb25TdWNjZXNzQ2FsbGJhY2tOYW1lO1xyXG4gICAgICAgICAgICAgICAgd3A4UmVnaXN0cmF0aW9uT3B0aW9ucy5lcnJjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyB3cDhSZWdpc3RyYXRpb25FcnJvckNhbGxiYWNrTmFtZTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgcHVzaE5vdGlmaWNhdGlvbi5yZWdpc3RlcihcclxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fc3VjY2Vzc1NlbnRSZWdpc3RyYXRpb25XUDgsIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9lcnJvclNlbnRSZWdpc3RyYXRpb25XUDgsIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnNcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBjdXJyZW50IHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQ6ICcgKyBkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3NXUDogZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKHJlc3VsdC51cmkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF92YWxpZGF0ZUFuZHJvaWRTZXR0aW5nczogZnVuY3Rpb24gKGFuZHJvaWRTZXR0aW5ncykge1xyXG4gICAgICAgICAgICBpZiAoIWFuZHJvaWRTZXR0aW5ncy5zZW5kZXJJRCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1NlbmRlciBJRCAocHJvamVjdCBudW1iZXIpIGlzIG5vdCBzZXQgaW4gdGhlIGFuZHJvaWQgc2V0dGluZ3MuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfdmFsaWRhdGVXUDhTZXR0aW5nczogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuY2hhbm5lbE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdjaGFubmVsTmFtZSBpcyBub3Qgc2V0IGluIHRoZSBXUDggc2V0dGluZ3MuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfY2xlYW5QbGF0Zm9ybXNQdXNoU2V0dGluZ3M6IGZ1bmN0aW9uIChwdXNoU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGNsZWFuU2V0dGluZ3MgPSB7fTtcclxuICAgICAgICAgICAgcHVzaFNldHRpbmdzID0gcHVzaFNldHRpbmdzIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGFkZFNldHRpbmdzRm9yUGxhdGZvcm0gPSBmdW5jdGlvbiBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtKG5ld1NldHRpbmdzT2JqZWN0LCBwbGF0Zm9ybSwgYWxsb3dlZEZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwdXNoU2V0dGluZ3NbcGxhdGZvcm1dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG5ld1NldHRpbmdzT2JqZWN0W3BsYXRmb3JtXSA9IG5ld1NldHRpbmdzT2JqZWN0W3BsYXRmb3JtXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdQbGF0Zm9ybVNldHRpbmdzID0gcHVzaFNldHRpbmdzW3BsYXRmb3JtXTtcclxuICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IG5ld1NldHRpbmdzT2JqZWN0W3BsYXRmb3JtXTtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChhbGxvd2VkRmllbGRzLCBmdW5jdGlvbiAoYWxsb3dlZEZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1BsYXRmb3JtU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYWxsb3dlZEZpZWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1thbGxvd2VkRmllbGRdID0gbmV3UGxhdGZvcm1TZXR0aW5nc1thbGxvd2VkRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybShjbGVhblNldHRpbmdzLCAnaU9TJywgWydiYWRnZScsICdzb3VuZCcsICdhbGVydCcsICdpbnRlcmFjdGl2ZVNldHRpbmdzJ10pO1xyXG4gICAgICAgICAgICBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtKGNsZWFuU2V0dGluZ3MsICdhbmRyb2lkJywgWydzZW5kZXJJRCcsICdwcm9qZWN0TnVtYmVyJ10pO1xyXG4gICAgICAgICAgICBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtKGNsZWFuU2V0dGluZ3MsICd3cDgnLCBbJ2NoYW5uZWxOYW1lJ10pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrRmllbGRzID0gWydub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQnLCAnbm90aWZpY2F0aW9uQ2FsbGJhY2tJT1MnLCAnbm90aWZpY2F0aW9uQ2FsbGJhY2tXUDgnXTtcclxuICAgICAgICAgICAgXy5lYWNoKGNhbGxiYWNrRmllbGRzLCBmdW5jdGlvbiAoY2FsbGJhY2tGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gcHVzaFNldHRpbmdzW2NhbGxiYWNrRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIFwiJyArIGNhbGxiYWNrRmllbGQgKyAnXCIgb2YgdGhlIHB1c2ggc2V0dGluZ3Mgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFuU2V0dGluZ3NbY2FsbGJhY2tGaWVsZF0gPSBwdXNoU2V0dGluZ3NbY2FsbGJhY2tGaWVsZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHB1c2hTZXR0aW5ncy5jdXN0b21QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhblNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnMgPSBwdXNoU2V0dGluZ3MuY3VzdG9tUGFyYW1ldGVycztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsZWFuU2V0dGluZ3M7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3BvcHVsYXRlUmVnaXN0cmF0aW9uT2JqZWN0OiBmdW5jdGlvbiAoZGV2aWNlUmVnaXN0cmF0aW9uLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnB1c2hUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignUHVzaCB0b2tlbiBpcyBub3QgYXZhaWxhYmxlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZ2V0TG9jYWxlTmFtZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRldmljZUlkID0gc2VsZi5fZ2V0RGV2aWNlSWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXJkd2FyZU1vZGVsID0gZGV2aWNlLm1vZGVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYXRmb3JtVHlwZSA9IHNlbGYuX2dldFBsYXRmb3JtVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVab25lID0ganN0ei5kZXRlcm1pbmUoKS5uYW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHVzaFRva2VuID0gc2VsZi5wdXNoVG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBsb2NhbGUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhdGZvcm1WZXJzaW9uID0gZGV2aWNlLnZlcnNpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLkhhcmR3YXJlSWQgPSBkZXZpY2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5IYXJkd2FyZU1vZGVsID0gaGFyZHdhcmVNb2RlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5QbGF0Zm9ybVR5cGUgPSBwbGF0Zm9ybVR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUGxhdGZvcm1WZXJzaW9uID0gcGxhdGZvcm1WZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlRpbWVab25lID0gdGltZVpvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUHVzaFRva2VuID0gcHVzaFRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLkxvY2FsZSA9IGxhbmd1YWdlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRMb2NhbGVOYW1lOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW11bGF0b3JNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzKHt2YWx1ZTogJ2VuX1VTJ30pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLmdsb2JhbGl6YXRpb24uZ2V0TG9jYWxlTmFtZShcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MobG9jYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLmdsb2JhbGl6YXRpb24uZ2V0TG9jYWxlTmFtZShcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXREZXZpY2VJZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlLnV1aWQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9SZXR1cm5zIHRoZSBFdmVybGl2ZSBkZXZpY2UgcGxhdGZvcm0gY29uc3RhbnQgZ2l2ZW4gYSB2YWx1ZSBhcXVpcmVkIGZyb20gY29yZG92YSdzIGRldmljZS5wbGF0Zm9ybS5cclxuICAgICAgICBfZ2V0UGxhdGZvcm1UeXBlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwc0xvd2VyID0gZGV2aWNlLnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocHNMb3dlcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaW9zJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2lwaG9uZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpcGFkJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uaU9TO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYW5kcm9pZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLkFuZHJvaWQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd3aW5jZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLldpbmRvd3NQaG9uZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3dpbjMybnQnOiAvLyByZWFsIHdwOCBkZXZpY2VzIHJldHVybiB0aGlzIHN0cmluZyBhcyBwbGF0Zm9ybSBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbGF0Zm9ybS5XaW5kb3dzUGhvbmU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbGF0Zm9ybS5Vbmtub3duO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZDogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaFRva2VuID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbml0RXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdEVycm9yQ2FsbGJhY2soe2Vycm9yOiBlcnJvcn0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3M6IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hUb2tlbiA9IHRva2VuO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5pdFN1Y2Nlc3NDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3NDYWxsYmFjayh7dG9rZW46IHRva2VufSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL09jY3VycyB3aGVuIHRoZSBkZXZpY2UgcmVnaXN0cmF0aW9uIGluIEFQTiBzdWNjZWVkc1xyXG4gICAgICAgIF9zdWNjZXNzZnVsUmVnaXN0cmF0aW9uQVBOOiBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3MuaU9TICYmIHRoaXMucHVzaFNldHRpbmdzLmlPUy5pbnRlcmFjdGl2ZVNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW50ZXJhY3RpdmVQdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLmlPUyxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3ModG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIGludGVyYWN0aXZlIHB1c2ggY29uZmlndXJhdGlvbiBpcyBpbmNvcnJlY3Q6ICcgKyBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKHRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vT2NjdXJzIGlmIHRoZSBkZXZpY2UgcmVnaXN0cmF0aW9uIGluIEFQTiBmYWlsc1xyXG4gICAgICAgIF9mYWlsZWRSZWdpc3RyYXRpb25BUE46IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQoZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gZGV2aWNlIHJlZ2lzdHJhdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2VudCB0byBHQ01cclxuICAgICAgICBfc3VjY2Vzc1NlbnRSZWdpc3RyYXRpb25HQ006IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IHNlbnQgcmVxdWVzdCBmb3IgcmVnaXN0ZXJpbmcgd2l0aCBHQ00uXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9PY2N1cnMgd2hlbiBkZXZpY2UgcmVnaXN0cmF0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZW50IGZvciBXUDhcclxuICAgICAgICBfc3VjY2Vzc1NlbnRSZWdpc3RyYXRpb25XUDg6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IHNlbnQgcmVxdWVzdCBmb3IgcmVnaXN0ZXJpbmcgV1A4IC5cIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL09jY3VycyB3aGVuIGFuIGVycm9yIG9jY3VyZWQgd2hlbiBzZW5kaW5nIHJlZ2lzdHJhdGlvbiByZXF1ZXN0IGZvciBXUDhcclxuICAgICAgICBfZXJyb3JTZW50UmVnaXN0cmF0aW9uV1A4OiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uRmFpbGVkKGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL09jY3VycyB3aGVuIGFuIGVycm9yIG9jY3VyZWQgd2hlbiBzZW5kaW5nIHJlZ2lzdHJhdGlvbiByZXF1ZXN0IHRvIEdDTVxyXG4gICAgICAgIF9lcnJvclNlbnRSZWdpc3RyYXRpb25HQ006IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQoZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vVGhpcyBmdW5jdGlvbiByZWNlaXZlcyBhbGwgbm90aWZpY2F0aW9uIGV2ZW50cyBmcm9tIEFQTlxyXG4gICAgICAgIF9vbk5vdGlmaWNhdGlvbkFQTjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFpc2VOb3RpZmljYXRpb25FdmVudElPUyhlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vVGhpcyBmdW5jdGlvbiByZWNlaXZlcyBhbGwgbm90aWZpY2F0aW9uIGV2ZW50cyBmb3IgV1A4XHJcbiAgICAgICAgX29uTm90aWZpY2F0aW9uV1A4OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50V1A4KGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vVGhpcyBmdW5jdGlvbiByZWNlaXZlcyBhbGwgbm90aWZpY2F0aW9uIGV2ZW50cyBmcm9tIEdDTVxyXG4gICAgICAgIF9vbk5vdGlmaWNhdGlvbkdDTTogZnVuY3Rpb24gb25Ob3RpZmljYXRpb25HQ00oZSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGUuZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlZ2lzdGVyZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJlZ2lkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2VzcyhlLnJlZ2lkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50QW5kcm9pZChlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHVzaFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50QW5kcm9pZChlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50SU9TOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tJT1MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrSU9TKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfcmFpc2VOb3RpZmljYXRpb25FdmVudFdQODogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrV1A4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja1dQOChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEN1cnJlbnREZXZpY2U7XHJcbn0oKSk7XHJcbiIsInZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL2V2ZXJsaXZlLnBsYXRmb3JtJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChwbGF0Zm9ybS5pc05hdGl2ZVNjcmlwdCkge1xyXG5cdHZhciBOYXRpdmVTY3JpcHRDdXJyZW50RGV2aWNlID0gcmVxdWlyZSgnLi9OYXRpdmVTY3JpcHRDdXJyZW50RGV2aWNlJyk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE5hdGl2ZVNjcmlwdEN1cnJlbnREZXZpY2U7XHJcbn0gZWxzZSBpZiAocGxhdGZvcm0uaXNDb3Jkb3ZhIHx8IHBsYXRmb3JtLmlzRGVza3RvcCkge1xyXG5cdHZhciBDb3Jkb3ZhQ3VycmVudERldmljZSA9IHJlcXVpcmUoJy4vQ29yZG92YUN1cnJlbnREZXZpY2UnKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29yZG92YUN1cnJlbnREZXZpY2U7XHJcbn0gZWxzZSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF8ubm9vcDtcclxufSIsInZhciBidWlsZFByb21pc2UgPSByZXF1aXJlKCcuLi91dGlscycpLmJ1aWxkUHJvbWlzZTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIFBsYXRmb3JtID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuUGxhdGZvcm07XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIGpzdHogPSBjb21tb24uanN0ejtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIHRuc1B1c2hQbHVnaW4gPSByZXF1aXJlKCduYXRpdmVzY3JpcHQtcHVzaC1ub3RpZmljYXRpb25zJyk7XHJcbnZhciB0bnNQbGF0Zm9ybSA9IHJlcXVpcmUoJ3BsYXRmb3JtJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBDdXJyZW50RGV2aWNlXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHB1c2hIYW5kbGVyXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIEN1cnJlbnREZXZpY2UgPSBmdW5jdGlvbiAocHVzaEhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9wdXNoSGFuZGxlciA9IHB1c2hIYW5kbGVyO1xyXG4gICAgICAgIHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2luaXRFcnJvckNhbGxiYWNrID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy9TdWZmaXggZm9yIHRoZSBnbG9iYWwgY2FsbGJhY2sgZnVuY3Rpb25zXHJcbiAgICAgICAgdGhpcy5fZ2xvYmFsRnVuY3Rpb25TdWZmaXggPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wdXNoVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5lbXVsYXRvck1vZGUgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgQ3VycmVudERldmljZS5lbnN1cmVQdXNoSXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBOYXRpdmVTY3JpcHQgd2lsbCB0aHJvdyBhbiBlcnJvciB3aGVuIHRoZSBUTlMgUHVzaCBQbHVnaW4gY2Fubm90IGJlIHJlcXVpcmVkLiBTbyB0aGlzIGlzIGFjdHVhbGx5IHVucmVhY2hhYmxlLlxyXG4gICAgfTtcclxuXHJcbiAgICBDdXJyZW50RGV2aWNlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGN1cnJlbnQgZGV2aWNlIGZvciBwdXNoIG5vdGlmaWNhdGlvbnMuIFRoaXMgbWV0aG9kIHJlcXVlc3RzIGEgcHVzaCB0b2tlbiBmcm9tIHRoZSBkZXZpY2UgdmVuZG9yIGFuZCBlbmFibGVzIHRoZSBwdXNoIG5vdGlmaWNhdGlvbiBmdW5jdGlvbmFsaXR5IG9uIHRoZSBkZXZpY2UuIE9uY2UgdGhpcyBpcyBkb25lLCB5b3UgY2FuIHJlZ2lzdGVyIHRoZSBkZXZpY2UgaW4ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2luZyB0aGUgcmVnaXN0ZXIoKSBtZXRob2QuXHJcbiAgICAgICAgICogQG1ldGhvZCBlbmFibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG5hbWUgZW5hYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7UHVzaFNldHRpbmdzfSBwdXNoU2V0dGluZ3MgQW4gb2JqZWN0IHNwZWNpZnlpbmcgdmFyaW91cyBzZXR0aW5ncyBmb3IgdGhlIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucy4gVGhpcyBtZXRob2QgcmVxdWVzdHMgYSBwdXNoIHRva2VuIGZyb20gdGhlIGRldmljZSB2ZW5kb3IgYW5kIGVuYWJsZXMgdGhlIHB1c2ggbm90aWZpY2F0aW9uIGZ1bmN0aW9uYWxpdHkgb24gdGhlIGRldmljZS4gT25jZSB0aGlzIGlzIGRvbmUsIHlvdSBjYW4gcmVnaXN0ZXIgdGhlIGRldmljZSBpbiBFdmVybGl2ZSB1c2luZyB0aGUgcmVnaXN0ZXIoKSBtZXRob2QuXHJcbiAgICAgICAgICogQG1ldGhvZCBlbmFibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG5hbWUgZW5hYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7UHVzaFNldHRpbmdzfSBwdXNoU2V0dGluZ3MgQW4gb2JqZWN0IHNwZWNpZnlpbmcgdmFyaW91cyBzZXR0aW5ncyBmb3IgdGhlIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbmFibGVOb3RpZmljYXRpb25zOiBmdW5jdGlvbiAocHVzaFNldHRpbmdzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncyA9IHRoaXMuX2NsZWFuUGxhdGZvcm1zUHVzaFNldHRpbmdzKHB1c2hTZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKF8uYmluZCh0aGlzLl9pbml0aWFsaXplLCB0aGlzKSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uXHJcbiAgICAgICAgICogQG1ldGhvZCBkaXNhYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBuYW1lIGRpc2FibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uXHJcbiAgICAgICAgICogQG1ldGhvZCBkaXNhYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBuYW1lIGRpc2FibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpc2FibGVOb3RpZmljYXRpb25zOiBmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVucmVnaXN0ZXIoKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjaygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhdGZvcm1UeXBlID0gc2VsZi5fZ2V0UGxhdGZvcm1UeXBlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtLkFuZHJvaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG5zUHVzaFBsdWdpbi51bnJlZ2lzdGVyKHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3IsIHNlbGYucHVzaFNldHRpbmdzLmFuZHJvaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRuc1B1c2hQbHVnaW4udW5yZWdpc3RlcihzdWNjZXNzQ2FsbGJhY2ssIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNiXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvckNiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcHVzaCByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIGdldFJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwdXNoIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UmVnaXN0cmF0aW9uOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGRldmljZUlkID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuX2dldERldmljZUlkKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEhhbmRsZXIuZGV2aWNlcy5nZXRCeUlkKCdIYXJkd2FyZUlkLycgKyBkZXZpY2VJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG9ubHkgYWZ0ZXIgW2VuYWJsZU5vdGlmaWNhdGlvbnMoKV17QGxpbmsgY3VycmVudERldmljZS5lbmFibGVOb3RpZmljYXRpb25zfSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VzdG9tUGFyYW1ldGVycyBDdXN0b20gcGFyYW1ldGVycyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0ZXJzIHRoZSBjdXJyZW50IGRldmljZSBmb3IgcHVzaCBub3RpZmljYXRpb25zIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgb25seSBhZnRlciBbZW5hYmxlTm90aWZpY2F0aW9ucygpXXtAbGluayBjdXJyZW50RGV2aWNlLmVuYWJsZU5vdGlmaWNhdGlvbnN9IGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAbmFtZSByZWdpc3RlclxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24gKGN1c3RvbVBhcmFtZXRlcnMsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgaWYgKGN1c3RvbVBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlBhcmFtZXRlcnMgPSBjdXN0b21QYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9wdWxhdGVSZWdpc3RyYXRpb25PYmplY3QoZGV2aWNlUmVnaXN0cmF0aW9uKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wdXNoSGFuZGxlci5kZXZpY2VzLmNyZWF0ZShkZXZpY2VSZWdpc3RyYXRpb24sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVucmVnaXN0ZXJzIHRoZSBjdXJyZW50IGRldmljZSBmcm9tIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBBZnRlciB0aGlzIGNhbGwgY29tcGxldGVzIHN1Y2Nlc3NmdWxseSwge3tzaXRlLmJzfX0gd2lsbCBubyBsb25nZXIgc2VuZCBub3RpZmljYXRpb25zIHRvIHRoaXMgZGV2aWNlLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBwcmV2ZW50IHRoZSBkZXZpY2UgZnJvbSByZWNlaXZpbmcgbm90aWZpY2F0aW9ucyBhbmQgZG9lcyBub3QgaW52YWxpZGF0ZSBwdXNoIHRva2Vucy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAbmFtZSB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVucmVnaXN0ZXJzIHRoZSBjdXJyZW50IGRldmljZSBmcm9tIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBBZnRlciB0aGlzIGNhbGwgY29tcGxldGVzIHN1Y2Nlc3NmdWxseSwge3tzaXRlLmJzfX0gd2lsbCBubyBsb25nZXIgc2VuZCBub3RpZmljYXRpb25zIHRvIHRoaXMgZGV2aWNlLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBwcmV2ZW50IHRoZSBkZXZpY2UgZnJvbSByZWNlaXZpbmcgbm90aWZpY2F0aW9ucyBhbmQgZG9lcyBub3QgaW52YWxpZGF0ZSBwdXNoIHRva2Vucy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAbmFtZSB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgZGV2aWNlSWQgPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy5fZ2V0RGV2aWNlSWQoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoSGFuZGxlci5kZXZpY2VzLmRlc3Ryb3lTaW5nbGUoe0lkOiAnSGFyZHdhcmVJZC8nICsgZGV2aWNlSWR9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcmVnaXN0cmF0aW9uIG9mIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB1bmRlZmluZWQsIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB1bmRlZmluZWQsIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGVSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChjdXN0b21QYXJhbWV0ZXJzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uID0ge307XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21QYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5QYXJhbWV0ZXJzID0gY3VzdG9tUGFyYW1ldGVycztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVsYXRlUmVnaXN0cmF0aW9uT2JqZWN0KGRldmljZVJlZ2lzdHJhdGlvbikudGhlbihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uSWQgPSAnSGFyZHdhcmVJZC8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZVJlZ2lzdHJhdGlvbi5IYXJkd2FyZUlkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcHVzaEhhbmRsZXIuZGV2aWNlcy51cGRhdGVTaW5nbGUoZGV2aWNlUmVnaXN0cmF0aW9uLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBwcm92aWRlcyBhIGRpZmZlcmVudCBvcGVyYXRpb24gb24gZWFjaCBzdXBwb3J0ZWQgcGxhdGZvcm06XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAtIE9uIGlPUzogQ2hlY2tzIGlmIE5vdGlmaWNhdGlvbnMgaXMgZW5hYmxlZCBmb3IgdGhpcyBhcHBsaWNhdGlvbiBpbiB0aGUgZGV2aWNlJ3MgTm90aWZpY2F0aW9uIENlbnRlci5cclxuICAgICAgICAgKiAtIE9uIFdpbmRvd3MgUGhvbmU6IENoZWNrcyBpZiB0aGUgYXBwbGljYXRpb24gaGFzIGFuIGFjdGl2ZSBvcGVuIGNoYW5uZWwgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgTWljcm9zb2Z0IFB1c2ggTm90aWZpY2F0aW9uIFNlcnZpY2UuIFRoZSBvdXRjb21lIGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgZGV2aWNlJ3Mgbm90aWZpY2F0aW9uIHNldHRpbmdzLlxyXG4gICAgICAgICAqIC0gT24gQW5kcm9pZDogQ2hlY2tzIGlmIHRoZSBhcHBsaWNhdGlvbiBoYXMgZXN0YWJsaXNoZWQgYSBjb25uZWN0aW9uIHdpdGggR29vZ2xlIENsb3VkIE1lc3NhZ2luZy4gVGhlIG91dGNvbWUgZG9lcyBub3QgZGVwZW5kIG9uIHRoZSBkZXZpY2UncyBub3RpZmljYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgICAgICogQG1ldGhvZCBhcmVOb3RpZmljYXRpb25zRW5hYmxlZFxyXG4gICAgICAgICAqIEBuYW1lIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IHBhc3NlZCB0byB0aGUgUHVzaCBOb3RpZmljYXRpb24gcGx1Z2luJ3MgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWQgbWV0aG9kXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBpT1M6IENoZWNrcyBpZiB0aGUgTm90aWZpY2F0aW9ucyBhcmUgZW5hYmxlZCBmb3IgdGhpcyBBcHBsaWNhdGlvbiBpbiB0aGUgRGV2aWNlJ3MgTm90aWZpY2F0aW9uIENlbnRlci5cclxuICAgICAgICAgKiBXaW5kb3dzIFBob25lOiBDaGVja3MgaWYgdGhlIEFwcGxpY2F0aW9uIGhhcyBhbiBhY3RpdmUgb3BlbmVkIENoYW5uZWwgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgTm90aWZpY2F0aW9uIFNlcnZpY2UuIE5vdCByZWx5aW5nIG9uIHRoZSBkZXZpY2Ugbm90aWZpY2F0aW9uIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEFuZHJvaWQ6IENoZWNrcyBpZiB0aGUgQXBwbGljYXRpb24gaGFzIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24gd2l0aCB0aGUgTm90aWZpY2F0aW9uIFNlcnZpY2UuIE5vdCByZWx5aW5nIG9uIHRoZSBkZXZpY2Ugbm90aWZpY2F0aW9uIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEBtZXRob2QgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcclxuICAgICAgICAgKiBAbmFtZSBhcmVOb3RpZmljYXRpb25zRW5hYmxlZFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCBwYXNzZWQgdG8gdGhlIFB1c2ggTm90aWZpY2F0aW9uIHBsdWdpbidzIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkIG1ldGhvZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzc2Z1bCBjaGVjay4gUGFzc2VzIGEgc2luZ2xlIGJvb2xlYW4gdmFsdWU6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGVycm9yIGluIHRoZSBwdXNoIHBsdWdpbiBoYXMgb2NjdXJyZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWQ6IGZ1bmN0aW9uIChvcHRpb25zLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcclxuICAgICAgICAgICAgICAgIHRuc1B1c2hQbHVnaW4uYXJlTm90aWZpY2F0aW9uc0VuYWJsZWQoc3VjY2Vzc0NiLCBlcnJvckNiLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfSwgb25TdWNjZXNzLCBvbkVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfaW5pdGlhbGl6ZUludGVyYWN0aXZlUHVzaDogZnVuY3Rpb24gKGlPU1NldHRpbmdzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0bnNQdXNoUGx1Z2luLnJlZ2lzdGVyVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgd2hpY2ggd2lsbCBpbW1lZGlhdGVseSByZXR1cm4gKEFQTnMgaXMgbm90IGNvbnRhY3RlZCBmb3IgdGhpcylcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgaW4gY2FzZSB0aGUgY29uZmlndXJhdGlvbiBpcyBpbmNvcnJlY3RcclxuICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9Jbml0aWFsaXplcyB0aGUgcHVzaCBmdW5jdGlvbmFsaXR5IG9uIHRoZSBkZXZpY2UuXHJcbiAgICAgICAgX2luaXRpYWxpemU6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemluZykge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IobmV3IEV2ZXJsaXZlRXJyb3IoJ1B1c2ggbm90aWZpY2F0aW9ucyBhcmUgY3VycmVudGx5IGluaXRpYWxpemluZy4nKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2sgPSBzdWNjZXNzO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0RXJyb3JDYWxsYmFjayA9IGVycm9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2Vzcyh0aGlzLnB1c2hUb2tlbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHRoaXMuX2dsb2JhbEZ1bmN0aW9uU3VmZml4O1xyXG4gICAgICAgICAgICBpZiAoIXN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgc3VmZml4ID0gRGF0ZS5ub3coKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsRnVuY3Rpb25TdWZmaXggPSBzdWZmaXg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwbGF0Zm9ybVR5cGUgPSB0aGlzLl9nZXRQbGF0Zm9ybVR5cGUoKTtcclxuICAgICAgICAgICAgaWYgKHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uaU9TKSB7XHJcbiAgICAgICAgICAgICAgICAvL0NvbnN0cnVjdCByZWdpc3RyYXRpb24gb3B0aW9ucyBvYmplY3QgYW5kIHZhbGlkYXRlIGlPUyBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwblJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB0aGlzLnB1c2hTZXR0aW5ncy5pT1M7XHJcblxyXG4gICAgICAgICAgICAgICAgYXBuUmVnaXN0cmF0aW9uT3B0aW9ucy5ub3RpZmljYXRpb25DYWxsYmFja0lPUyA9IHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrSU9TO1xyXG4gICAgICAgICAgICAgICAgLy9SZWdpc3RlciBmb3IgQVBOXHJcbiAgICAgICAgICAgICAgICB0bnNQdXNoUGx1Z2luLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIGFwblJlZ2lzdHJhdGlvbk9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMuX3N1Y2Nlc3NmdWxSZWdpc3RyYXRpb25BUE4sIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9mYWlsZWRSZWdpc3RyYXRpb25BUE4sIHRoaXMpICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybS5BbmRyb2lkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudCBpbiB0aGUgQW5kcm9pZCBTZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgdmFyIGdjbVJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB0aGlzLnB1c2hTZXR0aW5ncy5hbmRyb2lkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVBbmRyb2lkU2V0dGluZ3MoZ2NtUmVnaXN0cmF0aW9uT3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2NtUmVnaXN0cmF0aW9uT3B0aW9ucy5ub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQgPSB0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZWdpc3RlciBmb3IgR0NNXHJcbiAgICAgICAgICAgICAgICB0bnNQdXNoUGx1Z2luLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIGdjbVJlZ2lzdHJhdGlvbk9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMuX3N1Y2Nlc3NTZW50UmVnaXN0cmF0aW9uR0NNLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fZXJyb3JTZW50UmVnaXN0cmF0aW9uR0NNLCB0aGlzKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgY3VycmVudCBwbGF0Zm9ybSBpcyBub3Qgc3VwcG9ydGVkOiAnICsgdG5zUGxhdGZvcm0uZGV2aWNlLm9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF92YWxpZGF0ZUFuZHJvaWRTZXR0aW5nczogZnVuY3Rpb24gKGFuZHJvaWRTZXR0aW5ncykge1xyXG4gICAgICAgICAgICBpZiAoIWFuZHJvaWRTZXR0aW5ncy5zZW5kZXJJRCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1NlbmRlciBJRCAocHJvamVjdCBudW1iZXIpIGlzIG5vdCBzZXQgaW4gdGhlIGFuZHJvaWQgc2V0dGluZ3MuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9jbGVhblBsYXRmb3Jtc1B1c2hTZXR0aW5nczogZnVuY3Rpb24gKHB1c2hTZXR0aW5ncykge1xyXG4gICAgICAgICAgICB2YXIgY2xlYW5TZXR0aW5ncyA9IHt9O1xyXG4gICAgICAgICAgICBwdXNoU2V0dGluZ3MgPSBwdXNoU2V0dGluZ3MgfHwge307XHJcblxyXG4gICAgICAgICAgICB2YXIgYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybSA9IGZ1bmN0aW9uIGFkZFNldHRpbmdzRm9yUGxhdGZvcm0obmV3U2V0dGluZ3NPYmplY3QsIHBsYXRmb3JtLCBhbGxvd2VkRmllbGRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXB1c2hTZXR0aW5nc1twbGF0Zm9ybV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3U2V0dGluZ3NPYmplY3RbcGxhdGZvcm1dID0gbmV3U2V0dGluZ3NPYmplY3RbcGxhdGZvcm1dIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1BsYXRmb3JtU2V0dGluZ3MgPSBwdXNoU2V0dGluZ3NbcGxhdGZvcm1dO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gbmV3U2V0dGluZ3NPYmplY3RbcGxhdGZvcm1dO1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKGFsbG93ZWRGaWVsZHMsIGZ1bmN0aW9uIChhbGxvd2VkRmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3UGxhdGZvcm1TZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShhbGxvd2VkRmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW2FsbG93ZWRGaWVsZF0gPSBuZXdQbGF0Zm9ybVNldHRpbmdzW2FsbG93ZWRGaWVsZF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtKGNsZWFuU2V0dGluZ3MsICdpT1MnLCBbJ2JhZGdlJywgJ3NvdW5kJywgJ2FsZXJ0JywgJ2ludGVyYWN0aXZlU2V0dGluZ3MnXSk7XHJcbiAgICAgICAgICAgIGFkZFNldHRpbmdzRm9yUGxhdGZvcm0oY2xlYW5TZXR0aW5ncywgJ2FuZHJvaWQnLCBbJ3NlbmRlcklEJywgJ3Byb2plY3ROdW1iZXInXSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tGaWVsZHMgPSBbJ25vdGlmaWNhdGlvbkNhbGxiYWNrQW5kcm9pZCcsICdub3RpZmljYXRpb25DYWxsYmFja0lPUyddO1xyXG4gICAgICAgICAgICBfLmVhY2goY2FsbGJhY2tGaWVsZHMsIGZ1bmN0aW9uIChjYWxsYmFja0ZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBwdXNoU2V0dGluZ3NbY2FsbGJhY2tGaWVsZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgXCInICsgY2FsbGJhY2tGaWVsZCArICdcIiBvZiB0aGUgcHVzaCBzZXR0aW5ncyBzaG91bGQgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5TZXR0aW5nc1tjYWxsYmFja0ZpZWxkXSA9IHB1c2hTZXR0aW5nc1tjYWxsYmFja0ZpZWxkXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHVzaFNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFuU2V0dGluZ3MuY3VzdG9tUGFyYW1ldGVycyA9IHB1c2hTZXR0aW5ncy5jdXN0b21QYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xlYW5TZXR0aW5ncztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcG9wdWxhdGVSZWdpc3RyYXRpb25PYmplY3Q6IGZ1bmN0aW9uIChkZXZpY2VSZWdpc3RyYXRpb24sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYucHVzaFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdQdXNoIHRva2VuIGlzIG5vdCBhdmFpbGFibGUuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9nZXRMb2NhbGVOYW1lKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGV2aWNlSWQgPSBzZWxmLl9nZXREZXZpY2VJZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhcmR3YXJlTW9kZWwgPSB0bnNQbGF0Zm9ybS5kZXZpY2UubW9kZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhdGZvcm1UeXBlID0gc2VsZi5fZ2V0UGxhdGZvcm1UeXBlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVpvbmUgPSBqc3R6LmRldGVybWluZSgpLm5hbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXNoVG9rZW4gPSBzZWxmLnB1c2hUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5ndWFnZSA9ICdlbl9VUyc7IC8vVE9ET1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYXRmb3JtVmVyc2lvbiA9IHRuc1BsYXRmb3JtLmRldmljZS5vc1ZlcnNpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLkhhcmR3YXJlSWQgPSBkZXZpY2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5IYXJkd2FyZU1vZGVsID0gaGFyZHdhcmVNb2RlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5QbGF0Zm9ybVR5cGUgPSBwbGF0Zm9ybVR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUGxhdGZvcm1WZXJzaW9uID0gcGxhdGZvcm1WZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlRpbWVab25lID0gdGltZVpvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUHVzaFRva2VuID0gcHVzaFRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLkxvY2FsZSA9IGxhbmd1YWdlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRMb2NhbGVOYW1lOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3MoKTsgLy8gVE9ETyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvKiBUT0RPOiBNdXN0IHRyYW5zbGF0ZSBzb21laG93IHRvIE5hdGl2ZVNjcmlwdCB0byBnZXQgdGhlIGN1cnJlbnQgbG9jYWxlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVtdWxhdG9yTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcyh7dmFsdWU6ICdlbl9VUyd9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldExvY2FsZU5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGxvY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldExvY2FsZU5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0qL1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXREZXZpY2VJZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG5zUGxhdGZvcm0uZGV2aWNlLnV1aWQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9SZXR1cm5zIHRoZSBFdmVybGl2ZSBkZXZpY2UgcGxhdGZvcm0gY29uc3RhbnQgZ2l2ZW4gYSB2YWx1ZSBhcXVpcmVkIGZyb20gY29yZG92YSdzIGRldmljZS5wbGF0Zm9ybS5cclxuICAgICAgICBfZ2V0UGxhdGZvcm1UeXBlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwc0xvd2VyID0gdG5zUGxhdGZvcm0uZGV2aWNlLm9zLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocHNMb3dlcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaW9zJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2lwaG9uZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpcGFkJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uaU9TO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYW5kcm9pZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLkFuZHJvaWQ7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbGF0Zm9ybS5Vbmtub3duO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZDogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaFRva2VuID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbml0RXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdEVycm9yQ2FsbGJhY2soe2Vycm9yOiBlcnJvcn0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3M6IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hUb2tlbiA9IHRva2VuO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5pdFN1Y2Nlc3NDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3NDYWxsYmFjayh7dG9rZW46IHRva2VufSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL09jY3VycyB3aGVuIHRoZSBkZXZpY2UgcmVnaXN0cmF0aW9uIGluIEFQTiBzdWNjZWVkc1xyXG4gICAgICAgIF9zdWNjZXNzZnVsUmVnaXN0cmF0aW9uQVBOOiBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3MuaU9TICYmIHRoaXMucHVzaFNldHRpbmdzLmlPUy5pbnRlcmFjdGl2ZVNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW50ZXJhY3RpdmVQdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLmlPUyxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3ModG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIGludGVyYWN0aXZlIHB1c2ggY29uZmlndXJhdGlvbiBpcyBpbmNvcnJlY3Q6ICcgKyBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKHRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vT2NjdXJzIGlmIHRoZSBkZXZpY2UgcmVnaXN0cmF0aW9uIGluIEFQTiBmYWlsc1xyXG4gICAgICAgIF9mYWlsZWRSZWdpc3RyYXRpb25BUE46IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQoZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gZGV2aWNlIHJlZ2lzdHJhdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2VudCB0byBHQ01cclxuICAgICAgICBfc3VjY2Vzc1NlbnRSZWdpc3RyYXRpb25HQ006IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IHNlbnQgcmVxdWVzdCBmb3IgcmVnaXN0ZXJpbmcgd2l0aCBHQ00uXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gc2V0IG9uIG1lc3NhZ2UgcmVjZWl2ZWQuXHJcbiAgICAgICAgICAgIHRuc1B1c2hQbHVnaW4ub25NZXNzYWdlUmVjZWl2ZWQodGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3ModG9rZW4pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gYW4gZXJyb3Igb2NjdXJlZCB3aGVuIHNlbmRpbmcgcmVnaXN0cmF0aW9uIHJlcXVlc3QgdG8gR0NNXHJcbiAgICAgICAgX2Vycm9yU2VudFJlZ2lzdHJhdGlvbkdDTTogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGFsbCBub3RpZmljYXRpb24gZXZlbnRzIGZyb20gQVBOXHJcbiAgICAgICAgX29uTm90aWZpY2F0aW9uQVBOOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50SU9TKGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vVGhpcyBmdW5jdGlvbiByZWNlaXZlcyBhbGwgbm90aWZpY2F0aW9uIGV2ZW50cyBmcm9tIEdDTVxyXG4gICAgICAgIF9vbk5vdGlmaWNhdGlvbkdDTTogZnVuY3Rpb24gb25Ob3RpZmljYXRpb25HQ00oZSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGUuZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlZ2lzdGVyZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJlZ2lkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2VzcyhlLnJlZ2lkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50QW5kcm9pZChlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHVzaFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50QW5kcm9pZChlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50SU9TOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tJT1MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrSU9TKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQ3VycmVudERldmljZTtcclxufSgpKTtcclxuIiwidmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L1F1ZXJ5Jyk7XHJcbnZhciBIZWFkZXJzID0gY29uc3RhbnRzLkhlYWRlcnM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBUT0RPOiBbb2ZmbGluZV0gVXBkYXRlIHRoZSBzdHJ1Y3R1cmUgLSBmaWx0ZXIgZmllbGQgY2FuIGJlIHJlZmFjdG9yZWQgZm9yIGV4YW1wbGUgYW5kIGEgc2tpcC9saW1pdC9zb3J0IHByb3BlcnR5IGNhbiBiZSBhZGRlZFxyXG4gICAgdmFyIERhdGFRdWVyeSA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29uZmlnLmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gY29uZmlnLmZpbHRlcjtcclxuICAgICAgICB0aGlzLm9uU3VjY2VzcyA9IGNvbmZpZy5vblN1Y2Nlc3M7XHJcbiAgICAgICAgdGhpcy5vbkVycm9yID0gY29uZmlnLm9uRXJyb3I7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBjb25maWcub3BlcmF0aW9uO1xyXG4gICAgICAgIHRoaXMucGFyc2UgPSBjb25maWcucGFyc2U7XHJcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsT3B0aW9ucyA9IGNvbmZpZy5hZGRpdGlvbmFsT3B0aW9ucztcclxuICAgICAgICB0aGlzLmRhdGEgPSBjb25maWcuZGF0YTtcclxuICAgICAgICB0aGlzLnVzZU9mZmxpbmUgPSBjb25maWcudXNlT2ZmbGluZTtcclxuICAgICAgICB0aGlzLmFwcGx5T2ZmbGluZSA9IGNvbmZpZy5hcHBseU9mZmxpbmU7XHJcbiAgICAgICAgdGhpcy5ub1JldHJ5ID0gY29uZmlnLm5vUmV0cnk7IC8vcmV0cnkgd2lsbCBiZSBkb25lIGJ5IGRlZmF1bHQsIHdoZW4gYSByZXF1ZXN0IGZhaWxzIGJlY2F1c2Ugb2YgZXhwaXJlZCB0b2tlbiwgb25jZSB0aGUgYXV0aGVudGljYXRpb24uY29tcGxldGVBdXRoZW50aWNhdGlvbiBpbiBzZGsgaXMgY2FsbGVkLlxyXG4gICAgICAgIHRoaXMuc2tpcEF1dGggPSBjb25maWcuc2tpcEF1dGg7IC8vaWYgc2V0IHRvIHRydWUsIHRoZSBzZGsgd2lsbCBub3QgcmVxdWlyZSBhdXRob3JpemF0aW9uIGlmIHRoZSBkYXRhIHF1ZXJ5IGZhaWxzIGJlY2F1c2Ugb2YgZXhwaXJlZCB0b2tlbi4gVXNlZCBpbnRlcm5hbGx5IGZvciB2YXJpb3VzIGxvZ2luIG1ldGhvZHMuXHJcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZEhlYWRlcnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXNTeW5jID0gY29uZmlnLmlzU3luYztcclxuICAgIH07XHJcblxyXG4gICAgRGF0YVF1ZXJ5LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBfbm9ybWFsaXplSGVhZGVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXJLZXlzID0gT2JqZWN0LmtleXModGhpcy5oZWFkZXJzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZWRIZWFkZXJzID0ge307XHJcbiAgICAgICAgICAgIF8uZWFjaChoZWFkZXJLZXlzLCBmdW5jdGlvbiAoaGVhZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZEtleSA9IGhlYWRlcktleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fbm9ybWFsaXplZEhlYWRlcnNbbm9ybWFsaXplZEtleV0gPSBzZWxmLmhlYWRlcnNbaGVhZGVyS2V5XTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0SGVhZGVyOiBmdW5jdGlvbiAoaGVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbm9ybWFsaXplZEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZUhlYWRlcnMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRIZWFkZXIgPSBoZWFkZXIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRIZWFkZXJzW25vcm1hbGl6ZWRIZWFkZXJdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldEhlYWRlckFzSlNPTjogZnVuY3Rpb24gKGhlYWRlcikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX25vcm1hbGl6ZWRIZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVIZWFkZXJzKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBoZWFkZXJWYWx1ZSA9IHRoaXMuX25vcm1hbGl6ZWRIZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXTtcclxuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QoaGVhZGVyVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoaGVhZGVyVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGhlYWRlclZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRRdWVyeVBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5UGFyYW1zID0ge307XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcGVyYXRpb24gPT09IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWRCeUlkKSB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5maWx0ZXIgPSB0aGlzLmFkZGl0aW9uYWxPcHRpb25zLmlkO1xyXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuZXhwYW5kID0gdGhpcy5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5leHBhbmQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvcnQgPSB0aGlzLmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnNvcnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gdGhpcy5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy50YWtlKTtcclxuICAgICAgICAgICAgICAgIHZhciBza2lwID0gdGhpcy5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5za2lwKTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3QgPSB0aGlzLmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnNlbGVjdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5maWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZCA9IHRoaXMuZ2V0SGVhZGVyQXNKU09OKEhlYWRlcnMuZXhwYW5kKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIgaW5zdGFuY2VvZiBRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJPYmogPSB0aGlzLmZpbHRlci5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmZpbHRlciA9IGZpbHRlck9iai4kd2hlcmUgfHwgZmlsdGVyIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNvcnQgPSBmaWx0ZXJPYmouJHNvcnQgfHwgc29ydDtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5saW1pdCA9IGZpbHRlck9iai4kdGFrZSB8fCBsaW1pdDtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5za2lwID0gZmlsdGVyT2JqLiRza2lwIHx8IHNraXA7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2VsZWN0ID0gZmlsdGVyT2JqLiRzZWxlY3QgfHwgc2VsZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmV4cGFuZCA9IGZpbHRlck9iai4kZXhwYW5kIHx8IGV4cGFuZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuZmlsdGVyID0gKHRoaXMuZmlsdGVyIHx8IGZpbHRlcikgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuc29ydCA9IHNvcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMubGltaXQgPSBsaW1pdDtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5za2lwID0gc2tpcDtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5zZWxlY3QgPSBzZWxlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuZXhwYW5kID0gZXhwYW5kO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcXVlcnlQYXJhbXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBEYXRhUXVlcnkub3BlcmF0aW9ucyA9IHtcclxuICAgICAgICByZWFkOiAncmVhZCcsXHJcbiAgICAgICAgY3JlYXRlOiAnY3JlYXRlJyxcclxuICAgICAgICB1cGRhdGU6ICd1cGRhdGUnLFxyXG4gICAgICAgIHJlbW92ZTogJ2Rlc3Ryb3knLFxyXG4gICAgICAgIHJlbW92ZVNpbmdsZTogJ2Rlc3Ryb3lTaW5nbGUnLFxyXG4gICAgICAgIHJlYWRCeUlkOiAncmVhZEJ5SWQnLFxyXG4gICAgICAgIGNvdW50OiAnY291bnQnLFxyXG4gICAgICAgIHJhd1VwZGF0ZTogJ3Jhd1VwZGF0ZScsXHJcbiAgICAgICAgc2V0QWNsOiAnc2V0QWNsJyxcclxuICAgICAgICBzZXRPd25lcjogJ3NldE93bmVyJyxcclxuICAgICAgICB1c2VyTG9naW46ICdsb2dpbicsXHJcbiAgICAgICAgdXNlckxvZ291dDogJ2xvZ291dCcsXHJcbiAgICAgICAgdXNlckNoYW5nZVBhc3N3b3JkOiAnY2hhbmdlUGFzc3dvcmQnLFxyXG4gICAgICAgIHVzZXJMb2dpbldpdGhQcm92aWRlcjogJ2xvZ2luV2l0aCcsXHJcbiAgICAgICAgdXNlckxpbmtXaXRoUHJvdmlkZXI6ICdsaW5rV2l0aCcsXHJcbiAgICAgICAgdXNlclVubGlua0Zyb21Qcm92aWRlcjogJ3VubGlua0Zyb20nLFxyXG4gICAgICAgIHVzZXJSZXNldFBhc3N3b3JkOiAncmVzZXRQYXNzd29yZCcsXHJcbiAgICAgICAgdXNlclNldFBhc3N3b3JkOiAnc2V0UGFzc3dvcmQnLFxyXG4gICAgICAgIGZpbGVzVXBkYXRlQ29udGVudDogJ3VwZGF0ZUNvbnRlbnQnLFxyXG4gICAgICAgIGZpbGVzR2V0RG93bmxvYWRVcmxCeUlkOiAnZG93bmxvYWRVcmxCeUlkJ1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRGF0YVF1ZXJ5O1xyXG59KCkpOyIsInZhciBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi4vRXhwcmVzc2lvbicpO1xyXG52YXIgT3BlcmF0b3JUeXBlID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuT3BlcmF0b3JUeXBlO1xyXG52YXIgV2hlcmVRdWVyeSA9IHJlcXVpcmUoJy4vV2hlcmVRdWVyeScpO1xyXG52YXIgUXVlcnlCdWlsZGVyID0gcmVxdWlyZSgnLi9RdWVyeUJ1aWxkZXInKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIFF1ZXJ5XHJcbiAgICAgKiBAY2xhc3NkZXNjIEEgcXVlcnkgY2xhc3MgdXNlZCB0byBkZXNjcmliZSBhIHJlcXVlc3QgdGhhdCB3aWxsIGJlIG1hZGUgdG8gdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBBUEkuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2ZpbHRlcl0gQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtmaWVsZHNdIEEgW2ZpZWxkcyBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLVN1YnNldC1vZi1maWVsZHMgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3NvcnRdIEEgW3NvcnQgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1zb3J0aW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgaXRlbXMgdG8gc2tpcC4gVXNlZCBmb3IgcGFnaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0YWtlXSBOdW1iZXIgb2YgaXRlbXMgdG8gdGFrZS4gVXNlZCBmb3IgcGFnaW5nLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtleHBhbmRdIEFuIFtleHBhbmQgZXhwcmVzc2lvbl0oeyUgc2x1ZyBmZWF0dXJlcy1kYXRhLXJlbGF0aW9ucy1kZWZpbmluZy1leHBhbmQgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFF1ZXJ5KGZpbHRlciwgZmllbGRzLCBzb3J0LCBza2lwLCB0YWtlLCBleHBhbmQpIHtcclxuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcclxuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcclxuICAgICAgICB0aGlzLnNvcnQgPSBzb3J0O1xyXG4gICAgICAgIHRoaXMudG9za2lwID0gc2tpcDtcclxuICAgICAgICB0aGlzLnRvdGFrZSA9IHRha2U7XHJcbiAgICAgICAgdGhpcy5leHBhbmRFeHByZXNzaW9uID0gZXhwYW5kO1xyXG4gICAgICAgIHRoaXMuZXhwciA9IG5ldyBFeHByZXNzaW9uKE9wZXJhdG9yVHlwZS5xdWVyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgUXVlcnkucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8qKiBBcHBsaWVzIGEgZmlsdGVyIHRvIHRoZSBjdXJyZW50IHF1ZXJ5LiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgb25seSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgd2hlcmVcclxuICAgICAgICAgKiBAbmFtZSB3aGVyZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKiogRGVmaW5lcyBhIGZpbHRlciBkZWZpbml0aW9uIGZvciB0aGUgY3VycmVudCBxdWVyeS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB3aGVyZVxyXG4gICAgICAgICAqIEBuYW1lIHdoZXJlXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2hlcmU6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZmlsdGVyLCBbZmlsdGVyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBBcHBsaWVzIGEgZmllbGRzIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudCBxdWVyeS4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIG9ubHkgYSBzdWJzZXQgb2YgYWxsIGF2YWlsYWJsZSBpdGVtIGZpZWxkcy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZWxlY3RcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmllbGRzRXhwcmVzc2lvbiBBIFtmaWVsZHMgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1TdWJzZXQtb2YtZmllbGRzICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuc2VsZWN0LCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIC8vZXhjbHVkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmV4Y2x1ZGUsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgLy99LFxyXG4gICAgICAgIC8qKiBTb3J0cyB0aGUgaXRlbXMgaW4gdGhlIGN1cnJlbnQgcXVlcnkgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSBzcGVjaWZpZWQgZmllbGQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgb3JkZXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWUgdG8gb3JkZXIgYnkgaW4gYXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBvcmRlcjogZnVuY3Rpb24gKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm9yZGVyLCBbZmllbGRdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBTb3J0cyB0aGUgaXRlbXMgaW4gdGhlIGN1cnJlbnQgcXVlcnkgaW4gZGVzY2VuZGluZyBvcmRlciBieSB0aGUgc3BlY2lmaWVkIGZpZWxkLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIG9yZGVyRGVzY1xyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZSB0byBvcmRlciBieSBpbiBkZXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBvcmRlckRlc2M6IGZ1bmN0aW9uIChmaWVsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5vcmRlcl9kZXNjLCBbZmllbGRdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBTa2lwcyBhIGNlcnRhaW4gbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIGJlZ2lubmluZyBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN0IG9mIHRoZSBpdGVtcy4gVXNlZCBmb3IgcGFnaW5nLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNraXBcclxuICAgICAgICAgKiBAc2VlIFtxdWVyeS50YWtlXXtAbGluayBxdWVyeS50YWtlfVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHNraXAuXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNraXA6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5za2lwLCBbdmFsdWVdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBUYWtlcyBhIHNwZWNpZmllZCBudW1iZXIgb2YgaXRlbXMgZnJvbSB0aGUgcXVlcnkgcmVzdWx0LiBVc2VkIGZvciBwYWdpbmcuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdGFrZVxyXG4gICAgICAgICAqIEBzZWUgW3F1ZXJ5LnNraXBde0BsaW5rIHF1ZXJ5LnNraXB9XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gdGFrZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGFrZTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnRha2UsIFt2YWx1ZV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqIFNldHMgYW4gZXhwYW5kIGV4cHJlc3Npb24gZm9yIHRoZSBjdXJyZW50IHF1ZXJ5LiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgY29tcGxleCBkYXRhIHNldHMgdXNpbmcgYSBzaW5nbGUgcXVlcnkgYmFzZWQgb24gcmVsYXRpb25zIGJldHdlZW4gZGF0YSB0eXBlcy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBleHBhbmRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXhwYW5kRXhwcmVzc2lvbiBBbiBbZXhwYW5kIGV4cHJlc3Npb25dKHslIHNsdWcgZmVhdHVyZXMtZGF0YS1yZWxhdGlvbnMtZGVmaW5pbmctZXhwYW5kICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmV4cGFuZCwgW2V4cGFuZEV4cHJlc3Npb25dKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBCdWlsZHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRpZmZlcmVudCBleHByZXNzaW9ucyB0aGF0IHdpbGwgYmUgc2VudCB0byB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBJdCBiYXNpY2FsbHkgdHJhbnNsYXRlcyBhbnkgcHJldmlvdXNseSBzcGVjaWZpZWQgZXhwcmVzc2lvbnMgaW50byBzdGFuZGFyZCBxdWVyaWVzIHRoYXQge3tzaXRlLmJzfX0gY2FuIHVuZGVyc3RhbmQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgYnVpbGRcclxuICAgICAgICAgKiBAcmV0dXJucyB7eyR3aGVyZSwkc2VsZWN0LCRzb3J0LCRza2lwLCR0YWtlLCRleHBhbmR9fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnlCdWlsZGVyKHRoaXMpLmJ1aWxkKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2ltcGxlOiBmdW5jdGlvbiAob3AsIG9wcnMpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKG9wcnMpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cHIuYWRkT3BlcmFuZChuZXcgRXhwcmVzc2lvbihvcCwgYXJncykpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBRdWVyeTtcclxufSgpKTsiLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBPcGVyYXRvclR5cGUgPSBjb25zdGFudHMuT3BlcmF0b3JUeXBlO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XHJcbnZhciBHZW9Qb2ludCA9IHJlcXVpcmUoJy4uL0dlb1BvaW50Jyk7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi4vRXhwcmVzc2lvbicpO1xyXG52YXIgbWF4RGlzdGFuY2VDb25zdHMgPSBjb25zdGFudHMubWF4RGlzdGFuY2VDb25zdHM7XHJcbnZhciByYWRpdXNDb25zdHMgPSBjb25zdGFudHMucmFkaXVzQ29uc3RzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUXVlcnlCdWlsZGVyKHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgIHRoaXMuZXhwciA9IHF1ZXJ5LmV4cHI7XHJcbiAgICB9XHJcblxyXG4gICAgUXVlcnlCdWlsZGVyLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvLyBUT0RPIG1lcmdlIHRoZSB0d28gb2JqZWN0cyBiZWZvcmUgcmV0dXJuaW5nIHRoZW1cclxuICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xyXG4gICAgICAgICAgICBpZiAocXVlcnkuZmlsdGVyIHx8IHF1ZXJ5LmZpZWxkcyB8fCBxdWVyeS5zb3J0IHx8IHF1ZXJ5LnRvc2tpcCB8fCBxdWVyeS50b3Rha2UgfHwgcXVlcnkuZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAkd2hlcmU6IHF1ZXJ5LmZpbHRlciB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICRzZWxlY3Q6IHF1ZXJ5LmZpZWxkcyB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICRzb3J0OiBxdWVyeS5zb3J0IHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgJHNraXA6IHF1ZXJ5LnRvc2tpcCB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICR0YWtlOiBxdWVyeS50b3Rha2UgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAkZXhwYW5kOiBxdWVyeS5leHBhbmRFeHByZXNzaW9uIHx8IG51bGxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICR3aGVyZTogdGhpcy5fYnVpbGRXaGVyZSgpLFxyXG4gICAgICAgICAgICAgICAgJHNlbGVjdDogdGhpcy5fYnVpbGRTZWxlY3QoKSxcclxuICAgICAgICAgICAgICAgICRzb3J0OiB0aGlzLl9idWlsZFNvcnQoKSxcclxuICAgICAgICAgICAgICAgICRza2lwOiB0aGlzLl9nZXRTa2lwKCksXHJcbiAgICAgICAgICAgICAgICAkdGFrZTogdGhpcy5fZ2V0VGFrZSgpLFxyXG4gICAgICAgICAgICAgICAgJGV4cGFuZDogdGhpcy5fZ2V0RXhwYW5kKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRTa2lwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBza2lwRXhwcmVzc2lvbiA9IF8uZmluZCh0aGlzLmV4cHIub3BlcmFuZHMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLnNraXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc2tpcEV4cHJlc3Npb24gPyBza2lwRXhwcmVzc2lvbi5vcGVyYW5kc1swXSA6IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0VGFrZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGFrZUV4cHJlc3Npb24gPSBfLmZpbmQodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS50YWtlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRha2VFeHByZXNzaW9uID8gdGFrZUV4cHJlc3Npb24ub3BlcmFuZHNbMF0gOiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldEV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZXhwYW5kRXhwcmVzc2lvbiA9IF8uY2hhaW4odGhpcy5leHByLm9wZXJhbmRzKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5leHBhbmQ7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBleHByZXNzaW9uKSB7IC8vZXhwcmVzc2lvbiBjb250YWlucyBvcGVyYW5kcyBhbmQgaGFzIG9wZXJhdG9yIHR5cGUgZXhwYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHJlc3VsdCwgZXhwcmVzc2lvbi5vcGVyYW5kc1swXSk7XHJcbiAgICAgICAgICAgICAgICB9LCB7fSlcclxuICAgICAgICAgICAgICAgIC52YWx1ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5pc0VtcHR5KGV4cGFuZEV4cHJlc3Npb24pID8gbnVsbCA6IGV4cGFuZEV4cHJlc3Npb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYnVpbGRTZWxlY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdEV4cHJlc3Npb24gPSBfLmZpbmQodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5zZWxlY3Q7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBfLnJlZHVjZShzZWxlY3RFeHByZXNzaW9uLm9wZXJhbmRzLCBmdW5jdGlvbiAobWVtbywgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1vW3ZhbHVlXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYnVpbGRTb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3J0RXhwcmVzc2lvbnMgPSBfLmZpbHRlcih0aGlzLmV4cHIub3BlcmFuZHMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLm9yZGVyIHx8IHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUub3JkZXJfZGVzYztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHNvcnRFeHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBfLnJlZHVjZShzb3J0RXhwcmVzc2lvbnMsIGZ1bmN0aW9uIChtZW1vLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbW9bdmFsdWUub3BlcmFuZHNbMF1dID0gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5vcmRlciA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbztcclxuICAgICAgICAgICAgICAgIH0sIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9idWlsZFdoZXJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB3aGVyZUV4cHJlc3Npb24gPSBfLmZpbmQodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS53aGVyZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh3aGVyZUV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZChuZXcgRXhwcmVzc2lvbihPcGVyYXRvclR5cGUuYW5kLCB3aGVyZUV4cHJlc3Npb24ub3BlcmFuZHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLmZpbHRlcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbi5vcGVyYW5kc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYnVpbGQ6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NpbXBsZShleHByKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShleHByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1JlZ2V4KGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnZXgoZXhwcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNHZW8oZXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW8oZXhwcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNBbmQoZXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmQoZXhwcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNPcihleHByKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yKGV4cHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzTm90KGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm90KGV4cHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNTaW1wbGU6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID49IE9wZXJhdG9yVHlwZS5lcXVhbCAmJiBleHByLm9wZXJhdG9yIDw9IE9wZXJhdG9yVHlwZS5zaXplO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NpbXBsZTogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIHRlcm0gPSB7fSwgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMuX3RyYW5zbGF0ZW9wZXJhdG9yKGV4cHIub3BlcmF0b3IpO1xyXG4gICAgICAgICAgICBpZiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRlcm1bb3BlcmF0b3JdID0gb3BlcmFuZHNbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtID0gb3BlcmFuZHNbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmllbGRUZXJtW29wZXJhbmRzWzBdXSA9IHRlcm07XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFRlcm07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNSZWdleDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIub3BlcmF0b3IgPj0gT3BlcmF0b3JUeXBlLnJlZ2V4ICYmIGV4cHIub3BlcmF0b3IgPD0gT3BlcmF0b3JUeXBlLmVuZHNXaXRoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JlZ2V4OiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciByZWdleCA9IHRoaXMuX2dldFJlZ2V4KGV4cHIpO1xyXG4gICAgICAgICAgICB2YXIgcmVnZXhWYWx1ZSA9IHRoaXMuX2dldFJlZ2V4VmFsdWUocmVnZXgpO1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICBmaWVsZFRlcm1bb3BlcmFuZHNbMF1dID0gcmVnZXhWYWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRSZWdleDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBleHByLm9wZXJhbmRzWzFdO1xyXG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBleHByLm9wZXJhbmRzWzJdID8gZXhwci5vcGVyYW5kc1syXSA6ICcnO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIub3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLnJlZ2V4OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwID8gcGF0dGVybiA6IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuc3RhcnRzV2l0aDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHBhdHRlcm4sIGZsYWdzKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmVuZHNXaXRoOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4gKyBcIiRcIiwgZmxhZ3MpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVW5rbm93biBvcGVyYXRvciB0eXBlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0UmVnZXhWYWx1ZTogZnVuY3Rpb24gKHJlZ2V4KSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gJyc7XHJcbiAgICAgICAgICAgIGlmIChyZWdleC5nbG9iYWwpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgKz0gJ2cnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWdleC5tdWx0aWxpbmUpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgKz0gJ20nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWdleC5pZ25vcmVDYXNlKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zICs9ICdpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyRyZWdleDogcmVnZXguc291cmNlLCAkb3B0aW9uczogb3B0aW9uc307XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNHZW86IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID49IE9wZXJhdG9yVHlwZS5uZWFyU2hwZXJlICYmIGV4cHIub3BlcmF0b3IgPD0gT3BlcmF0b3JUeXBlLndpdGhpblNocGVyZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZW86IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZFRlcm0gPSB7fTtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgZmllbGRUZXJtW29wZXJhbmRzWzBdXSA9IHRoaXMuX2dldEdlb1Rlcm0oZXhwcik7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFRlcm07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0R2VvVGVybTogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChleHByLm9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5uZWFyU2hwZXJlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXROZWFyU3BoZXJlVGVybShleHByKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLndpdGhpbkJveDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2l0aGluQm94KGV4cHIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUud2l0aGluUG9seWdvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2l0aGluUG9seWdvbihleHByKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLndpdGhpblNocGVyZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2l0aGluQ2VudGVyU3BoZXJlKGV4cHIpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVW5rbm93biBvcGVyYXRvciB0eXBlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0TmVhclNwaGVyZVRlcm06IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9nZXRHZW9Qb2ludChvcGVyYW5kc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciBtYXhEaXN0YW5jZSA9IG9wZXJhbmRzWzJdO1xyXG4gICAgICAgICAgICB2YXIgbWV0cmljcyA9IG9wZXJhbmRzWzNdO1xyXG4gICAgICAgICAgICB2YXIgbWF4RGlzdGFuY2VDb25zdDtcclxuICAgICAgICAgICAgdmFyIHRlcm0gPSB7XHJcbiAgICAgICAgICAgICAgICAnJG5lYXJTcGhlcmUnOiBjZW50ZXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXhEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlQ29uc3QgPSBtYXhEaXN0YW5jZUNvbnN0c1ttZXRyaWNzXSB8fCBtYXhEaXN0YW5jZUNvbnN0cy5yYWRpYW5zO1xyXG4gICAgICAgICAgICAgICAgdGVybVttYXhEaXN0YW5jZUNvbnN0XSA9IG1heERpc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXJtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFdpdGhpbkJveDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgdmFyIGJvdHRvbUxlZnQgPSB0aGlzLl9nZXRHZW9Qb2ludChvcGVyYW5kc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciB1cHBlclJpZ2h0ID0gdGhpcy5fZ2V0R2VvUG9pbnQob3BlcmFuZHNbMl0pO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJyR3aXRoaW4nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJyRib3gnOiBbYm90dG9tTGVmdCwgdXBwZXJSaWdodF1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRXaXRoaW5Qb2x5Z29uOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fZ2V0R2VvUG9pbnRzKG9wZXJhbmRzWzFdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICckd2l0aGluJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICckcG9seWdvbic6IHBvaW50c1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFdpdGhpbkNlbnRlclNwaGVyZTogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2dldEdlb1BvaW50KG9wZXJhbmRzWzFdKTtcclxuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IG9wZXJhbmRzWzJdO1xyXG4gICAgICAgICAgICB2YXIgbWV0cmljcyA9IG9wZXJhbmRzWzNdO1xyXG4gICAgICAgICAgICB2YXIgcmFkaXVzQ29uc3QgPSByYWRpdXNDb25zdHNbbWV0cmljc10gfHwgcmFkaXVzQ29uc3RzLnJhZGlhbnM7XHJcbiAgICAgICAgICAgIHZhciBzcGhlcmVJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgJ2NlbnRlcic6IGNlbnRlclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzcGhlcmVJbmZvW3JhZGl1c0NvbnN0XSA9IHJhZGl1cztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICckd2l0aGluJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICckY2VudGVyU3BoZXJlJzogc3BoZXJlSW5mb1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldEdlb1BvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShwb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR2VvUG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0R2VvUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0R2VvUG9pbnQocG9pbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc0FuZDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5hbmQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYW5kOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbCwgdGVybSwgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBvcGVyYW5kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRlcm0gPSB0aGlzLl9idWlsZChvcGVyYW5kc1tpXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9hbmRBcHBlbmQocmVzdWx0LCB0ZXJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FuZEFwcGVuZDogZnVuY3Rpb24gKGFuZE9iaiwgbmV3T2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBsLCBrZXksIHZhbHVlLCBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBfLmtleXMobmV3T2JqKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhbmRPYmpba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5kT2JqW2tleV0gPSBuZXdPYmpba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3T2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF8uZXh0ZW5kKHZhbHVlLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYW5kT2JqW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYW5kT2JqO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzT3I6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUub3I7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfb3I6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBsLCB0ZXJtLCByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wZXJhbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IHRoaXMuX2J1aWxkKG9wZXJhbmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRlcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7JG9yOiByZXN1bHR9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzTm90OiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLm5vdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9ub3Q6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7JG5vdDogdGhpcy5fYnVpbGQoZXhwci5vcGVyYW5kc1swXSl9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3RyYW5zbGF0ZW9wZXJhdG9yOiBmdW5jdGlvbiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuZXF1YWw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5ub3RfZXF1YWw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckbmUnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuZ3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckZ3QnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckbHQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuZ3RlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGd0ZSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5sdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckbHRlJztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmlzaW46XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckaW4nO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubm90aW46XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckbmluJztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmFsbDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRhbGwnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuc2l6ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRzaXplJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVW5rbm93biBvcGVyYXRvciB0eXBlLicpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFF1ZXJ5QnVpbGRlcjtcclxufSgpKTsiLCJ2YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi9EYXRhUXVlcnknKTtcclxudmFyIFJlcXVlc3QgPSByZXF1aXJlKCcuLi9SZXF1ZXN0Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIgPSB7fTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwgPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgIGlmIChkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMgJiYgZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkKSB7XHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICcvJyArIGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbmRwb2ludDtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEJhc2VPYmplY3QgPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRPYmplY3QgPSB7XHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwoZGF0YVF1ZXJ5KSxcclxuICAgICAgICAgICAgZmlsdGVyOiBkYXRhUXVlcnkuZmlsdGVyLFxyXG4gICAgICAgICAgICBzdWNjZXNzOiBkYXRhUXVlcnkub25TdWNjZXNzLFxyXG4gICAgICAgICAgICBlcnJvcjogZGF0YVF1ZXJ5Lm9uRXJyb3IsXHJcbiAgICAgICAgICAgIGRhdGE6IGRhdGFRdWVyeS5kYXRhLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiBkYXRhUXVlcnkuaGVhZGVyc1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChkYXRhUXVlcnkucGFyc2UpIHtcclxuICAgICAgICAgICAgZGVmYXVsdE9iamVjdC5wYXJzZSA9IGRhdGFRdWVyeS5wYXJzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0T2JqZWN0O1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkID0gZnVuY3Rpb24gKGRhdGFRdWVyeSwgYWRkaXRpb25hbE9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gXy5leHRlbmQoUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEJhc2VPYmplY3QoZGF0YVF1ZXJ5KSwgYWRkaXRpb25hbE9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWRCeUlkXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY291bnRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lICsgJy9fY291bnQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGVdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmF3VXBkYXRlXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgZW5kcG9pbnQgPSBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGRhdGFRdWVyeS5maWx0ZXI7XHJcbiAgICAgICAgdmFyIG9maWx0ZXIgPSBudWxsOyAvLyByZXF1ZXN0IG9wdGlvbnMgZmlsdGVyXHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBlbmRwb2ludCArPSAnLycgKyBmaWx0ZXI7IC8vIHNlbmQgdGhlIGZpbHRlciB0aHJvdWdoIHF1ZXJ5IHN0cmluZ1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgb2ZpbHRlciA9IGZpbHRlcjsgLy8gc2VuZCB0aGUgZmlsdGVyIGFzIGZpbHRlciBoZWFkZXJzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxyXG4gICAgICAgICAgICBmaWx0ZXI6IG9maWx0ZXJcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZV0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZV0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRCYXNlT2JqZWN0KGRhdGFRdWVyeSksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlXSA9IFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVdO1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5zZXRBY2xdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBlbmRwb2ludCA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZGF0YVF1ZXJ5LmZpbHRlcjtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKSB7IC8vIGlmIGZpbHRlciBpcyBzdHJpbmcgdGhhbiB3aWxsIHVwZGF0ZSBhIHNpbmdsZSBpdGVtIHVzaW5nIHRoZSBmaWx0ZXIgYXMgYW4gaWRlbnRpZmllclxyXG4gICAgICAgICAgICBlbmRwb2ludCArPSAnLycgKyBmaWx0ZXI7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JykgeyAvLyBlbHNlIGlmIGl0IGlzIGFuIG9iamVjdCB0aGFuIHdlIHdpbGwgdXNlIGl0J3MgaWQgcHJvcGVydHlcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyW2lkRmllbGRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbmRwb2ludCArPSAnL19hY2wnO1xyXG4gICAgICAgIHZhciBtZXRob2QsIGRhdGE7XHJcbiAgICAgICAgaWYgKGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5hY2wgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgbWV0aG9kID0gJ0RFTEVURSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWV0aG9kID0gJ1BVVCc7XHJcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuYWNsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogZW5kcG9pbnQsXHJcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnNldE93bmVyXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgZW5kcG9pbnQgPSBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGRhdGFRdWVyeS5maWx0ZXI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKSB7IC8vIGlmIGZpbHRlciBpcyBzdHJpbmcgdGhhbiB3aWxsIHVwZGF0ZSBhIHNpbmdsZSBpdGVtIHVzaW5nIHRoZSBmaWx0ZXIgYXMgYW4gaWRlbnRpZmllclxyXG4gICAgICAgICAgICBlbmRwb2ludCArPSAnLycgKyBmaWx0ZXI7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JykgeyAvLyBlbHNlIGlmIGl0IGlzIGFuIG9iamVjdCB0aGFuIHdlIHdpbGwgdXNlIGl0J3MgaWQgcHJvcGVydHlcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyW2lkRmllbGRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbmRwb2ludCArPSAnL19vd25lcic7XHJcblxyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogZW5kcG9pbnRcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbl0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogJ29hdXRoL3Rva2VuJyxcclxuICAgICAgICAgICAgYXV0aEhlYWRlcnM6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ291dF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiAnb2F1dGgvbG9nb3V0J1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckNoYW5nZVBhc3N3b3JkXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIga2VlcFRva2VucyA9IGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5rZWVwVG9rZW5zO1xyXG4gICAgICAgIHZhciBlbmRwb2ludCA9ICdVc2Vycy9jaGFuZ2VwYXNzd29yZCc7XHJcbiAgICAgICAgaWYgKGtlZXBUb2tlbnMpIHtcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJz9rZWVwVG9rZW5zPXRydWUnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogZW5kcG9pbnQsXHJcbiAgICAgICAgICAgIGF1dGhIZWFkZXJzOiBmYWxzZSxcclxuICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbldpdGhQcm92aWRlcl0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBhdXRoSGVhZGVyczogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMaW5rV2l0aFByb3ZpZGVyXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwoZGF0YVF1ZXJ5KSArICcvbGluaydcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJVbmxpbmtGcm9tUHJvdmlkZXJdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRFbmRwb2ludFVybChkYXRhUXVlcnkpICsgJy91bmxpbmsnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyUmVzZXRQYXNzd29yZF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsKGRhdGFRdWVyeSkgKyAnL3Jlc2V0cGFzc3dvcmQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyU2V0UGFzc3dvcmRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRFbmRwb2ludFVybChkYXRhUXVlcnkpICsgJy9zZXRwYXNzd29yZCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLmZpbGVzVXBkYXRlQ29udGVudF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwoZGF0YVF1ZXJ5KSArICcvQ29udGVudCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLmZpbGVzR2V0RG93bmxvYWRVcmxCeUlkXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyO1xyXG59KCkpOyIsInZhciBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi4vRXhwcmVzc2lvbicpO1xyXG52YXIgT3BlcmF0b3JUeXBlID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuT3BlcmF0b3JUeXBlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NkZXNjIEEgZmx1ZW50IEFQSSBvcGVyYXRpb24gZm9yIGNyZWF0aW5nIGEgZmlsdGVyIGZvciBhIHF1ZXJ5IGJ5IGNoYWluaW5nIGRpZmZlcmVudCBydWxlcy5cclxuICAgICAqIEBjbGFzcyBXaGVyZVF1ZXJ5XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAYm9ycm93cyBXaGVyZVF1ZXJ5I2VxIGFzIFdoZXJlUXVlcnkjZXF1YWxcclxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjbmUgYXMgV2hlcmVRdWVyeSNub3RFcXVhbFxyXG4gICAgICogQGJvcnJvd3MgV2hlcmVRdWVyeSNndCBhcyBXaGVyZVF1ZXJ5I2dyZWF0ZXJUaGFuXHJcbiAgICAgKiBAYm9ycm93cyBXaGVyZVF1ZXJ5I2d0ZSBhcyBXaGVyZVF1ZXJ5I2dyZWF0ZXJUaGFuRXF1YWxcclxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjbHQgYXMgV2hlcmVRdWVyeSNsZXNzVGhhblxyXG4gICAgICogQGJvcnJvd3MgV2hlcmVRdWVyeSNsdGUgYXMgV2hlcmVRdWVyeSNsZXNzVGhhbkVxdWFsXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFdoZXJlUXVlcnkocGFyZW50UXVlcnksIGV4cHJPcCwgc2luZ2xlT3BlcmFuZCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50UXVlcnk7XHJcbiAgICAgICAgdGhpcy5zaW5nbGUgPSBzaW5nbGVPcGVyYW5kO1xyXG4gICAgICAgIHRoaXMuZXhwciA9IG5ldyBFeHByZXNzaW9uKGV4cHJPcCB8fCBPcGVyYXRvclR5cGUud2hlcmUpO1xyXG4gICAgICAgIHRoaXMucGFyZW50LmV4cHIuYWRkT3BlcmFuZCh0aGlzLmV4cHIpO1xyXG4gICAgfVxyXG5cclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gYGFuZGAgY2xhdXNlIHRvIHRoZSBjdXJyZW50IGNvbmRpdGlvbiBhbmQgcmV0dXJucyBpdCBmb3IgZnVydGhlciBjaGFpbmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIGFuZFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcywgT3BlcmF0b3JUeXBlLmFuZCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFuIGBvcmAgY2xhdXNlIHRvIHRoZSBjdXJyZW50IGNvbmRpdGlvbiBhbmQgcmV0dXJucyBpdCBmb3IgZnVydGhlciBjaGFpbmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIG9yXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXaGVyZVF1ZXJ5KHRoaXMsIE9wZXJhdG9yVHlwZS5vcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgYG5vdGAgY2xhdXNlIHRvIHRoZSBjdXJyZW50IGNvbmRpdGlvbiBhbmQgcmV0dXJucyBpdCBmb3IgZnVydGhlciBjaGFpbmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIG5vdFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5vdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcywgT3BlcmF0b3JUeXBlLm5vdCwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2ltcGxlOiBmdW5jdGlvbiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwci5hZGRPcGVyYW5kKG5ldyBFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmdzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb25lKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGJlIGVxdWFsIHRvIGEgc3BlY2lmaWMgdmFsdWUuXHJcbiAgICAgICAgICogQG1ldGhvZCBlcVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQ29tcGFyaXNvbiB2YWx1ZSAodG8gd2hpY2ggdGhlIGZpZWxkcyBtdXN0IGJlIGVxdWFsKS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBlcTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5lcXVhbCwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgKm5vdCogYmUgZXF1YWwgdG8gYSBzcGVjaWZpYyB2YWx1ZS5cclxuICAgICAgICAgKiBAbWV0aG9kIG5lXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0byB3aGljaCB0aGUgZmllbGQgbXVzdCBub3QgYmUgZXF1YWwpLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5lOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm5vdF9lcXVhbCwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGdyZWF0ZXIgdGhhbmAgYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBndFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQ29tcGFyaXNvbiB2YWx1ZSAodGhhdCB0aGUgZmllbGQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbikuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ3Q6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZ3QsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGJlIGBncmVhdGVyIHRoYW4gb3IgZXF1YWxgIHRvIGEgY2VydGFpbiB2YWx1ZS4gQXBwbGljYWJsZSB0byBOdW1iZXIsIFN0cmluZywgYW5kIERhdGUgZmllbGRzLlxyXG4gICAgICAgICAqIEBtZXRob2QgZ3RlXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0aGF0IHRoZSBmaWVsZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvKS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBndGU6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZ3RlLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBiZSBgbGVzcyB0aGFuYCBhIGNlcnRhaW4gdmFsdWUuIEFwcGxpY2FibGUgdG8gTnVtYmVyLCBTdHJpbmcsIGFuZCBEYXRlIGZpZWxkcy5cclxuICAgICAgICAgKiBAbWV0aG9kIGx0XHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0aGF0IHRoZSBmaWVsZCBzaG91bGQgYmUgbGVzcyB0aGFuKS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBsdDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5sdCwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGxlc3MgdGhhbiBvciBlcXVhbGAgdG8gYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBsdGVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8pLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx0ZTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5sdGUsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGJlIGluIGEgc2V0IG9mIHZhbHVlcy5cclxuICAgICAgICAgKiBAbWV0aG9kIGlzaW5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBBbiBhcnJheSBvZiB0aGUgdmFsdWVzIHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBpbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc2luOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmlzaW4sIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0ICpub3QqIGJlIGluIGEgc2V0IG9mIHZhbHVlcy5cclxuICAgICAgICAgKiBAbWV0aG9kIG5vdGluXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgQW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgdGhlIGZpZWxkIHNob3VsZCBub3QgYmUgaW4uXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbm90aW46IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUubm90aW4sIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGluY2x1ZGUgKmFsbCogb2YgdGhlIHNwZWNpZmllZCB2YWx1ZXMuIEFwcGxpY2FibGUgdG8gQXJyYXkgZmllbGRzLlxyXG4gICAgICAgICAqIEBtZXRob2QgYWxsXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgQW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgdGhlIGZpZWxkIG11c3QgaW5jbHVkZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBhbGw6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuYWxsLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBjb250YWluIGFuIGFycmF5IHdob3NlIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiBhIHNwZWNpZmllZCB2YWx1ZS4gQXBwbGljYWJsZSB0byBBcnJheSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBzaXplXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBzaXplIHRoYXQgdGhlIGFycmF5IG11c3QgYmUgYmlnZ2VyIHRoYW4uXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2l6ZTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5zaXplLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBzYXRpc2Z5IGEgc3BlY2lmaWVkIHJlZ2V4LlxyXG4gICAgICAgICAqIEBtZXRob2QgcmVnZXhcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVndWxhckV4cHJlc3Npb24gUmVndWxhciBleHByZXNzaW9uIGluIFBDUkUgZm9ybWF0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gQSBzdHJpbmcgb2YgcmVnZXggb3B0aW9ucyB0byB1c2UuIFNlZSBbc3BlY3NdKHtodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L3JlZ2V4LyNvcC5fU19vcHRpb25zfSkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYXZhaWxhYmxlIG9wdGlvbnMuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVnZXg6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIGZsYWdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnJlZ2V4LCBmaWVsZCwgdmFsdWUsIGZsYWdzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIHZhbHVlIG11c3QgKnN0YXJ0KiB3aXRoIGEgc3BlY2lmaWVkIHN0cmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIHN0YXJ0c1dpdGhcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0cmluZyB0aGF0IHRoZSBmaWVsZCBzaG91bGQgc3RhcnQgd2l0aC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnNdIEEgc3RyaW5nIG9mIHJlZ2V4IG9wdGlvbnMgdG8gdXNlLiBTZWUgW3NwZWNzXSh7aHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9yZWdleC8jb3AuX1Nfb3B0aW9uc30pIGZvciBhIGRlc2NyaXB0aW9uIG9mIGF2YWlsYWJsZSBvcHRpb25zLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIGZsYWdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnN0YXJ0c1dpdGgsIGZpZWxkLCB2YWx1ZSwgZmxhZ3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgdmFsdWUgbXVzdCAqZW5kKiB3aXRoIGEgc3BlY2lmaWVkIHN0cmluZy5cclxuICAgICAgICAgKiBAbWV0aG9kIGVuZHNXaXRoXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBzdHJpbmcgdGhhdCB0aGUgZmllbGQgc2hvdWxkIGVuZCB3aXRoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gQSBzdHJpbmcgb2YgIHJlZ2V4IG9wdGlvbnMgdG8gdXNlLiBTZWUgW3NwZWNzXSh7aHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9yZWdleC8jb3AuX1Nfb3B0aW9uc30pIGZvciBhIGRlc2NyaXB0aW9uIG9mIGF2YWlsYWJsZSBvcHRpb25zLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVuZHNXaXRoOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlLCBmbGFncykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5lbmRzV2l0aCwgZmllbGQsIHZhbHVlLCBmbGFncyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgR2Vvc3BhdGlhbCBjb25kaXRpb24gdGhhdCBhIHNwZWNpZmllZCBnZW9wb2ludCBtdXN0IGJlIHdpdGhpbiBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSBhbm90aGVyIGdlb3BvaW50LiBBcHBsaWNhYmxlIHRvIEdlb1BvaW50IGZpZWxkcyBvbmx5LlxyXG4gICAgICAgICAqIEBtZXRob2QgbmVhclNwaGVyZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lIGNvbnRhaW5pbmcgYSB7R2VvUG9pbnR9IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBgKGRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSxkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKWAsIHdoZXJlICpkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUqIHJhbmdlcyBmcm9tIC05MCB0byA5MCBhbmQgKmRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUqIHJhbmdlcyBmcm9tIC0xODAgdG8gMTgwLiBFeGFtcGxlOiBgKDQyLjY5NTQzMjIsMTIzLjMyMzk0NjcpYFxyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuR2VvUG9pbnR9IHBvaW50IENvbXBhcmlzb24gZ2VvcG9pbnQgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIERpc3RhbmNlIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0cmljcz1yYWRpYW5zXSBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hhdCB1bml0IG9mIG1lYXN1cmVtZW50IGlzIHVzZWQgZm9yIGRpc3RhbmNlLiBQb3NzaWJsZSB2YWx1ZXM6IHJhZGlhbnMsIGttLCBtaWxlcy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBuZWFyU3BoZXJlOiBmdW5jdGlvbiAoZmllbGQsIHBvaW50LCBkaXN0YW5jZSwgbWV0cmljcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5uZWFyU2hwZXJlLCBmaWVsZCwgcG9pbnQsIGRpc3RhbmNlLCBtZXRyaWNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBHZW9zcGF0aWFsIGNvbmRpdGlvbiB0aGF0IGEgc3BlY2lmaWVkIGdlb3BvaW50IG11c3QgYmUgd2l0aGluIGEgc3BlY2lmaWVkIGNvb3JkaW5hdGUgcmVjdGFuZ2xlLiBBcHBsaWNhYmxlIHRvIEdlb1BvaW50IGZpZWxkcyBvbmx5LlxyXG4gICAgICAgICAqIEBtZXRob2Qgd2l0aGluQm94XHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUgY29udGFpbmluZyBhIHtHZW9Qb2ludH0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGAoZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlLGRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUpYCwgd2hlcmUgKmRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSogcmFuZ2VzIGZyb20gLTkwIHRvIDkwIGFuZCAqZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSogcmFuZ2VzIGZyb20gLTE4MCB0byAxODAuIEV4YW1wbGU6IGAoNDIuNjk1NDMyMiwxMjMuMzIzOTQ2NylgXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gcG9pbnRCb3R0b21MZWZ0IFZhbHVlIHJlcHJlc2VudGluZyB0aGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBib3guXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gcG9pbnRVcHBlclJpZ2h0IFZhbHVlIHJlcHJlc2VudGluZyB0aGUgdXBwZXIgcmlnaHQgY29ybmVyIG9mIHRoZSBib3guXHJcbiAgICAgICAgICogQGV4YW1wbGUgYGBganNcclxuICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IEV2ZXJsaXZlLlF1ZXJ5KCk7XHJcbiAgICAgICAgIHF1ZXJ5LndoZXJlKCkud2l0aGluQm94KCdMb2NhdGlvbicsXHJcbiAgICAgICAgIG5ldyBFdmVybGl2ZS5HZW9Qb2ludCgyMy4zMTc4NzEsIDQyLjY4NzcwOSksXHJcbiAgICAgICAgIG5ldyBFdmVybGl2ZS5HZW9Qb2ludCgyMy4zMzEzNDYsIDQyLjcwNzA3NSkpO1xyXG4gICAgICAgICBgYGBcclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB3aXRoaW5Cb3g6IGZ1bmN0aW9uIChmaWVsZCwgcG9pbnRCb3R0b21MZWZ0LCBwb2ludFVwcGVyUmlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUud2l0aGluQm94LCBmaWVsZCwgcG9pbnRCb3R0b21MZWZ0LCBwb2ludFVwcGVyUmlnaHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIEdlb3NwYXRpYWwgY29uZGl0aW9uIHRoYXQgYSBzcGVjaWZpZWQgZ2VvcG9pbnQgbXVzdCBiZSB3aXRoaW4gYSBzcGVjaWZpZWQgY29vcmRpbmF0ZSBwb2x5Z29uLiBUaGUgcG9seWdvbiBpcyBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2YgZ2VvcG9pbnRzLiBUaGUgbGFzdCBwb2ludCBpbiB0aGUgYXJyYXkgaXMgaW1wbGljaXRseSBjb25uZWN0ZWQgdG8gdGhlIGZpcnN0IHBvaW50IHRodXMgY2xvc2luZyB0aGUgc2hhcGUuIEFwcGxpY2FibGUgdG8gR2VvUG9pbnQgZmllbGRzIG9ubHkuXHJcbiAgICAgICAgICogQG1ldGhvZCB3aXRoaW5Qb2x5Z29uXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUgY29udGFpbmluZyBhIHtHZW9Qb2ludH0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGAoZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlLGRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUpYCwgd2hlcmUgKmRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSogcmFuZ2VzIGZyb20gLTkwIHRvIDkwIGFuZCAqZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSogcmFuZ2VzIGZyb20gLTE4MCB0byAxODAuIEV4YW1wbGU6IGAoNDIuNjk1NDMyMiwxMjMuMzIzOTQ2NylgXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludFtdfSBwb2ludHMgQ29tcGFyaXNvbiB2YWx1ZSBpbiB0aGUgZm9ybSBvZiBhbiBhcnJheSBvZiBnZW9wb2ludHMgZGVmaW5pbmcgdGhlIHBvbHlnb24uXHJcbiAgICAgICAgICogQGV4YW1wbGUgYGBganNcclxuICAgICAgICAgdmFyIHBvaW50MSA9IG5ldyBFdmVybGl2ZS5HZW9Qb2ludCgyMy4zMTc4NzEsIDQyLjY4NzcwOSk7XHJcbiAgICAgICAgIHZhciBwb2ludDIgPSBuZXcgRXZlcmxpdmUuR2VvUG9pbnQoNDIuNjk4NzQ5LCA0Mi42OTg3NDkpO1xyXG4gICAgICAgICB2YXIgcG9pbnQzID0gbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMzMTM0NiwgNDIuNzAyMjgyKTtcclxuXHJcbiAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBFdmVybGl2ZS5RdWVyeSgpO1xyXG4gICAgICAgICBxdWVyeS53aGVyZSgpLndpdGhpblBvbHlnb24oXCJsb2NhdGlvblwiLCBbcG9pbnQxLCBwb2ludDIsIHBvaW50M10pO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhpblBvbHlnb246IGZ1bmN0aW9uIChmaWVsZCwgcG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLndpdGhpblBvbHlnb24sIGZpZWxkLCBwb2ludHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIEdlb3NwYXRpYWwgY29uZGl0aW9uIHRoYXQgYSBzcGVjaWZpZWQgZ2VvcG9pbnQgbXVzdCBiZSB3aXRoaW4gYSBjb29yZGluYXRlIGNpcmNsZS4gQXBwbGljYWJsZSB0byBHZW9Qb2ludCBmaWVsZHMgb25seS5cclxuICAgICAgICAgKiBAbWV0aG9kIHdpdGhpbkNlbnRlclNwaGVyZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lIGNvbnRhaW5pbmcgYSB7R2VvUG9pbnR9IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBgKGRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSxkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKWAsIHdoZXJlICpkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUqIHJhbmdlcyBmcm9tIC05MCB0byA5MCBhbmQgKmRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUqIHJhbmdlcyBmcm9tIC0xODAgdG8gMTgwLiBFeGFtcGxlOiBgKDQyLjY5NTQzMjIsMTIzLjMyMzk0NjcpYFxyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuR2VvUG9pbnR9IGNlbnRlciBDb21wYXJpc29uIHZhbHVlIHNwZWNpZnlpbmcgdGhlIGNlbnRlciBvZiB0aGUgY29vcmRpbmF0ZSBjaXJjbGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBWYWx1ZSBzcGVjaWZ5aW5nIHRoZSByYWRpdXMgbGVuZ3RoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0cmljcz1yYWRpYW5zXSBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hhdCB1bml0IG9mIG1lYXN1cmVtZW50IGlzIHVzZWQgZm9yIHJhZGl1cyBsZW5ndGguIFBvc3NpYmxlIHZhbHVlczogcmFkaWFucywga20sIG1pbGVzLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhpbkNlbnRlclNwaGVyZTogZnVuY3Rpb24gKGZpZWxkLCBjZW50ZXIsIHJhZGl1cywgbWV0cmljcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS53aXRoaW5TaHBlcmUsIGZpZWxkLCBjZW50ZXIsIHJhZGl1cywgbWV0cmljcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmRzIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBjdXJyZW50IFdoZXJlUXVlcnkuIFlvdSBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgaW4gb3JkZXIgdG8gY29udGludWUgd2l0aCB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgcGFyZW50IGBRdWVyeWAuIEFsbCBvdGhlciBgV2hlcmVRdWVyeWAgbWV0aG9kcyByZXR1cm4gdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgYFdoZXJlUXVlcnlgIHRvIGFsbG93IGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2QgZG9uZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBkb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFdoZXJlUXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5fZG9uZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5lcXVhbCA9IFdoZXJlUXVlcnkucHJvdG90eXBlLmVxO1xyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUubm90RXF1YWwgPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5uZTtcclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gV2hlcmVRdWVyeS5wcm90b3R5cGUuZ3Q7XHJcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5ncmVhdGVyVGhhbkVxdWFsID0gV2hlcmVRdWVyeS5wcm90b3R5cGUuZ3RlO1xyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUubGVzc1RoYW4gPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5sdDtcclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmxlc3NUaGFuRXF1YWwgPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5sdGU7XHJcblxyXG4gICAgcmV0dXJuIFdoZXJlUXVlcnk7XHJcbn0oKSk7IiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBmdW5jdGlvbiByZXF3ZXN0KG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgaHR0cFJlcXVlc3RPcHRpb25zID0ge1xyXG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxyXG4gICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfHwge31cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XHJcbiAgICAgICAgICAgIGh0dHBSZXF1ZXN0T3B0aW9ucy5jb250ZW50ID0gb3B0aW9ucy5kYXRhOyAvLyBOT1RFOiBJZiB3ZSBwYXNzIG51bGwvdW5kZWZpbmVkLCBpdCB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbiBpbiB0aGUgaHR0cCBtb2R1bGUuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBodHRwUmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICAgICAgaHR0cFJlcXVlc3RPcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xyXG5cclxuICAgICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzIHx8IG5vb3A7XHJcbiAgICAgICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvciB8fCBub29wO1xyXG5cclxuICAgICAgICB2YXIgcmVxdWVzdFN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFN0cmluZyA9IHJlc3BvbnNlLmNvbnRlbnQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPCA0MDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MgY2FsbGJhY2sgY2FsbHMgYSBjdXN0b20gcGFyc2UgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoY29udGVudFN0cmluZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBjYWxsYmFjayByZWxpZXMgb24gYSBKU09OIE9iamVjdCB3aXRoIFJlc3BvbnNlVGV4dCBpbnNpZGVcclxuICAgICAgICAgICAgICAgIGVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQ6IGNvbnRlbnRTdHJpbmdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHJlcXVlc3RFcnJvckNhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAvLyBlcnJvcjogZnVuY3Rpb24oanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKVxyXG4gICAgICAgICAgICAvLyB3aGVuIHRpbWVvdXRpbmcgZm9yIGV4YW1wbGUgKGkuZS4gbm8gaW50ZXJuZXQgY29ubmVjdGl2aXR5KSwgd2UgZ2V0IGFuIGVyciB3aXRoIGNvbnRlbnQgeyBtZXNzYWdlOiBcInRpbWVvdXQuLi5cIiwgc3RhY2s6IG51bGwgfVxyXG4gICAgICAgICAgICBlcnJvcih7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZVRleHQ6IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBodHRwLnJlcXVlc3QoaHR0cFJlcXVlc3RPcHRpb25zKS50aGVuKHJlcXVlc3RTdWNjZXNzQ2FsbGJhY2ssIHJlcXVlc3RFcnJvckNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVxd2VzdDtcclxufSgpKTsiLCJ2YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XHJcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xyXG52YXIgcnN2cCA9IHJlcXVpcmUoJ3JzdnAnKTtcclxudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlcXdlc3Qob3B0aW9ucykge1xyXG4gICAgICAgIHZhciB1cmxQYXJ0cyA9IHVybC5wYXJzZShvcHRpb25zLnVybCk7XHJcbiAgICAgICAgdmFyIHJlcXVlc3Q7XHJcbiAgICAgICAgaWYgKHVybFBhcnRzLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xyXG4gICAgICAgICAgICByZXF1ZXN0ID0gaHR0cHMucmVxdWVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSBodHRwLnJlcXVlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xyXG4gICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyB8fCBfLm5vb3A7XHJcbiAgICAgICAgb3B0aW9ucy5lcnJvciA9IG9wdGlvbnMuZXJyb3IgfHwgXy5ub29wO1xyXG5cclxuICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XHJcbiAgICAgICAgdmFyIHJlcSA9IHJlcXVlc3Qoe1xyXG4gICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxyXG4gICAgICAgICAgICBob3N0bmFtZTogdXJsUGFydHMuaG9zdG5hbWUsXHJcbiAgICAgICAgICAgIHBvcnQ6IHVybFBhcnRzLnBvcnQsXHJcbiAgICAgICAgICAgIHBhdGg6IHVybFBhcnRzLnBhdGgsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcclxuICAgICAgICB9LCBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgIHZhciBqc29uID0gJyc7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50RW5jb2RpbmcgPSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VQcm94eTtcclxuICAgICAgICAgICAgc3dpdGNoIChjb250ZW50RW5jb2Rpbmcpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3ppcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm94eSA9IHpsaWIuY3JlYXRlR3VuemlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnBpcGUocmVzcG9uc2VQcm94eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJveHkgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm94eS5zZXRFbmNvZGluZygndXRmOCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXNwb25zZVByb3h5Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGpzb24gKz0gZGF0YS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJlc3BvbnNlUHJveHkub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIDF4eCBJbmZvcm1hdGlvbmFsLCAyeHggU3VjY2VzcywgM3h4IFJlZGlyZWN0aW9uLCA0eHggQ2xpZW50IEVycm9yLCA1eHggU2VydmVyIEVycm9yXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHJlcy5zdGF0dXNDb2RlIDwgNDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKGpzb24sIHJlcyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoeyByZXNwb25zZVRleHQ6IGpzb24gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBlbXB0eSByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGVycm9yLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoeyByZXNwb25zZVRleHQ6IGVycm9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmVycm9yKHsgcmVzcG9uc2VUZXh0OiBlIH0pOyAvLyBUT0RPXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRFbmNvZGluZyA9IGhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXTtcclxuICAgICAgICAgICAgc3dpdGNoIChjb250ZW50RW5jb2Rpbmcpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3ppcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIob3B0aW9ucy5kYXRhLCAndXRmLTgnKTtcclxuICAgICAgICAgICAgICAgICAgICB6bGliLmd6aXAoYnVmLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmVuZChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXEuZW5kKG9wdGlvbnMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcS5lbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcXdlc3Q7XHJcbn0oKSk7IiwidmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi4vZXZlcmxpdmUucGxhdGZvcm0nKTtcclxudmFyIFdlYkZpbGVTdG9yZSA9IHJlcXVpcmUoJy4vV2ViRmlsZVN0b3JlJyk7XHJcbnZhciBOYXRpdmVTY3JpcHRGaWxlU3RvcmUgPSByZXF1aXJlKCcuL05hdGl2ZVNjcmlwdEZpbGVTdG9yZScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pZiAocGxhdGZvcm0uaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gTmF0aXZlU2NyaXB0RmlsZVN0b3JlO1xyXG59IGVsc2UgaWYgKHBsYXRmb3JtLmlzQ29yZG92YSB8fCBwbGF0Zm9ybS5pc0Rlc2t0b3ApIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gV2ViRmlsZVN0b3JlO1xyXG59IGVsc2Uge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfLm5vb3A7XHJcbn0iLCJ2YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuLy4uL2V2ZXJsaXZlLnBsYXRmb3JtLmpzJyk7XHJcbnZhciBpc05hdGl2ZVNjcmlwdCA9IHBsYXRmb3JtLmlzTmF0aXZlU2NyaXB0O1xyXG52YXIgaXNOb2RlanMgPSBwbGF0Zm9ybS5pc05vZGVqcztcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vLi4vY29uc3RhbnRzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdExvY2FsU3RvcmFnZShvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbFNldHRpbmdzO1xyXG5cclxuICAgICAgICAgICAgLy93b3Jrb3VuZCBmb3Igb2xkZXIgbmF0aXZlc2NyaXB0IHZlcnNpb25zXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFNldHRpbmdzID0gcmVxdWlyZSgnYXBwbGljYXRpb24tc2V0dGluZ3MnKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTZXR0aW5ncyA9IHJlcXVpcmUoJ2xvY2FsLXNldHRpbmdzJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU2V0dGluZ3MuZ2V0U3RyaW5nKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTZXR0aW5ncy5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2V0SXRlbTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTZXR0aW5ncy5zZXRTdHJpbmcoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FsU3RvcmFnZTtcclxuICAgICAgICAgICAgaWYgKGlzTm9kZWpzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgTG9jYWxTdG9yYWdlID0gcmVxdWlyZSgnbm9kZS1sb2NhbHN0b3JhZ2UnKS5Mb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlKG9wdGlvbnMuc3RvcmFnZS5zdG9yYWdlUGF0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZ2V0SXRlbTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNldEl0ZW06IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBMb2NhbFN0b3JlKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX2xvY2FsU3RvcmFnZSA9IGluaXRMb2NhbFN0b3JhZ2UodGhpcy5vcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBMb2NhbFN0b3JlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0SXRlbTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIExvY2FsU3RvcmU7XHJcbn0oKSk7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG5cclxuZnVuY3Rpb24gTmF0aXZlU2NyaXB0RmlsZVN0b3JlKHN0b3JhZ2VQYXRoLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZpbGUtc3lzdGVtJyk7XHJcbiAgICB0aGlzLmRhdGFEaXJlY3RvcnlQYXRoID0gdGhpcy5mcy5rbm93bkZvbGRlcnMuZG9jdW1lbnRzKCkucGF0aDtcclxuICAgIHRoaXMuZmlsZXNEaXJlY3RvcnlQYXRoID0gc3RvcmFnZVBhdGg7XHJcbn1cclxuXHJcbk5hdGl2ZVNjcmlwdEZpbGVTdG9yZS5wcm90b3R5cGUgPSB7XHJcbiAgICBnZXRFcnJvckhhbmRsZXI6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUZpbGVzRGlyZWN0b3J5OiBmdW5jdGlvbiAoZGlyZWN0b3J5RW50cnkpIHtcclxuICAgICAgICB2YXIgZmlsZXNEaXJlY3RvcnlQYXRoID0gdGhpcy5mcy5wYXRoLmpvaW4oZGlyZWN0b3J5RW50cnkucGF0aCwgdGhpcy5maWxlc0RpcmVjdG9yeVBhdGgpO1xyXG4gICAgICAgIHZhciBmaWxlc0RpcmVjdG9yeSA9IHRoaXMuZnMuRm9sZGVyLmZyb21QYXRoKGZpbGVzRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIGZpbGVzRGlyZWN0b3J5LnJlbW92ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVGaWxlOiBmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGVFbnRyeS5yZW1vdmUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZEZpbGVBc1RleHQ6IGZ1bmN0aW9uIChmaWxlRW50cnkpIHtcclxuICAgICAgICByZXR1cm4gZmlsZUVudHJ5LnJlYWRUZXh0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHdyaXRlVGV4dFRvRmlsZTogZnVuY3Rpb24gKGZpbGVFbnRyeSwgY29udGVudCkge1xyXG4gICAgICAgIHJldHVybiBmaWxlRW50cnkud3JpdGVUZXh0KGNvbnRlbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRGaWxlOiBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZURhdGFEaXJlY3RvcnkoZnVuY3Rpb24gKGRpcmVjdG9yeUVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnVsbEZpbGVQYXRoID0gc2VsZi5mcy5wYXRoLmpvaW4oZGlyZWN0b3J5RW50cnkucGF0aCwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IHNlbGYuZnMuRmlsZS5mcm9tUGF0aChmdWxsRmlsZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmaWxlKTtcclxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzb2x2ZURhdGFEaXJlY3Rvcnk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhRGlyZWN0b3J5ID0gc2VsZi5mcy5Gb2xkZXIuZnJvbVBhdGgoc2VsZi5kYXRhRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YURpcmVjdG9yeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGVuc3VyZUZpbGVzRGlyZWN0b3J5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZURhdGFEaXJlY3RvcnkoZnVuY3Rpb24gKGRpcmVjdG9yeUVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZURpcmVjdG9yeVBhdGggPSBzZWxmLmZzLnBhdGguam9pbihkaXJlY3RvcnlFbnRyeS5wYXRoLCBzZWxmLmZpbGVzRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmZzLkZvbGRlci5mcm9tUGF0aChmaWxlRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRGaWxlc0RpcmVjdG9yeVBhdGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlc0RpcmVjdG9yeVBhdGg7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRPRE86IFtvZmZsaW5lXSBJbXBsZW1lbnRcclxuICAgIHdyaXRlVGV4dDogZnVuY3Rpb24gKGZpbGVOYW1lLCB0ZXh0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVE9ETzogW29mZmxpbmVdIEltcGxlbWVudFxyXG4gICAgY3JlYXRlRGlyZWN0b3J5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVE9ETzogW29mZmxpbmVdIEltcGxlbWVudFxyXG4gICAgZ2V0RmlsZVNpemU6IGZ1bmN0aW9uIChmaWxlLCBnZXRGaWxlU2l6ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRPRE86IFtvZmZsaW5lXSBJbXBsZW1lbnRcclxuICAgIGdldEZpbGVCeUFic29sdXRlUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWFkRmlsZUFzQmFzZTY0OiBmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmFtZUZpbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfSxcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmF0aXZlU2NyaXB0RmlsZVN0b3JlOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi4vZXZlcmxpdmUucGxhdGZvcm0nKTtcclxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcblxyXG52YXIgZGV2aWNlUmVhZHlQcm9taXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIHJlc29sdmUpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBXZWJGaWxlU3RvcmUoc3RvcmFnZVBhdGgsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblxyXG4gICAgdmFyIGZpbGVzRGlyZWN0b3J5UGF0aDtcclxuXHJcbiAgICBpZiAocGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUpIHtcclxuICAgICAgICAvL3dpbmRvd3MgcGhvbmUgZG9lcyBub3QgaGFuZGxlIGxlYWRpbmcgb3IgdHJhaWxpbmcgc2xhc2hlcyB2ZXJ5IHdlbGwgOihcclxuICAgICAgICBmaWxlc0RpcmVjdG9yeVBhdGggPSBzdG9yYWdlUGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJy8nLCAnZycpLCAnJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChzdG9yYWdlUGF0aC5sYXN0SW5kZXhPZignLycpID09PSAtMSkge1xyXG4gICAgICAgICAgICBmaWxlc0RpcmVjdG9yeVBhdGggPSBzdG9yYWdlUGF0aCArICcvJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZmlsZXNEaXJlY3RvcnlQYXRoID0gZmlsZXNEaXJlY3RvcnlQYXRoIHx8IHN0b3JhZ2VQYXRoO1xyXG5cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICBkZXZpY2VSZWFkeVByb21pc2UoKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZi5maWxlc0RpcmVjdG9yeVBhdGggPSBmaWxlc0RpcmVjdG9yeVBhdGg7XHJcbiAgICAgICAgICAgIHNlbGYuX3JlcXVlc3RGaWxlU3lzdGVtID0gd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbTtcclxuICAgICAgICAgICAgc2VsZi5fcmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTCA9IHdpbmRvdy5yZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMIHx8IHdpbmRvdy53ZWJraXRSZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMO1xyXG4gICAgICAgICAgICBzZWxmLl9QRVJTSVNURU5UX0ZJTEVfU1lTVEVNID0gd2luZG93LkxvY2FsRmlsZVN5c3RlbSA/IHdpbmRvdy5Mb2NhbEZpbGVTeXN0ZW0uUEVSU0lTVEVOVCA6IHdpbmRvdy5QRVJTSVNURU5UO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5XZWJGaWxlU3RvcmUucHJvdG90eXBlID0ge1xyXG4gICAgZ2V0RXJyb3JIYW5kbGVyOiBmdW5jdGlvbiBnZXRFcnJvckhhbmRsZXIoY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgZXJyb3JzTWFwID0ge1xyXG4gICAgICAgICAgICAnMTAwMCc6ICdOT1RfRk9VTkQnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgXy5lYWNoKE9iamVjdC5rZXlzKEZpbGVFcnJvciksIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBlcnJvcnNNYXBbRmlsZUVycm9yW2Vycm9yXV0gPSBlcnJvcjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICghZS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBlcnJvcnNNYXBbZS5jb2RlXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXREYXRhRGlyZWN0b3J5OiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmaWxlU3lzdGVtUm9vdDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldERhdGFEaXJlY3RvcnkoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXZpY2VSZWFkeVByb21pc2UoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RmlsZVN5c3RlbSA9IGZ1bmN0aW9uIChieXRlcywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVxdWVzdEZpbGVTeXN0ZW0uY2FsbCh3aW5kb3csIHNlbGYuX1BFUlNJU1RFTlRfRklMRV9TWVNURU0sIGJ5dGVzLCBmdW5jdGlvbiAoZmlsZVN5c3RlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVN5c3RlbVJvb3QgPSBmaWxlU3lzdGVtLnJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlU3lzdGVtUm9vdC5uYXRpdmVVUkwgPSBmaWxlU3lzdGVtUm9vdC5uYXRpdmVVUkwgfHwgZmlsZVN5c3RlbVJvb3QudG9VUkwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZmlsZVN5c3RlbVJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZVN5c3RlbVJvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbGVTeXN0ZW1Sb290KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXRmb3JtLmlzRGVza3RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hdmlnYXRvciAmJiAhbmF2aWdhdG9yLndlYmtpdFBlcnNpc3RlbnRTdG9yYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcignRmlsZVN5c3RlbVN0b3JhZ2UgY2FuIGJlIHVzZWQgb25seSB3aXRoIGJyb3dzZXJzIHN1cHBvcnRpbmcgaXQuIENvbnNpZGVyIHVzaW5nIGxvY2FsU3RvcmFnZS4nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3Iud2Via2l0UGVyc2lzdGVudFN0b3JhZ2UucmVxdWVzdFF1b3RhKHNlbGYub3B0aW9ucy5zdG9yYWdlLnJlcXVlc3RlZFF1b3RhLCBmdW5jdGlvbiAoZ3JhbnRlZEJ5dGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEZpbGVTeXN0ZW0oZ3JhbnRlZEJ5dGVzLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RGaWxlU3lzdGVtKDAsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9KCkpLFxyXG5cclxuICAgIGdldEZpbGVzRGlyZWN0b3J5OiBmdW5jdGlvbiBnZXRGaWxlc0RpcmVjdG9yeSgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzZWxmLmdldERhdGFEaXJlY3RvcnkoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGFEaXJlY3RvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhRGlyZWN0b3J5LmdldERpcmVjdG9yeShzZWxmLmZpbGVzRGlyZWN0b3J5UGF0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1c2l2ZTogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB9LCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVGaWxlc0RpcmVjdG9yeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNEaXJlY3RvcnkoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZXNEaXJlY3RvcnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZW1vdmVGb2xkZXJXcmFwKGZpbGVzRGlyZWN0b3J5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUZpbGU6IGZ1bmN0aW9uIChmaWxlRW50cnkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZpbGVFbnRyeS5yZW1vdmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWFkRmlsZUFzVGV4dDogZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzZWxmLmdldEZpbGVzRGlyZWN0b3J5KCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlRW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2luZG93cyBwaG9uZSByZXR1cm5zIGFuIG9iamVjdC4uLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlc3VsdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHRoaXMucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICB3cml0ZVRleHRUb0ZpbGU6IGZ1bmN0aW9uIChmaWxlRW50cnksIGNvbnRlbnQpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmLmdldEZpbGVzRGlyZWN0b3J5KClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldFdyaXRlcldyYXAoZmlsZUVudHJ5LCBjb250ZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZpbGVTaXplOiBmdW5jdGlvbiAoZmlsZW5hbWUsIGZvbGRlcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgZmlsZUxvY2F0aW9uID0gdXRpbHMuam9pblBhdGgoZm9sZGVyLCBmaWxlbmFtZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRGaWxlKGZpbGVMb2NhdGlvbilcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmaWxlRW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlRW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZpbGUuc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZpbGU6IGZ1bmN0aW9uIChmaWxlTmFtZSwgZGlyRW50cnkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWxlc0RpcmVjdG9yeSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVEaXJlY3Rvcnk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlyRW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlRGlyZWN0b3J5ID0gZGlyRW50cnk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVEaXJlY3RvcnkgPSBkaXJlY3RvcnlFbnRyeTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZURpcmVjdG9yeS5nZXRGaWxlKGZpbGVOYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVzaXZlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZpbGVCeUFic29sdXRlUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcGF0aCA9IHV0aWxzLnRyYW5zZm9ybVBsYXRmb3JtUGF0aChwYXRoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzZWxmLl9yZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMLmNhbGwod2luZG93LCBwYXRoLCByZXNvbHZlLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSBGaWxlRXJyb3IuTk9UX0ZPVU5EX0VSUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlRGlyZWN0b3J5OiBmdW5jdGlvbiAoZGlyZWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWxlc0RpcmVjdG9yeSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldERpcmVjdG9yeVdyYXAoZGlyZWN0b3J5LCBkaXJlY3RvcnlFbnRyeSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBleGNsdXNpdmU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmFtZUZpbGU6IGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSwgZmlsZUVudHJ5LCBmaWxlbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZmlsZUVudHJ5Lm1vdmVUbyhkaXJlY3RvcnlFbnRyeSwgZmlsZW5hbWUsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXREaXJlY3RvcnlXcmFwOiBmdW5jdGlvbiAoZGlyZWN0b3J5LCBkaXJlY3RvcnlFbnRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZGlyZWN0b3J5RW50cnkuZ2V0RGlyZWN0b3J5KGRpcmVjdG9yeSwgb3B0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX3JlbW92ZUZvbGRlcldyYXA6IGZ1bmN0aW9uIChmaWxlc0RpckVudHJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmaWxlc0RpckVudHJ5LnJlbW92ZVJlY3Vyc2l2ZWx5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2dldFdyaXRlcldyYXA6IGZ1bmN0aW9uIChmaWxlRW50cnksIGNvbnRlbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZpbGVFbnRyeS5jcmVhdGVXcml0ZXIoZnVuY3Rpb24gKGZpbGVXcml0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVXcml0ZXIub253cml0ZWVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGVXcml0ZXIub25lcnJvciA9IHJlamVjdDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBuZXcgQmxvYihbY29udGVudF0pO1xyXG4gICAgICAgICAgICAgICAgZmlsZVdyaXRlci53cml0ZShiYik7XHJcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHdyaXRlVGV4dDogZnVuY3Rpb24gKGZpbGVOYW1lLCB0ZXh0LCBwYXRoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBmaWxlSGFuZGxlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWxlc0RpcmVjdG9yeSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jcmVhdGVEaXJlY3RvcnkocGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3RvcnlFbnRyeTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRpcmVjdG9yeUVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRGaWxlKGZpbGVOYW1lLCBkaXJlY3RvcnlFbnRyeSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmaWxlRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVIYW5kbGUgPSBmaWxlRW50cnk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi53cml0ZVRleHRUb0ZpbGUoZmlsZUVudHJ5LCB0ZXh0KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgIGlzIGEgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjb3Jkb3ZhIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgc3RhbmRhcmQgRmlsZVRyYW5zZmVyIGZpbGVFbnRyeVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVIYW5kbGUubmF0aXZlVVJMIHx8IGZpbGVIYW5kbGUudG9VUkwoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTU4MzM2My9nZXQtYmFzZTY0LWZyb20taW1hZ2V1cmktd2l0aC1waG9uZWdhcFxyXG4gICAgcmVhZEZpbGVBc0Jhc2U2NDogZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZmlsZUVudHJ5LmZpbGUoZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHV0aWxzLmFycmF5QnVmZmVyVG9CYXNlNjQoZXZ0LnRhcmdldC5yZXN1bHQpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xyXG4gICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJGaWxlU3RvcmU7IiwidmFyIGJ1aWxkUHJvbWlzZSA9IHJlcXVpcmUoJy4uL3V0aWxzJykuYnVpbGRQcm9taXNlO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcbnZhciBpZEZpZWxkID0gY29uc3RhbnRzLmlkRmllbGQ7XHJcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9EYXRhUXVlcnknKTtcclxudmFyIFJlcXVlc3RPcHRpb25zQnVpbGRlciA9IHJlcXVpcmUoJy4uL3F1ZXJ5L1JlcXVlc3RPcHRpb25zQnVpbGRlcicpO1xyXG52YXIgcnN2cCA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLnJzdnA7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgRXZlcmxpdmUgPSByZXF1aXJlKCcuLi9FdmVybGl2ZScpO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgRXZlcmxpdmVFcnJvcnMgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcnM7XHJcbnZhciBldmVybGl2ZVBsYXRmb3JtID0gcmVxdWlyZSgnLi4vZXZlcmxpdmUucGxhdGZvcm0nKS5wbGF0Zm9ybTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gbWVyZ2VSZXN1bHREYXRhKGRhdGEsIHN1Y2Nlc3MpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlcywgcmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJzID0gcmVzLnJlc3VsdDtcclxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3Iga2VuZG8gb2JzZXJ2YWJsZSBhcnJheVxyXG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGRhdGEpIHx8IHR5cGVvZiBkYXRhLmxlbmd0aCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfLmV4dGVuZChpdGVtLCBhdHRyc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfLmV4dGVuZChkYXRhLCBhdHRycyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN1Y2Nlc3MocmVzLCByZXNwb25zZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZXJnZVVwZGF0ZVJlc3VsdERhdGEoZGF0YSwgc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgIHZhciBtb2RpZmllZEF0ID0gcmVzLk1vZGlmaWVkQXQ7XHJcbiAgICAgICAgICAgIGRhdGEuTW9kaWZpZWRBdCA9IG1vZGlmaWVkQXQ7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MocmVzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIERhdGFcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBjbGFzcyB0aGF0IHByb3ZpZGVzIG1ldGhvZHMgZm9yIGFsbCBDUlVEIG9wZXJhdGlvbnMgdG8gYSBnaXZlbiB7e3NpdGUuYnN9fSBkYXRhIHR5cGUuIENvdmVycyBhZHZhbmNlZCBzY2VuYXJpb3Mgd2l0aCBjdXN0b20gaGVhZGVycyBhbmQgc3BlY2lhbCBzZXJ2ZXItc2lkZSBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHVwXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbk5hbWVcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGF0YShzZXR1cCwgY29sbGVjdGlvbk5hbWUsIG9mZmxpbmVTdG9yYWdlLCBldmVybGl2ZSkge1xyXG4gICAgICAgIHRoaXMuc2V0dXAgPSBzZXR1cDtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlID0gb2ZmbGluZVN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5ldmVybGl2ZSA9IGV2ZXJsaXZlO1xyXG4gICAgfVxyXG5cclxuICAgIERhdGEucHJvdG90eXBlID0ge1xyXG4gICAgICAgIF9pc09ubGluZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZSA/IHRoaXMub2ZmbGluZVN0b3JhZ2UuaXNPbmxpbmUoKSA6IHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldE9mZmxpbmVDcmVhdGVEYXRhOiBmdW5jdGlvbiAocXVlcnksIHJlcXVlc3RSZXNwb25zZSkge1xyXG4gICAgICAgICAgICB2YXIgY3JlYXRlRGF0YTtcclxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShxdWVyeS5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeS5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdFRvQ3JlYXRlID0gXy5leHRlbmQocXVlcnkuZGF0YVtpXSwgcmVxdWVzdFJlc3BvbnNlLnJlc3VsdFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRGF0YS5wdXNoKG9iamVjdFRvQ3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlRGF0YSA9IF8uZXh0ZW5kKHF1ZXJ5LmRhdGEsIHJlcXVlc3RSZXNwb25zZS5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRGF0YTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hcHBseU9mZmxpbmU6IGZ1bmN0aW9uIChxdWVyeSwgcmVxdWVzdFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBhdXRvU3luY0VuYWJsZWQgPSB0aGlzLm9mZmxpbmVTdG9yYWdlICYmIHRoaXMub2ZmbGluZVN0b3JhZ2Uuc2V0dXAuYXV0b1N5bmM7XHJcbiAgICAgICAgICAgIGlmIChhdXRvU3luY0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocXVlcnkub3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZEJ5SWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW5jUmVhZFF1ZXJ5ID0gbmV3IERhdGFRdWVyeShfLmRlZmF1bHRzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3RSZXNwb25zZS5yZXN1bHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N5bmM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBxdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5wcm9jZXNzUXVlcnkoc3luY1JlYWRRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdGVEYXRhID0gdGhpcy5fZ2V0T2ZmbGluZUNyZWF0ZURhdGEocXVlcnksIHJlcXVlc3RSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdGVRdWVyeSA9IG5ldyBEYXRhUXVlcnkoXy5kZWZhdWx0cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjcmVhdGVEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTeW5jOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlLnByb2Nlc3NRdWVyeShjcmVhdGVRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yYXdVcGRhdGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmlzU3luYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lk1vZGlmaWVkQXQgPSByZXF1ZXN0UmVzcG9uc2UuTW9kaWZpZWRBdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmbGluZVN0b3JhZ2UucHJvY2Vzc1F1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5pc1N5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5wcm9jZXNzUXVlcnkocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSBfLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zW2tleV0sIHZhbHVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIE1vZGlmaWVzIHdoZXRoZXIgdGhlIHF1ZXJ5IHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuXHJcbiAgICAgICAgICogRGVmYXVsdCBpcyB0cnVlLlxyXG4gICAgICAgICAqIE9ubHkgdmFsaWQgd2hlbiBvZmZsaW5lU3RvcmFnZSBpcyBlbmFibGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB1c2VPZmZsaW5lXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICogKi9cclxuICAgICAgICB1c2VPZmZsaW5lOiBmdW5jdGlvbiAodXNlT2ZmbGluZSkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNpbmdsZSB2YWx1ZSBpcyBleHBlY3RlZCBpbiB1c2VPZmZsaW5lKCkgcXVlcnkgbW9kaWZpZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCd1c2VPZmZsaW5lJywgdXNlT2ZmbGluZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBuYW1lIGlnbm9yZUNhY2hlXHJcbiAgICAgICAgICogRG9lcyBub3QgdXNlIHRoZSBjYWNoZSB3aGVuIHJldHJpZXZpbmcgdGhlIGRhdGEuXHJcbiAgICAgICAgICogT25seSB2YWxpZCB3aGVuIGNhY2hpbmcgaXMgZW5hYmxlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YX1cclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgIGlnbm9yZUNhY2hlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRPcHRpb24oJ2lnbm9yZUNhY2hlJywgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBuYW1lIGZvcmNlQ2FjaGVcclxuICAgICAgICAgKiBGb3JjZXMgdGhlIHJlcXVlc3QgdG8gZ2V0IHRoZSBkYXRhIGZyb20gdGhlIGNhY2hlIGV2ZW4gaWYgdGhlIGRhdGEgaXMgYWxyZWFkeSBleHBpcmVkLlxyXG4gICAgICAgICAqIE9ubHkgdmFsaWQgd2hlbiBjYWNoaW5nIGlzIGVuYWJsZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICogKi9cclxuICAgICAgICBmb3JjZUNhY2hlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRPcHRpb24oJ2ZvcmNlQ2FjaGUnLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG5hbWUgbWF4QWdlXHJcbiAgICAgICAgICogU2V0cyBjYWNoZSBleHBpcmF0aW9uIHNwZWNpZmljYWxseSBmb3IgdGhlIGN1cnJlbnQgcXVlcnlcclxuICAgICAgICAgKiBPbmx5IHZhbGlkIHdoZW4gY2FjaGluZyBpcyBlbmFibGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBtYXhBZ2VJbk1pbnV0ZXNcclxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YX1cclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgIG1heEFnZTogZnVuY3Rpb24gKG1heEFnZUluTWludXRlcykge1xyXG4gICAgICAgICAgICB2YXIgbWF4QWdlID0gbWF4QWdlSW5NaW51dGVzICogMTAwMCAqIDYwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCdtYXhBZ2UnLCBtYXhBZ2UpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzU3luYzogZnVuY3Rpb24gKGlzU3luYykge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNpbmdsZSB2YWx1ZSBpcyBleHBlY3RlZCBpbiBpc1N5bmMoKSBxdWVyeSBtb2RpZmllcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRPcHRpb24oJ2lzU3luYycsIGlzU3luYyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIE1vZGlmaWVzIHdoZXRoZXIgdGhlIHF1ZXJ5IHNob3VsZCBpbnZva2UgdGhlIHt7QGxpbmsgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmhhc0F1dGhlbnRpY2F0aW9uUmVxdWlyZW1lbnR9fS5cclxuICAgICAgICAgKiBEZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICAgICAqIE9ubHkgdmFsaWQgd2hlbiBhdXRoZW50aWNhdGlvbiBtb2R1bGUgaGFzIGFuIG9uQXV0aGVudGljYXRpb25SZXF1aXJlZCBmdW5jdGlvbiAuXHJcbiAgICAgICAgICogQHBhcmFtIHNraXBBdXRoXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICogKi9cclxuICAgICAgICBza2lwQXV0aDogZnVuY3Rpb24gKHNraXBBdXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2luZ2xlIHZhbHVlIGlzIGV4cGVjdGVkIGluIHNraXBBdXRoKCkgcXVlcnkgbW9kaWZpZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCdza2lwQXV0aCcsIHNraXBBdXRoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb2RpZmllcyB3aGV0aGVyIHRoZSBxdWVyeSBzaG91bGQgYmUgYXBwbGllZCBvZmZsaW5lLCBpZiB0aGUgc2RrIGlzIGN1cnJlbnR5IHdvcmtpbmcgb25saW5lLlxyXG4gICAgICAgICAqIERlZmF1bHQgaXMgdHJ1ZS5cclxuICAgICAgICAgKiBPbmx5IHZhbGlkIHdoZW4gb2ZmbGluZVN0b3JhZ2UgaXMgZW5hYmxlZC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIGFwcGx5T2ZmbGluZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRhfVxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgYXBwbHlPZmZsaW5lOiBmdW5jdGlvbiAoYXBwbHlPZmZsaW5lKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2luZ2xlIHZhbHVlIGlzIGV4cGVjdGVkIGluIGFwcGx5T2ZmbGluZSgpIHF1ZXJ5IG1vZGlmaWVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldE9wdGlvbignYXBwbHlPZmZsaW5lJywgYXBwbHlPZmZsaW5lKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGFkZGl0aW9uYWwgbm9uLXN0YW5kYXJkIEhUVFAgaGVhZGVycyBpbiB0aGUgY3VycmVudCBkYXRhIHJlcXVlc3QuIFNlZSBbTGlzdCBvZiBOb24tU3RhbmRhcmQgSFRUUCBIZWFkZXJzXXt7JSBzbHVnIHJlc3QtYXBpLWhlYWRlcnN9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGhlYWRlcnMgQWRkaXRpb25hbCBoZWFkZXJzIHRvIGJlIHNlbnQgd2l0aCB0aGUgZGF0YSByZXF1ZXN0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRhfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhIZWFkZXJzOiBmdW5jdGlvbiAoaGVhZGVycykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCdoZWFkZXJzJywgaGVhZGVycyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGFuIGV4cGFuZCBleHByZXNzaW9uIHRvIGJlIHVzZWQgaW4gdGhlIGRhdGEgcmVxdWVzdC4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIGNvbXBsZXggZGF0YSBzZXRzIHVzaW5nIGEgc2luZ2xlIHF1ZXJ5IGJhc2VkIG9uIHJlbGF0aW9ucyBiZXR3ZWVuIGRhdGEgdHlwZXMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBleHBhbmRFeHByZXNzaW9uIEFuIFtleHBhbmQgZXhwcmVzc2lvbl0oeyUgc2x1ZyBmZWF0dXJlcy1kYXRhLXJlbGF0aW9ucy1kZWZpbmluZy1leHBhbmQgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICB2YXIgZXhwYW5kSGVhZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtRXhwYW5kJzogSlNPTi5zdHJpbmdpZnkoZXhwYW5kRXhwcmVzc2lvbilcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2l0aEhlYWRlcnMoZXhwYW5kSGVhZGVyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYXBwbHlRdWVyeU9mZmxpbmU6IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXF1ZXJ5LmFwcGx5T2ZmbGluZSkge1xyXG4gICAgICAgICAgICAgICAgcXVlcnkub25FcnJvci5jYWxsKHRoaXMsIG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgYXBwbHlPZmZsaW5lIG11c3QgYmUgZmFsc2Ugd2hlbiB3b3JraW5nIG9mZmxpbmUuJykpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5vZmZsaW5lU3RvcmFnZS5wcm9jZXNzUXVlcnkocXVlcnkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vblN1Y2Nlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFdmVybGl2ZUVycm9yKGVyci5tZXNzYWdlLCBFdmVybGl2ZUVycm9ycy5nZW5lcmFsRGF0YWJhc2VFcnJvci5jb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vbkVycm9yLmNhbGwodGhpcywgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9zZW5kUmVxdWVzdDogZnVuY3Rpb24gKHF1ZXJ5LCBvbmxpbmUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU3VjY2VzcyA9IHF1ZXJ5Lm9uU3VjY2VzcztcclxuICAgICAgICAgICAgcXVlcnkub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmFwcGx5T2ZmbGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9hcHBseU9mZmxpbmUocXVlcnksIGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3VjY2Vzcy5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubGluZSAmJiBlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMub3BlcmF0aW9uTm90U3VwcG9ydGVkT2ZmbGluZS5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5vbkVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxTdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGdldFJlcXVlc3RPcHRpb25zRnJvbVF1ZXJ5ID0gUmVxdWVzdE9wdGlvbnNCdWlsZGVyW3F1ZXJ5Lm9wZXJhdGlvbl07XHJcbiAgICAgICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IGdldFJlcXVlc3RPcHRpb25zRnJvbVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0QWRkaXRpb25hbEhlYWRlcnMocXVlcnksIHJlcXVlc3RPcHRpb25zKTtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh0aGlzLnNldHVwLCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hcHBseVF1ZXJ5T25saW5lOiBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LnVzZUNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJsaXZlLmNhY2hlLl9jYWNoZURhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kUmVxdWVzdChxdWVyeSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0QWRkaXRpb25hbEhlYWRlcnM6IGZ1bmN0aW9uIChxdWVyeSwgcmVxdWVzdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LmlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVyc1tjb25zdGFudHMuSGVhZGVycy5zeW5jXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzZGtIZWFkZXJWYWx1ZSA9IHtcclxuICAgICAgICAgICAgICAgIHNkazogJ2pzJyxcclxuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiBldmVybGl2ZVBsYXRmb3JtXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzW2NvbnN0YW50cy5IZWFkZXJzLnNka10gPSBKU09OLnN0cmluZ2lmeShzZGtIZWFkZXJWYWx1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvY2Vzc2VzIGEgcXVlcnkgd2l0aCBhbGwgb2YgaXRzIG9wdGlvbnMuIEFwcGxpZXMgdGhlIG9wZXJhdGlvbiBvbmxpbmUvb2ZmbGluZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVF1ZXJ5fSBxdWVyeSBUaGUgcXVlcnkgdG8gcHJvY2Vzc1xyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtEYXRhUXVlcnl9IHF1ZXJ5XHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJvY2Vzc0RhdGFRdWVyeTogZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZsaW5lU3RvcmFnZUVuYWJsZWQgPSB0aGlzLmV2ZXJsaXZlLl9pc09mZmxpbmVTdG9yYWdlRW5hYmxlZCgpO1xyXG4gICAgICAgICAgICBxdWVyeS51c2VPZmZsaW5lID0gb2ZmbGluZVN0b3JhZ2VFbmFibGVkID8gIXRoaXMuZXZlcmxpdmUuaXNPbmxpbmUoKSA6IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfLmRlZmF1bHRzKHRoaXMub3B0aW9ucywgcXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc0NhY2hpbmdFbmFibGVkID0gKHRoaXMuZXZlcmxpdmUuc2V0dXAuY2FjaGluZyA9PT0gdHJ1ZSB8fCAodGhpcy5ldmVybGl2ZS5zZXR1cC5jYWNoaW5nICYmIHRoaXMuZXZlcmxpdmUuc2V0dXAuY2FjaGluZy5lbmFibGVkKSk7XHJcbiAgICAgICAgICAgIHZhciBpc1N1cHBvcnRlZEluT2ZmbGluZSA9IHV0aWxzLmlzUXVlcnlTdXBwb3J0ZWRPZmZsaW5lKHF1ZXJ5KTtcclxuXHJcbiAgICAgICAgICAgIHF1ZXJ5LnVzZUNhY2hlID0gaXNDYWNoaW5nRW5hYmxlZCAmJiAhcXVlcnkuaXNTeW5jICYmIGlzU3VwcG9ydGVkSW5PZmZsaW5lO1xyXG4gICAgICAgICAgICBxdWVyeS5hcHBseU9mZmxpbmUgPSBxdWVyeS5hcHBseU9mZmxpbmUgIT09IHVuZGVmaW5lZCA/IHF1ZXJ5LmFwcGx5T2ZmbGluZSA6IG9mZmxpbmVTdG9yYWdlRW5hYmxlZCB8fCBxdWVyeS51c2VDYWNoZTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcXVlcnkudXNlQ2FjaGUgJiYgcXVlcnkuZm9yY2VDYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgcXVlcnkub25FcnJvci5jYWxsKHRoaXMsIG5ldyBFdmVybGl2ZUVycm9yKEV2ZXJsaXZlRXJyb3JzLmNhbm5vdEZvcmNlQ2FjaGVXaGVuRGlzYWJsZWQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFxdWVyeS5za2lwQXV0aCAmJiB0aGlzLmV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uICYmIHRoaXMuZXZlcmxpdmUuYXV0aGVudGljYXRpb24uaXNBdXRoZW50aWNhdGlvbkluUHJvZ3Jlc3MoKSkge1xyXG4gICAgICAgICAgICAgICAgcXVlcnkub25FcnJvciA9IF8ud3JhcChxdWVyeS5vbkVycm9yLCBmdW5jdGlvbiAoZXJyb3JGdW5jLCBlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmludmFsaWRUb2tlbi5jb2RlIHx8IGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5leHBpcmVkVG9rZW4uY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2hlbkF1dGhlbnRpY2F0ZWRQcm9taXNlID0gc2VsZi5ldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5fZW5zdXJlQXV0aGVudGljYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyeS5ub1JldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuQXV0aGVudGljYXRlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRnVuYy5jYWxsKHNlbGYsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSBhcmUgY3VycmVudGx5IGF1dGhlbnRpY2F0aW5nLCBxdWV1ZSB0aGUgZGF0YSBxdWVyeSBhZnRlciB3ZSBoYXZlIGxvZ2dlZCBpblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZXZlcmxpdmUuYXV0aGVudGljYXRpb24uaXNBdXRoZW50aWNhdGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdoZW5BdXRoZW50aWNhdGVkUHJvbWlzZSA9IHNlbGYuZXZlcmxpdmUuYXV0aGVudGljYXRpb24uX2Vuc3VyZUF1dGhlbnRpY2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyeS5ub1JldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5BdXRoZW50aWNhdGVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aGVuQXV0aGVudGljYXRlZFByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgoIXF1ZXJ5LmlzU3luYyAmJiB0aGlzLm9mZmxpbmVTdG9yYWdlICYmIHRoaXMub2ZmbGluZVN0b3JhZ2UuaXNTeW5jaHJvbml6aW5nKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeS5vbkVycm9yLmNhbGwodGhpcywgbmV3IEV2ZXJsaXZlRXJyb3IoRXZlcmxpdmVFcnJvcnMuc3luY0luUHJvZ3Jlc3MpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChxdWVyeS51c2VPZmZsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVF1ZXJ5T2ZmbGluZShxdWVyeSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVF1ZXJ5T25saW5lKHF1ZXJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgb3B0aW9uczogeyByZXF1ZXN0U2V0dGluZ3M6IHsgZXhlY3V0ZVNlcnZlckNvZGU6IGZhbHNlIH0gfS4gcG93ZXIgZmllbGRzIHF1ZXJpZXMgY291bGQgYmUgYWRkZWQgdG8gdGhhdCBvcHRpb25zIGFyZ3VtZW50XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRcclxuICAgICAgICAgKiBAbmFtZSBnZXRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRcclxuICAgICAgICAgKiBAbmFtZSBnZXRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChmaWx0ZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NDYixcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvckNiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFRPRE8gaGFuZGxlIG9wdGlvbnNcclxuICAgICAgICAvLyBUT0RPIHRoaW5rIHRvIHBhc3MgdGhlIGlkIGFzIGEgZmlsdGVyXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSBkYXRhIGl0ZW0gYnkgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRCeUlkXHJcbiAgICAgICAgICogQG5hbWUgZ2V0QnlJZFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gaXRlbSBieSBJRC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldEJ5SWRcclxuICAgICAgICAgKiBAbmFtZSBnZXRCeUlkXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgIGdldEJ5SWQ6IGZ1bmN0aW9uIChpZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkQnlJZCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2Vzc0NiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yQ2JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjb3VudCBvZiB0aGUgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjb3VudFxyXG4gICAgICAgICAqIEBuYW1lIGNvdW50XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNvdW50IG9mIHRoZSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjb3VudFxyXG4gICAgICAgICAqIEBuYW1lIGNvdW50XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY291bnQ6IGZ1bmN0aW9uIChmaWx0ZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5jb3VudCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Vzc0NiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yQ2JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICAgICAqIEBuYW1lIGNyZWF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBkYXRhIEl0ZW0gb3IgaXRlbXMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAgICAgKiBAbmFtZSBjcmVhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gZGF0YSBUaGUgaXRlbSBvciBpdGVtcyB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzczogbWVyZ2VSZXN1bHREYXRhKGRhdGEsIHN1Y2Nlc3MpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFsbCBvYmplY3RzIHRoYXQgbWF0Y2ggYSBmaWx0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBleHByZXNzaW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgcmF3VXBkYXRlXHJcbiAgICAgICAgICogQG5hbWUgcmF3VXBkYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHVwZGF0ZU9iamVjdCBVcGRhdGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG5ldyB2YWx1ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIG9iamVjdHMgdGhhdCBtYXRjaCBhIGZpbHRlciB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByYXdVcGRhdGVcclxuICAgICAgICAgKiBAbmFtZSByYXdVcGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFVwZGF0ZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHZhbHVlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFuIG9iamVjdCBieSBJRCB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByYXdVcGRhdGVcclxuICAgICAgICAgKiBAbmFtZSByYXdVcGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlZE9iamVjdCBVcGRhdGVkIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgdmFsdWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFuIG9iamVjdCBieSBJRCB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByYXdVcGRhdGVcclxuICAgICAgICAgKiBAbmFtZSByYXdVcGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFVwZGF0ZWQgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG5ldyB2YWx1ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmF3VXBkYXRlOiBmdW5jdGlvbiAoYXR0cnMsIGZpbHRlciwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJhd1VwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBhdHRycyxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGVyZSBpcyBhIGNhc2UgaW4gd2hpY2ggcmVwbGFjZSA9IHRydWUgaXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb25cclxuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbiAoYXR0cnMsIGZpbHRlciwgc2luZ2xlLCByZXBsYWNlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgICAgIGRhdGFbcmVwbGFjZSA/ICckcmVwbGFjZScgOiAnJHNldCddID0gYXR0cnM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHVwZGF0ZSBpcyBmb3IgYSBzaW5nbGUgaXRlbSAtIG1lcmdlIHRoZSB1cGRhdGUgcmVzdWx0IGFuZCBhZGQgdGhlIE1vZGlmaWVkQXQgZmllbGQgdG8gdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgdmFyIG9uU3VjY2VzcyA9IHNpbmdsZSA/IG1lcmdlVXBkYXRlUmVzdWx0RGF0YShhdHRycywgc3VjY2VzcykgOiBzdWNjZXNzO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnVwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzaW5nbGUgPyBhdHRyc1tpZEZpZWxkXSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBvblN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBhIHNpbmdsZSBkYXRhIGl0ZW0uIFRoaXMgb3BlcmF0aW9uIHRha2VzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBib3RoIHRoZSBkYXRhIGl0ZW0gdG8gYmUgdXBkYXRlZCBhbmQgdGhlIHVwZGF0ZWQgdmFsdWVzLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlU2luZ2xlXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlU2luZ2xlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSB1cGRhdGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcHJvdmlkZWQgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVNpbmdsZVxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVNpbmdsZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBUaGUgaXRlbSB0aGF0IHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZVNpbmdsZTogZnVuY3Rpb24gKG1vZGVsLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKG1vZGVsLCBudWxsLCB0cnVlLCBmYWxzZSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIGl0ZW1zIHRoYXQgbWF0Y2ggYSBmaWx0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFRoZSB1cGRhdGUgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFsbCBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbW9kZWwgVGhlIHVwZGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobW9kZWwsIGZpbHRlciwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZShtb2RlbCwgZmlsdGVyLCBmYWxzZSwgZmFsc2UsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoYXR0cnMsIGZpbHRlciwgc2luZ2xlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogc2luZ2xlID8gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlIDogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogc2luZ2xlID8gYXR0cnNbaWRGaWVsZF0gOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZXMgYSBzaW5nbGUgZGF0YSBpdGVtIGJ5IElELlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVNpbmdsZVxyXG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lTaW5nbGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBPYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSBJRCB0byBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIHNpbmdsZSBkYXRhIGl0ZW0gYnkgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBkZXN0cm95U2luZ2xlXHJcbiAgICAgICAgICogQG5hbWUgZGVzdHJveVNpbmdsZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBPYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSBJRCB0byBiZSBkZWxldGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZXN0cm95U2luZ2xlOiBmdW5jdGlvbiAobW9kZWwsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95KG1vZGVsLCBudWxsLCB0cnVlLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIGEgZmlsdGVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhbGwgaXRlbXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzdHJveShudWxsLCBmaWx0ZXIsIGZhbHNlLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIEFDTCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSB1cGRhdGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIEFDTCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSB1cGRhdGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRpb25QYXJhbWV0ZXJzIEFuIG9iamVjdCB0aGF0IGFjY2VwdHMgb3BlcmF0aW9uIHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIEFjY2VzcyBDb250cm9sIExpc3QgKEFDTCkgb2YgYSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QWNsXHJcbiAgICAgICAgICogQG5hbWUgc2V0QWNsXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFjbCBUaGUgYWNsIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhbiBpdGVtIHdpdGggYSBzcGVjaWZpZWQgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldEFjbDogZnVuY3Rpb24gKGFjbCwgZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0QWNsLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjbDogYWNsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIG93bmVyIG9mIHRoZSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0T3duZXJcclxuICAgICAgICAgKiBAbmFtZSBzZXRPd25lclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2wgVGhlIG5ldyBvd25lciBJRC5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBUaGUgaXRlbSB3aG9zZSBvd25lciB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSB1cGRhdGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgb3duZXIgb2YgdGhlIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRPd25lclxyXG4gICAgICAgICAqIEBuYW1lIHNldE93bmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFjbCBUaGUgbmV3IG93bmVyIElELlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIG93bmVyIHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvblBhcmFtZXRlcnMgQW4gb2JqZWN0IHRoYXQgYWNjZXB0cyBvcGVyYXRpb24gcGFyYW1ldGVycy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5zdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMudXNlT2ZmbGluZV0gV2hldGhlciB0byBpbnZva2UgdGhlIG9wZXJhdGlvbiBvbiB0aGUgb2ZmbGluZSBzdG9yYWdlLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIEV2ZXJsaXZlIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuYXBwbHlPZmZsaW5lPXRydWVdIElmIHdvcmtpbmcgb25saW5lLCB3aGV0aGVyIHRvIGFsc28gYXBwbHkgdGhlIG9wZXJhdGlvbiBvbiB0aGUgbG9jYWwgc3RvcmFnZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBvd25lciBvZiB0aGUgc3BlY2lmaWVkIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNldE93bmVyXHJcbiAgICAgICAgICogQG5hbWUgc2V0T3duZXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3duZXJJZCBUaGUgbmV3IG93bmVyIElELlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBvd25lciBvZiB0aGUgc3BlY2lmaWVkIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNldE93bmVyXHJcbiAgICAgICAgICogQG5hbWUgc2V0T3duZXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3duZXJJZCBUaGUgbmV3IG93bmVyIElELlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldE93bmVyOiBmdW5jdGlvbiAob3duZXJJZCwgZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0T3duZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPd25lcjogb3duZXJJZFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2F2ZXMgdGhlIHByb3ZpZGVkIGRhdGEgaXRlbS4gVGhpcyBvcGVyYXRpb24gd2lsbCBjcmVhdGUgb3IgdXBkYXRlIHRoZSBpdGVtIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIG5ldyBvciBleGlzdGluZy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNhdmVcclxuICAgICAgICAgKiBAbmFtZSBzYXZlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBzYXZlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhdmVzIHRoZSBwcm92aWRlZCBkYXRhIGl0ZW0uIFRoaXMgb3BlcmF0aW9uIHdpbGwgY3JlYXRlIG9yIHVwZGF0ZSB0aGUgaXRlbSBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBuZXcgb3IgZXhpc3RpbmcuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzYXZlXHJcbiAgICAgICAgICogQG5hbWUgc2F2ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSB0aGF0IGlzIGJlaW5nIHNhdmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzYXZlOiBmdW5jdGlvbiAobW9kZWwsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGlzTmV3ID0gdGhpcy5pc05ldyhtb2RlbCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2F2ZVN1Y2Nlc3MocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnR5cGUgPSBpc05ldyA/ICdjcmVhdGUnIDogJ3VwZGF0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhyZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNhdmVFcnJvcihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnIudHlwZSA9IGlzTmV3ID8gJ2NyZWF0ZScgOiAndXBkYXRlJztcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc05ldykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNyZWF0ZShtb2RlbCwgc2F2ZVN1Y2Nlc3MsIHNhdmVFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnVwZGF0ZVNpbmdsZShtb2RlbCwgc2F2ZVN1Y2Nlc3MsIHNhdmVFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGRhdGEgaXRlbSBpcyBuZXcgb3Igbm90LlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAcGFyYW0gbW9kZWwgSXRlbSB0byBjaGVjay5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc05ldzogZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbW9kZWxbaWRGaWVsZF0gPT09ICd1bmRlZmluZWQnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIERhdGE7XHJcbn0oKSk7XHJcbiIsIi8qKlxyXG4gKiBAY2xhc3MgRmlsZXNcclxuICogQHByb3RlY3RlZFxyXG4gKiBAZXh0ZW5kcyBEYXRhXHJcbiAqL1xyXG5cclxudmFyIGJ1aWxkUHJvbWlzZSA9IHJlcXVpcmUoJy4uL3V0aWxzJykuYnVpbGRQcm9taXNlO1xyXG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuYWRkRmlsZXNGdW5jdGlvbnMgPSBmdW5jdGlvbiBhZGRGaWxlc0Z1bmN0aW9ucyhucykge1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBVUkwgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBlbmRwb2ludCBmb3IgdXBsb2FkaW5nIGEgZmlsZS4gSXQgaXMgc3BlY2lmaWMgdG8gZWFjaCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGFwcC5cclxuICAgICAqIEBtZW1iZXJvZiBGaWxlcy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgZ2V0VXBsb2FkVXJsXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBucy5nZXRVcGxvYWRVcmwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHRoaXMuc2V0dXApICsgdGhpcy5jb2xsZWN0aW9uTmFtZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRvd25sb2FkIFVSTCBmb3IgYSBmaWxlLlxyXG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBnZXREb3dubG9hZFVybFxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBzZWUge0BsaW5rIEZpbGVzLmdldERvd25sb2FkVXJsQnlJZH1cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgVGhlIElEIG9mIHRoZSBmaWxlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdXJsIFRoZSBkb3dubG9hZCBVUkwuXHJcbiAgICAgKi9cclxuICAgIG5zLmdldERvd25sb2FkVXJsID0gZnVuY3Rpb24gKGZpbGVJZCkge1xyXG4gICAgICAgIHJldHVybiB1dGlscy5idWlsZFVybCh0aGlzLnNldHVwKSArIHRoaXMuY29sbGVjdGlvbk5hbWUgKyAnLycgKyBmaWxlSWQgKyAnL0Rvd25sb2FkJztcclxuICAgIH07XHJcblxyXG4gICAgbnMuX2dldFVwZGF0ZVVybCA9IGZ1bmN0aW9uIChmaWxlSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uTmFtZSArICcvJyArIGZpbGVJZCArICcvQ29udGVudCc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgVVJMIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gZW5kcG9pbnQgZm9yIHVwZGF0aW5nIGEgZmlsZS4gSXQgaXMgc3BlY2lmaWMgdG8gZWFjaCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGFwcC5cclxuICAgICAqIEBtZW1iZXJvZiBGaWxlcy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgZ2V0VXBkYXRlVXJsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHVybCBUaGUgdXBkYXRlIFVSTC5cclxuICAgICAqL1xyXG4gICAgbnMuZ2V0VXBkYXRlVXJsID0gZnVuY3Rpb24gKGZpbGVJZCkge1xyXG4gICAgICAgIHJldHVybiB1dGlscy5idWlsZFVybCh0aGlzLnNldHVwKSArIHRoaXMuX2dldFVwZGF0ZVVybChmaWxlSWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgYSBmaWxlJ3MgY29udGVudFxyXG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVDb250ZW50XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIEZpbGUgSUQuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZSBUaGUgZmlsZSBtZXRhZGF0YSBhbmQgdGhlIGJhc2U2NCBlbmNvZGVkIGZpbGUgY29udGVudC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBucy51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gKGZpbGVJZCwgZmlsZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNVcGRhdGVDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhc3NlZCBmaWxlIGNvbnRlbnQgaXMgYmFzZTY0IGVuY29kZWRcclxuICAgICAgICAgICAgICAgIGRhdGE6IGZpbGUsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVJZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZG93bmxvYWQgVVJMIGZvciBhIGZpbGUgYnkgSUQuXHJcbiAgICAgKiBAbWVtYmVyb2YgRmlsZXMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGdldERvd25sb2FkVXJsQnlJZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZCBGaWxlIElELlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRvd25sb2FkIFVSTCBmb3IgYSBmaWxlIGJ5IElELlxyXG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBnZXREb3dubG9hZFVybEJ5SWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgRmlsZSBJRC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5nZXREb3dubG9hZFVybEJ5SWQgPSBmdW5jdGlvbiAoZmlsZUlkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5maWxlc0dldERvd25sb2FkVXJsQnlJZCxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUlkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhkYXRhLnJlc3VsdC5VcmkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIG5zLmRvd25sb2FkID0gZnVuY3Rpb24gKHVybCwgbG9jYWxQYXRoLCBvcHRpb25zLCB0cnVzdEFsbEhvc3RzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmICghdHJ1c3RBbGxIb3N0cykge1xyXG4gICAgICAgICAgICAgICAgdHJ1c3RBbGxIb3N0cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZmlsZVRyYW5zZmVyID0gbmV3IEZpbGVUcmFuc2ZlcigpO1xyXG4gICAgICAgICAgICBmaWxlVHJhbnNmZXIuZG93bmxvYWQodXJsLCBsb2NhbFBhdGgsIHN1Y2Nlc3MsIGVycm9yLCB0cnVzdEFsbEhvc3RzLCBvcHRpb25zKTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIG5zLnVwbG9hZCA9IGZ1bmN0aW9uIChsb2NhbFBhdGgsIHVybCwgb3B0aW9ucywgdHJ1c3RBbGxIb3N0cywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoIXRydXN0QWxsSG9zdHMpIHtcclxuICAgICAgICAgICAgICAgIHRydXN0QWxsSG9zdHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZmlsZVRyYW5zZmVyID0gbmV3IEZpbGVUcmFuc2ZlcigpO1xyXG4gICAgICAgICAgICB2YXIgdXJpID0gZW5jb2RlVVJJKHVybCk7XHJcbiAgICAgICAgICAgIGZpbGVUcmFuc2Zlci51cGxvYWQobG9jYWxQYXRoLCB1cmksIHN1Y2Nlc3MsIGVycm9yLCBvcHRpb25zLCB0cnVzdEFsbEhvc3RzKTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9XHJcbn07IiwiLyoqXHJcbiAqIEBjbGFzcyBVc2Vyc1xyXG4gKiBAZXh0ZW5kcyBEYXRhXHJcbiAqIEBwcm90ZWN0ZWRcclxuICovXHJcblxyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG52YXIgYnVpbGRQcm9taXNlID0gdXRpbHMuYnVpbGRQcm9taXNlO1xyXG52YXIgZ3VhcmRVbnNldCA9IHV0aWxzLmd1YXJkVW5zZXQ7XHJcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9EYXRhUXVlcnknKTtcclxudmFyIFJlcXVlc3QgPSByZXF1aXJlKCcuLi9SZXF1ZXN0Jyk7XHJcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIEV2ZXJsaXZlRXJyb3JzID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3JzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuYWRkVXNlcnNGdW5jdGlvbnMgPSBmdW5jdGlvbiBhZGRVc2Vyc0Z1bmN0aW9ucyhucywgZXZlcmxpdmUpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyB1c2VyIHdpdGggdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgbmV3IHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgbmV3IHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1c2VySW5mbyBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciB0aGUgdXNlciAoZXguIERpc3BsYXlOYW1lLCBFbWFpbCwgZXRjLilcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcclxuICAgICAqIEBuYW1lIHJlZ2lzdGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIG5ldyB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIG5ldyB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0gYXR0cnNcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5yZWdpc3RlciA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIGF0dHJzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIGd1YXJkVW5zZXQodXNlcm5hbWUsICd1c2VybmFtZScpO1xyXG4gICAgICAgIGd1YXJkVW5zZXQocGFzc3dvcmQsICdwYXNzd29yZCcpO1xyXG4gICAgICAgIHZhciB1c2VyID0ge1xyXG4gICAgICAgICAgICBVc2VybmFtZTogdXNlcm5hbWUsXHJcbiAgICAgICAgICAgIFBhc3N3b3JkOiBwYXNzd29yZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXy5leHRlbmQodXNlciwgYXR0cnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh1c2VyLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlciB0aGF0IGlzIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHRvIHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESy4gVGhlIHN1Y2Nlc3MgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGgge0BsaW5rIFVzZXJzLlJlc3VsdFR5cGVzLmN1cmVudFVzZXJSZXN1bHR9LlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBjdXJyZW50VXNlclxyXG4gICAgICogQG5hbWUgY3VycmVudFVzZXJcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlciB0aGF0IGlzIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHRvIHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESy4gVGhlIHN1Y2Nlc3MgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGgge0BsaW5rIFVzZXJzLlJlc3VsdFR5cGVzLmN1cmVudFVzZXJSZXN1bHR9LlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBjdXJyZW50VXNlclxyXG4gICAgICogQG5hbWUgY3VycmVudFVzZXJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5jdXJyZW50VXNlciA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgaWQgPSBzZWxmLmV2ZXJsaXZlLl9pc09mZmxpbmVTdG9yYWdlRW5hYmxlZCgpICYmIHNlbGYuZXZlcmxpdmUuaXNPZmZsaW5lKCkgPyBzZWxmLmV2ZXJsaXZlLnNldHVwLnByaW5jaXBhbElkIDogJ21lJztcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoaWQgPT09ICdtZScgJiYgIXNlbGYuZXZlcmxpdmUuc2V0dXAudG9rZW4gJiYgIXNlbGYuZXZlcmxpdmUuc2V0dXAubWFzdGVyS2V5IHx8ICFpZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3Jlc3VsdDogbnVsbH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLmdldEJ5SWQoaWQpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzLnJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiByZXMucmVzdWx0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiBudWxsfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5ldmVybGl2ZS5hdXRoZW50aWNhdGlvbiAmJiBzZWxmLmV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiBudWxsfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gNjAxKSB7IC8vIGludmFsaWQgcmVxdWVzdCwgaS5lLiB0aGUgYWNjZXNzIHRva2VuIGlzIG1pc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiBudWxsfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gODAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFdmVybGl2ZUVycm9yKEV2ZXJsaXZlRXJyb3JzLmludmFsaWRUb2tlbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBwYXNzd29yZCBvZiBhIHVzZXIuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGNoYW5nZVBhc3N3b3JkXHJcbiAgICAgKiBAbmFtZSBjaGFuZ2VQYXNzd29yZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYXNzd29yZCBUaGUgdXNlcidzIG5ldyBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFRva2VucyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgdG9rZW5zIHdpbGwgYmUgcHJlc2VydmVkIGV2ZW4gYWZ0ZXIgdGhlIHBhc3N3b3JkIGNoYW5nZS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgcGFzc3dvcmQgb2YgYSB1c2VyLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBjaGFuZ2VQYXNzd29yZFxyXG4gICAgICogQG5hbWUgY2hhbmdlUGFzc3dvcmRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgdXNlcidzIHVzZXJuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UGFzc3dvcmQgVGhlIHVzZXIncyBuZXcgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBUb2tlbnMgSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIHRva2VucyB3aWxsIGJlIHByZXNlcnZlZCBldmVuIGFmdGVyIHRoZSBwYXNzd29yZCBjaGFuZ2UuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMuY2hhbmdlUGFzc3dvcmQgPSBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkLCBuZXdQYXNzd29yZCwga2VlcFRva2Vucywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgc3VjY2VzcyA9IF8ud3JhcChzdWNjZXNzLCBmdW5jdGlvbiAoc3VjY2VzcywgZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5yZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWtlZXBUb2tlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnMuY2xlYXJBdXRob3JpemF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3MoZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyQ2hhbmdlUGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBVc2VybmFtZTogdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgUGFzc3dvcmQ6IHBhc3N3b3JkLFxyXG4gICAgICAgICAgICAgICAgICAgIE5ld1Bhc3N3b3JkOiBuZXdQYXNzd29yZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAga2VlcFRva2Vuczoga2VlcFRva2Vuc1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSlcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcilcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gQWxsIHJlcXVlc3RzIGluaXRpYXRlZCBieSB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZSB3aWxsIGJlIGF1dGhlbnRpY2F0ZWQgd2l0aCB0aGF0IHVzZXIncyBjcmVkZW50aWFscy5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5cclxuICAgICAqIEBuYW1lIGxvZ2luXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmxvZ2lufVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gQWxsIHJlcXVlc3RzIGluaXRpYXRlZCBieSB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZSB3aWxsIGJlIGF1dGhlbnRpY2F0ZWQgd2l0aCB0aGF0IHVzZXIncyBjcmVkZW50aWFscy5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5cclxuICAgICAqIEBuYW1lIGxvZ2luXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmxvZ2lufVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5sb2dpbiA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLmxvZ2luKHVzZXJuYW1lLCBwYXNzd29yZCwgc3VjY2VzcywgZXJyb3IpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dvdXRcclxuICAgICAqIEBuYW1lIGxvZ291dFxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBzZWUgW2F1dGhlbnRpY2F0aW9uLmxvZ2luXXtAbGluayAuLi9BdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5sb2dvdXR9XHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBvdXQgdGhlIHVzZXIgd2hvIGlzIGN1cnJlbnRseSBsb2dnZWQgaW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ291dFxyXG4gICAgICogQG5hbWUgbG9nb3V0XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmxvZ291dH1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5sb2dvdXQgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9nb3V0KHN1Y2Nlc3MsIGVycm9yKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhGYWNlYm9va1xyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBzZWUgW2F1dGhlbnRpY2F0aW9uLmxvZ2luXXtAbGluayAuLi9BdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhGYWNlYm9va31cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhGYWNlYm9va1xyXG4gICAgICogQG5hbWUgbG9naW5XaXRoRmFjZWJvb2tcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24ubG9naW5XaXRoRmFjZWJvb2t9XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxvZ2luV2l0aEZhY2Vib29rID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhGYWNlYm9vayhhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYSBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoRmFjZWJvb2tcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgRmFjZWJvb2sgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSBCYWNrZW5kIFNlcnZpY2VzIHVzZXIgd2l0aCBhIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhGYWNlYm9va1xyXG4gICAgICogQG5hbWUgbGlua1dpdGhGYWNlYm9va1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBGYWNlYm9vayBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIGEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5saW5rV2l0aEZhY2Vib29rID0gZnVuY3Rpb24gKHVzZXJJZCwgYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0ZhY2Vib29rJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBGYWNlYm9vayB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUZhY2Vib29rXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tRmFjZWJvb2tcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEZhY2Vib29rIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21GYWNlYm9va1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21GYWNlYm9vayA9IGZ1bmN0aW9uICh1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5zLl91bmxpbmtGcm9tUHJvdmlkZXIoJ0ZhY2Vib29rJywgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoQURGU1xyXG4gICAgICogQG5hbWUgbG9naW5XaXRoQURGU1xyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBzZWUgW2F1dGhlbnRpY2F0aW9uLmxvZ2luXXtAbGluayAuLi9BdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhBREZTfVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhBREZTXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhBREZTXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aEFERlN9XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubG9naW5XaXRoQURGUyA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9naW5XaXRoQURGUyhhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoQURGU1xyXG4gICAgICogQG5hbWUgbGlua1dpdGhBREZTXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIEFERlMgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhBREZTXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgQURGUyBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoQURGUyA9IGZ1bmN0aW9uICh1c2VySWQsIGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdBREZTJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBBREZTIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tQURGU1xyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEFERlMgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21BREZTXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tQURGU1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21BREZTID0gZnVuY3Rpb24gKHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gbnMuX3VubGlua0Zyb21Qcm92aWRlcignQURGUycsIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBNaWNyb3NvZnQgQWNjb3VudCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aExpdmVJRH1cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBNaWNyb3NvZnQgQWNjb3VudCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBNaWNyb3NvZnQgQWNjb3VudCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aExpdmVJRH1cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBNaWNyb3NvZnQgQWNjb3VudCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubG9naW5XaXRoTGl2ZUlEID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhMaXZlSUQoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IHRvIGEgTWljcm9zb2Z0IEFjY291bnQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aExpdmVJRFxyXG4gICAgICogQG5hbWUgbGlua1dpdGhMaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgTWljcm9zb2Z0IEFjY291bnQgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIE1pY3Jvc29mdCBBY2NvdW50IGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhMaXZlSURcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoTGl2ZUlEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIE1pY3Jvc29mdCBBY2NvdW50IGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubGlua1dpdGhMaXZlSUQgPSBmdW5jdGlvbiAodXNlcklkLCBhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnTGl2ZUlEJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBNaWNyb3NvZnQgQWNjb3VudCBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21MaXZlSURcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21MaXZlSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIE1pY3Jvc29mdCBBY2NvdW50IGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUxpdmVJRFxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUxpdmVJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21MaXZlSUQgPSBmdW5jdGlvbiAodXNlcklkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdMaXZlSUQnLCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhHb29nbGVcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24ubG9naW5XaXRoR29vZ2xlfVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhHb29nbGVcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEdvb2dsZVxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBzZWUgW2F1dGhlbnRpY2F0aW9uLmxvZ2luXXtAbGluayAuLi9BdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhHb29nbGV9XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5sb2dpbldpdGhHb29nbGUgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aEdvb2dsZShhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYSBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbGlua1dpdGhHb29nbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgR29vZ2xlIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYSBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbGlua1dpdGhHb29nbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgR29vZ2xlIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubGlua1dpdGhHb29nbGUgPSBmdW5jdGlvbiAodXNlcklkLCBhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnR29vZ2xlJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5zLl9saW5rV2l0aFByb3ZpZGVyKGlkZW50aXR5LCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgR29vZ2xlIGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUdvb2dsZVxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUdvb2dsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgR29vZ2xlIGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUdvb2dsZVxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUdvb2dsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21Hb29nbGUgPSBmdW5jdGlvbiAodXNlcklkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdHb29nbGUnLCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHdpdGggYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFR3aXR0ZXIgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVHdpdHRlciBzZWNyZXQgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVHdpdHRlciB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblNlY3JldCBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5sb2dpbldpdGhUd2l0dGVyID0gZnVuY3Rpb24gKHRva2VuLCB0b2tlblNlY3JldCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9naW5XaXRoVHdpdHRlcih0b2tlbiwgdG9rZW5TZWNyZXQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciB0byBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aFR3aXR0ZXJcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSBUd2l0dGVyIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVGhlIFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciB0byBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLiAgICAgICAgICogTGlua3MgYSBCYWNrZW5kIFNlcnZpY2VzIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aFR3aXR0ZXJcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSBUd2l0dGVyIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVGhlIFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoVHdpdHRlciA9IGZ1bmN0aW9uICh1c2VySWQsIHRva2VuLCB0b2tlblNlY3JldCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnVHdpdHRlcicsXHJcbiAgICAgICAgICAgIFRva2VuOiB0b2tlbixcclxuICAgICAgICAgICAgVG9rZW5TZWNyZXQ6IHRva2VuU2VjcmV0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5zLl9saW5rV2l0aFByb3ZpZGVyKGlkZW50aXR5LCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21Ud2l0dGVyXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21Ud2l0dGVyXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21Ud2l0dGVyID0gZnVuY3Rpb24gKHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gbnMuX3VubGlua0Zyb21Qcm92aWRlcignVHdpdHRlcicsIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIHRoYXQgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgd2lsbCB1c2UgZm9yIGF1dGhvcml6YXRpb24uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHNldEF1dGhvcml6YXRpb25cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24uc2V0QXV0aG9yaXphdGlvbn1cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlbiB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYXV0aG9yaXphdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuVG9rZW5UeXBlfSB0b2tlblR5cGUgVG9rZW4gdHlwZS4gQ3VycmVudGx5IG9ubHkgJ2JlYXJlcicgdG9rZW4gaXMgc3VwcG9ydGVkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaW5jaXBhbElkIFRoZSBpZCBvZiB0aGUgdXNlciB0aGF0IGlzIGxvZ2dlZCBpbi5cclxuICAgICAqL1xyXG4gICAgbnMuc2V0QXV0aG9yaXphdGlvbiA9IGZ1bmN0aW9uIHNldEF1dGhvcml6YXRpb24odG9rZW4sIHRva2VuVHlwZSwgcHJpbmNpcGFsSWQpIHtcclxuICAgICAgICBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5zZXRBdXRob3JpemF0aW9uKHRva2VuLCB0b2tlblR5cGUsIHByaW5jaXBhbElkKVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4gdGhhdCB0aGUge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgY3VycmVudGx5IHVzZXMuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCB0aGFuIGxvZ2dpbmcgb3V0LCBiZWNhdXNlIHRoZSBjdXJyZW50IGF1dGhvcml6YXRpb24gdG9rZW4gaXMgbm90IGludmFsaWRhdGVkLlxyXG4gICAgICogQG1ldGhvZCBjbGVhckF1dGhvcml6YXRpb25cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24uY2xlYXJBdXRob3JpemF0aW9ufVxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICovXHJcbiAgICBucy5jbGVhckF1dGhvcml6YXRpb24gPSBmdW5jdGlvbiBjbGVhckF1dGhvcml6YXRpb24oKSB7XHJcbiAgICAgICAgZXZlcmxpdmUuYXV0aGVudGljYXRpb24uc2V0QXV0aG9yaXphdGlvbihudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBhIHBhc3N3b3JkIHJlc2V0IGVtYWlsIHRvIGEgc3BlY2lmaWVkIHVzZXIuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHJlc2V0UGFzc3dvcmRcclxuICAgICAqIEBuYW1lIHJlc2V0UGFzc3dvcmRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyIFRoZSB1c2VyIG9iamVjdCwgd2hpY2ggbXVzdCBjb250YWluZXIgZWl0aGVyIHVzZXJuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgZW1haWwgdG8gYSBzcGVjaWZpZWQgdXNlci5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgcmVzZXRQYXNzd29yZFxyXG4gICAgICogQG5hbWUgcmVzZXRQYXNzd29yZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXIgVGhlIHVzZXIgb2JqZWN0LCB3aGljaCBtdXN0IGNvbnRhaW5lciBlaXRoZXIgdXNlcm5hbWUgb3IgZW1haWwgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5yZXNldFBhc3N3b3JkID0gZnVuY3Rpb24gKHVzZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyUmVzZXRQYXNzd29yZCxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogdXNlcixcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2Vzc0NiLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JDYlxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgbmV3IHBhc3N3b3JkIGZvciBhIHVzZXIgdXNpbmcgYSBwYXNzd29yZCByZXNldCBjb2RlLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBzZXRQYXNzd29yZFxyXG4gICAgICogQG5hbWUgc2V0UGFzc3dvcmRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXRQYXNzd29yZE9iamVjdCBUaGUgb2JqZWN0LCB3aGljaCBjb250YWlucyBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgZm9yIGNoYW5naW5nIHRoZSB1c2VyIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNldFBhc3N3b3JkT2JqZWN0LlJlc2V0Q29kZSBUaGUgcmVzZXQgY29kZSBvYnRhaW5lZCB1c2luZyBhIHBhc3N3b3JkIHJlc2V0IGVtYWlsLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNldFBhc3N3b3JkT2JqZWN0Lk5ld1Bhc3N3b3JkIFRoZSBuZXcgcGFzc3dvcmQgZm9yIHRoZSB1c2VyLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBuZXcgcGFzc3dvcmQgZm9yIGEgdXNlciB1c2luZyBhIHBhc3N3b3JkIHJlc2V0IGNvZGUuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHNldFBhc3N3b3JkXHJcbiAgICAgKiBAbmFtZSBzZXRQYXNzd29yZFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldFBhc3N3b3JkT2JqZWN0IFRoZSBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSBmb3IgY2hhbmdpbmcgdGhlIHVzZXIgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0UGFzc3dvcmRPYmplY3QuUmVzZXRDb2RlIFRoZSByZXNldCBjb2RlIG9idGFpbmVkIHVzaW5nIGEgcGFzc3dvcmQgcmVzZXQgZW1haWwuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0UGFzc3dvcmRPYmplY3QuTmV3UGFzc3dvcmQgVGhlIG5ldyBwYXNzd29yZCBmb3IgdGhlIHVzZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBuZXcgcGFzc3dvcmQgZm9yIGEgdXNlciB1c2luZyBhIHBhc3N3b3JkIHJlc2V0IGNvZGUuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHNldFBhc3N3b3JkXHJcbiAgICAgKiBAbmFtZSBzZXRQYXNzd29yZFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldFBhc3N3b3JkT2JqZWN0IFRoZSBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSBmb3IgY2hhbmdpbmcgdGhlIHVzZXIgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2V0UGFzc3dvcmRPYmplY3QuVXNlcm5hbWUgVGhlIHVzZXJuYW1lIHRoYXQgdGhlIHBhc3N3b3JkIHdpbGwgYmUgY2hhbmdlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZXRQYXNzd29yZE9iamVjdC5TZWNyZXRRdWVzdGlvbklkIFRoZSBpZCBvZiB0aGUgc2VjcmV0IHF1ZXN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNldFBhc3N3b3JkT2JqZWN0LlNlY3JldEFuc3dlciBUaGUgYW5zd2VyIHRvIHRoZSBzZWNyZXQgcXVlc3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0UGFzc3dvcmRPYmplY3QuTmV3UGFzc3dvcmQgVGhlIG5ldyBwYXNzd29yZCBmb3IgdGhlIHVzZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIG5ldyBwYXNzd29yZCBmb3IgYSB1c2VyIHVzaW5nIGEgcGFzc3dvcmQgcmVzZXQgY29kZS5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2Qgc2V0UGFzc3dvcmRcclxuICAgICAqIEBuYW1lIHNldFBhc3N3b3JkXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0UGFzc3dvcmRPYmplY3QgVGhlIG9iamVjdCwgd2hpY2ggY29udGFpbnMgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IGZvciBjaGFuZ2luZyB0aGUgdXNlciBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZXRQYXNzd29yZE9iamVjdC5Vc2VybmFtZSBUaGUgdXNlcm5hbWUgdGhhdCB0aGUgcGFzc3dvcmQgd2lsbCBiZSBjaGFuZ2VkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNldFBhc3N3b3JkT2JqZWN0LlNlY3JldFF1ZXN0aW9uSWQgVGhlIGlkIG9mIHRoZSBzZWNyZXQgcXVlc3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0UGFzc3dvcmRPYmplY3QuU2VjcmV0QW5zd2VyIFRoZSBhbnN3ZXIgdG8gdGhlIHNlY3JldCBxdWVzdGlvbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXRQYXNzd29yZE9iamVjdC5OZXdQYXNzd29yZCBUaGUgbmV3IHBhc3N3b3JkIGZvciB0aGUgdXNlci5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5zZXRQYXNzd29yZCA9IGZ1bmN0aW9uIChzZXRQYXNzd29yZE9iamVjdCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xyXG4gICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJTZXRQYXNzd29yZCxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogc2V0UGFzc3dvcmRPYmplY3QsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NDYixcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yQ2JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBucy5fbGlua1dpdGhQcm92aWRlciA9IGZ1bmN0aW9uIChpZGVudGl0eSwgdXNlcklkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHVzZXJJZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxpbmtXaXRoUHJvdmlkZXIsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGlkZW50aXR5LFxyXG4gICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICBza2lwQXV0aDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBucy5fdW5saW5rRnJvbVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyTmFtZSwgdXNlcklkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6IHByb3ZpZGVyTmFtZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IHVzZXJJZFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlclVubGlua0Zyb21Qcm92aWRlcixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogaWRlbnRpdHksXHJcbiAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcclxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG59OyIsInZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcbnZhciBfID0gY29tbW9uLl87XHJcbnZhciByc3ZwID0gY29tbW9uLnJzdnA7XHJcbnZhciBFdmVybGl2ZSA9IHJlcXVpcmUoJy4vRXZlcmxpdmUnKTtcclxudmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuXHJcbnZhciB1dGlscyA9IHt9O1xyXG5cclxudXRpbHMuZ3VhcmRVbnNldCA9IGZ1bmN0aW9uIGd1YXJkVW5zZXQodmFsdWUsIG5hbWUsIG1lc3NhZ2UpIHtcclxuICAgIGlmICghbWVzc2FnZSkge1xyXG4gICAgICAgIG1lc3NhZ2UgPSAnVGhlICcgKyBuYW1lICsgJyBpcyByZXF1aXJlZCc7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudXRpbHMucGFyc2VVdGlsaXRpZXMgPSB7XHJcbiAgICBnZXRSZXZpdmVyOiBmdW5jdGlvbiAocGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZVN0cmluZykge1xyXG4gICAgICAgIHZhciBkYXRlUGFyc2VyO1xyXG4gICAgICAgIGlmIChwYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGRhdGVQYXJzZXIgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5wYXJzZUlzb0RhdGVTdHJpbmc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGF0ZVBhcnNlciA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLnBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gZGF0ZVBhcnNlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlSXNvRGF0ZVN0cmluZzogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oXFxkezR9KSgtKFxcZHsyfSkoLShcXGR7Mn0pKFQoXFxkezJ9KTooXFxkezJ9KSg6KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoXFwrfC0pKFxcZHsyfSk6KFxcZHsyfSkpKSk/KSkkLykpIHtcclxuICAgICAgICAgICAgLy8gRGF0ZVRpbWVcclxuICAgICAgICAgICAgdmFyIHNlY29uZFBhcnRzID0gbWF0Y2hbMTJdO1xyXG4gICAgICAgICAgICBpZiAoc2Vjb25kUGFydHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWNvbmRQYXJ0cy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGFydHMgPSBNYXRoLnJvdW5kKE51bWJlcihzZWNvbmRQYXJ0cy5zdWJzdHIoMCwgMykgKyAnLicgKyBzZWNvbmRQYXJ0cy5zdWJzdHIoMykpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlY29uZFBhcnRzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2Vjb25kUGFydHMgYXJlIG9uZSBvciB0d28gY2hhcmFjdGVycyB0aGVuIHR3byBvciBvbmUgemVyb3Mgc2hvdWxkIGJlIGFwcGVuZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gaGF2ZSB0aGUgY29ycmVjdCBudW1iZXIgZm9yIG1pbGxpc2Vjb25kcyAoJy42NycgbWVhbnMgNjcwbXMgbm90IDY3bXMpXHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGFydHMgKz0gc2Vjb25kUGFydHMubGVuZ3RoID09PSAyID8gJzAnIDogJzAwJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKFxyXG4gICAgICAgICAgICAgICAgRGF0ZS5VVEMoXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzFdKSwgLy8geWVhclxyXG4gICAgICAgICAgICAgICAgICAgIChOdW1iZXIobWF0Y2hbM10pIC0gMSkgfHwgMCwgLy8gbW9udGhcclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobWF0Y2hbNV0pIHx8IDAsIC8vIGRheVxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtYXRjaFs3XSkgfHwgMCwgLy8gaG91clxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtYXRjaFs4XSkgfHwgMCwgLy8gbWludXRlXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzEwXSkgfHwgMCwgLy8gc2Vjb25kXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKHNlY29uZFBhcnRzKSB8fCAwXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBpZiAobWF0Y2hbMTNdICYmIG1hdGNoWzEzXSAhPT0gXCJaXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoID0gTnVtYmVyKG1hdGNoWzE2XSkgfHwgMCxcclxuICAgICAgICAgICAgICAgICAgICBtID0gTnVtYmVyKG1hdGNoWzE3XSkgfHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICBoICo9IDM2MDAwMDA7XHJcbiAgICAgICAgICAgICAgICBtICo9IDYwMDAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBoICsgbTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxNV0gPT09IFwiK1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUudmFsdWVPZigpICsgb2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLy50ZXN0KHN0cmluZykpIHtcclxuICAgICAgICAgICAgLy8gRGF0ZVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgvXihcXGR7Mn0pOihcXGR7Mn0pKDooXFxkezJ9KShcXC4oXFxkKykpPyk/KFp8KChcXCt8LSkoXFxkezJ9KTooXFxkezJ9KSkpPyQvLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgICAgICAvLyBUaW1lXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnBhcnNlVXRpbGl0aWVzLnBhcnNlSXNvRGF0ZVN0cmluZyhzdHJpbmcpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKG9iaiwgZnVuYykge1xyXG4gICAgICAgIHZhciBrZXksIHZhbHVlLCBuZXdWYWx1ZTtcclxuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBmdW5jKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmV3VmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLnBhcnNlVXRpbGl0aWVzLnRyYXZlcnNlKHZhbHVlLCBmdW5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmF2ZXJzZUFuZFJldml2ZTogZnVuY3Rpb24gKGRhdGEsIHJldml2ZXIpIHtcclxuICAgICAgICBpZiAoIXJldml2ZXIpIHtcclxuICAgICAgICAgICAgcmV2aXZlciA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy50cmF2ZXJzZShkYXRhLCByZXZpdmVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gKHJldml2ZXIsIGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgJiYgZXJyb3IubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7bWVzc2FnZTogZXJyb3IubWVzc2FnZSwgY29kZTogZXJyb3IuZXJyb3JDb2RlfTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX3BhcnNlSW50ZXJuYWw6IGZ1bmN0aW9uIChyZXZpdmVyLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSwgcmV2aXZlcik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdXRpbHMucGFyc2VVdGlsaXRpZXMudHJhdmVyc2VBbmRSZXZpdmUoZGF0YSwgcmV2aXZlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgX3RyYW5zZm9ybVJlc3VsdDogZnVuY3Rpb24gKGRhdGEsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtyZXN1bHQ6IGRhdGEuUmVzdWx0fTtcclxuICAgICAgICAgICAgXy5leHRlbmQocmVzdWx0LCBhZGRpdGlvbmFsUHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZVJlc3VsdDogZnVuY3Rpb24gKHJldml2ZXIsIGRhdGEpIHtcclxuICAgICAgICBkYXRhID0gdXRpbHMucGFyc2VVdGlsaXRpZXMuX3BhcnNlSW50ZXJuYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gdXRpbHMucGFyc2VVdGlsaXRpZXMuX3RyYW5zZm9ybVJlc3VsdChkYXRhLCB7Y291bnQ6IGRhdGEuQ291bnR9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VTaW5nbGVSZXN1bHQ6IGZ1bmN0aW9uIChyZXZpdmVyLCBkYXRhKSB7XHJcbiAgICAgICAgZGF0YSA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLl9wYXJzZUludGVybmFsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnBhcnNlVXRpbGl0aWVzLl90cmFuc2Zvcm1SZXN1bHQoZGF0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlVXBkYXRlUmVzdWx0OiBmdW5jdGlvbiAocmV2aXZlciwgZGF0YSkge1xyXG4gICAgICAgIGRhdGEgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5fcGFyc2VJbnRlcm5hbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy5fdHJhbnNmb3JtUmVzdWx0KGRhdGEsIHtNb2RpZmllZEF0OiBkYXRhLk1vZGlmaWVkQXR9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VKU09OOiBmdW5jdGlvbiAoanNvbikge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24sIHV0aWxzLnBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIoKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG51dGlscy5idWlsZFByb21pc2UgPSBmdW5jdGlvbiBidWlsZFByb21pc2Uob3BlcmF0aW9uLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgdmFyIGNhbGxiYWNrcyA9IHV0aWxzLmdldENhbGxiYWNrcyhzdWNjZXNzLCBlcnJvcik7XHJcbiAgICBvcGVyYXRpb24oY2FsbGJhY2tzLnN1Y2Nlc3MsIGNhbGxiYWNrcy5lcnJvcik7XHJcbiAgICByZXR1cm4gY2FsbGJhY2tzLnByb21pc2U7XHJcbn07XHJcblxyXG51dGlscy5nZXRDYWxsYmFja3MgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgIHZhciBwcm9taXNlO1xyXG4gICAgdmFyIGNyZWF0ZVByb21pc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAocGxhdGZvcm0uaXNOb2RlanMpIHtcclxuICAgICAgICAvLyBub2RlIGpzIHN0eWxlIGNvbnRpbnVhdGlvblxyXG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gc3VjY2VzcztcclxuICAgICAgICAgICAgc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLCByZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBlcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1Y2Nlc3MgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSBjcmVhdGVQcm9taXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3MgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSBjcmVhdGVQcm9taXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7cHJvbWlzZTogcHJvbWlzZSwgc3VjY2Vzczogc3VjY2VzcywgZXJyb3I6IGVycm9yfTtcclxufTtcclxuXHJcbnV0aWxzLmJ1aWxkQXV0aEhlYWRlciA9IGZ1bmN0aW9uIGJ1aWxkQXV0aEhlYWRlcihzZXR1cCwgb3B0aW9ucykge1xyXG4gICAgdmFyIGF1dGhIZWFkZXJWYWx1ZSA9IG51bGw7XHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmF1dGhIZWFkZXJzID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBhdXRoSGVhZGVyVmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAoc2V0dXAudG9rZW4pIHtcclxuICAgICAgICBhdXRoSGVhZGVyVmFsdWUgPSAoc2V0dXAudG9rZW5UeXBlIHx8ICdiZWFyZXInKSArICcgJyArIHNldHVwLnRva2VuO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2V0dXAubWFzdGVyS2V5KSB7XHJcbiAgICAgICAgYXV0aEhlYWRlclZhbHVlID0gJ21hc3RlcmtleSAnICsgc2V0dXAubWFzdGVyS2V5O1xyXG4gICAgfVxyXG4gICAgaWYgKGF1dGhIZWFkZXJWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7QXV0aG9yaXphdGlvbjogYXV0aEhlYWRlclZhbHVlfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG51dGlscy5EZXZpY2VSZWdpc3RyYXRpb25SZXN1bHQgPSBmdW5jdGlvbiBEZXZpY2VSZWdpc3RyYXRpb25SZXN1bHQodG9rZW4pIHtcclxuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxufTtcclxuXHJcbnV0aWxzLmNsb25lRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XHJcbn07XHJcblxyXG51dGlscy5idWlsZFVybCA9IGZ1bmN0aW9uIChzZXR1cCkge1xyXG4gICAgdmFyIHVybCA9ICcnO1xyXG4gICAgaWYgKHR5cGVvZiBzZXR1cC5zY2hlbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdXJsICs9IHNldHVwLnNjaGVtZSArICc6JztcclxuICAgIH1cclxuICAgIHVybCArPSBzZXR1cC51cmw7XHJcbiAgICBpZiAoc2V0dXAuYXBpS2V5KSB7XHJcbiAgICAgICAgdXJsICs9IHNldHVwLmFwaUtleSArICcvJztcclxuICAgIH1cclxuICAgIHJldHVybiB1cmw7XHJcbn07XHJcblxyXG51dGlscy5nZXREYk9wZXJhdG9ycyA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBzaGFsbG93KSB7XHJcbiAgICB2YXIgZGJPcGVyYXRvcnMgPSBbXTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGRiT3BlcmF0b3JzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtb2RpZmllcktleXMgPSBPYmplY3Qua2V5cyhleHByZXNzaW9uKTtcclxuICAgIF8uZWFjaChtb2RpZmllcktleXMsIGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJyQnKSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkYk9wZXJhdG9ycy5wdXNoKGtleSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwcmVzc2lvbltrZXldID09PSAnb2JqZWN0JyAmJiAhc2hhbGxvdykge1xyXG4gICAgICAgICAgICBkYk9wZXJhdG9ycyA9IGRiT3BlcmF0b3JzLmNvbmNhdCh1dGlscy5nZXREYk9wZXJhdG9ycyhleHByZXNzaW9uW2tleV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZGJPcGVyYXRvcnM7XHJcbn07XHJcblxyXG51dGlscy5kaXNhYmxlUmVxdWVzdENhY2hlID0gZnVuY3Rpb24gKHVybCwgbWV0aG9kKSB7XHJcbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xyXG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSB1cmwuaW5kZXhPZignPycpID4gLTEgPyAnJicgOiAnPyc7XHJcbiAgICAgICAgdXJsICs9IHNlcGFyYXRvciArICdfZWw9JyArIHRpbWVzdGFtcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJsO1xyXG59O1xyXG5cclxudmFyIHVuc3VwcG9ydGVkRGJPcGVyYXRvcnMgPSBbXHJcbiAgICAnJGdlb1dpdGhpbicsXHJcbiAgICAnJGdlb0ludGVyc2VjdHMnLFxyXG4gICAgJyRuZWFyJyxcclxuICAgICckd2l0aGluJyxcclxuICAgICckbmVhclNwaGVyZSdcclxuXTtcclxuXHJcbnV0aWxzLmdldFVuc3VwcG9ydGVkT3BlcmF0b3JzID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgdmFyIGRiT3BlcmF0b3JzID0gdXRpbHMuZ2V0RGJPcGVyYXRvcnMoZmlsdGVyKTtcclxuICAgIHJldHVybiBfLmludGVyc2VjdGlvbihkYk9wZXJhdG9ycywgdW5zdXBwb3J0ZWREYk9wZXJhdG9ycyk7XHJcbn07XHJcblxyXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc5MDU5MjkvaG93LXRvLXRlc3QtdmFsaWQtdXVpZC1ndWlkXHJcbnV0aWxzLmlzR3VpZCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIHJldHVybiAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9JC9pLnRlc3Qoc3RyKTtcclxufTtcclxuXHJcbnV0aWxzLmlzUXVlcnlTdXBwb3J0ZWRPZmZsaW5lID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICB2YXIgcXVlcnlQYXJhbXMgPSBxdWVyeS5nZXRRdWVyeVBhcmFtZXRlcnMoKTtcclxuICAgIHZhciBoYXNFeHBhbmRFeHByZXNzaW9uID0gIV8uaXNFbXB0eU9iamVjdChxdWVyeVBhcmFtcy5leHBhbmQpO1xyXG4gICAgdmFyIHVuc3VwcG9ydGVkT3BlcmF0b3JzID0gdXRpbHMuZ2V0VW5zdXBwb3J0ZWRPcGVyYXRvcnMocXVlcnlQYXJhbXMuZmlsdGVyKTtcclxuICAgIHZhciBoYXNVbnN1cHBvcnRlZE9wZXJhdG9ycyA9IHVuc3VwcG9ydGVkT3BlcmF0b3JzLmxlbmd0aCAhPT0gMDtcclxuICAgIHZhciBpc1Vuc3VwcG9ydGVkSW5PZmZsaW5lID0gaGFzRXhwYW5kRXhwcmVzc2lvbiB8fCBoYXNVbnN1cHBvcnRlZE9wZXJhdG9ycztcclxuICAgIHJldHVybiAhaXNVbnN1cHBvcnRlZEluT2ZmbGluZTtcclxufTtcclxuXHJcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTYyNDU3NjcvY3JlYXRpbmctYS1ibG9iLWZyb20tYS1iYXNlNjQtc3RyaW5nLWluLWphdmFzY3JpcHQvMTYyNDU3NjgjMTYyNDU3NjhcclxudXRpbHMuYjY0dG9CbG9iID0gZnVuY3Rpb24gKGI2NERhdGEsIGNvbnRlbnRUeXBlLCBzbGljZVNpemUpIHtcclxuICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgfHwgJyc7XHJcbiAgICBzbGljZVNpemUgPSBzbGljZVNpemUgfHwgNTEyO1xyXG5cclxuICAgIHZhciBieXRlQ2hhcmFjdGVycyA9IGF0b2IoYjY0RGF0YSk7XHJcbiAgICB2YXIgYnl0ZUFycmF5cyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aDsgb2Zmc2V0ICs9IHNsaWNlU2l6ZSkge1xyXG4gICAgICAgIHZhciBzbGljZSA9IGJ5dGVDaGFyYWN0ZXJzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2xpY2VTaXplKTtcclxuXHJcbiAgICAgICAgdmFyIGJ5dGVOdW1iZXJzID0gbmV3IEFycmF5KHNsaWNlLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBieXRlTnVtYmVyc1tpXSA9IHNsaWNlLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZU51bWJlcnMpO1xyXG5cclxuICAgICAgICBieXRlQXJyYXlzLnB1c2goYnl0ZUFycmF5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKGJ5dGVBcnJheXMsIHt0eXBlOiBjb250ZW50VHlwZX0pO1xyXG4gICAgcmV0dXJuIGJsb2I7XHJcbn07XHJcblxyXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzkyNjc4OTkvYXJyYXlidWZmZXItdG8tYmFzZTY0LWVuY29kZWQtc3RyaW5nXHJcbnV0aWxzLmFycmF5QnVmZmVyVG9CYXNlNjQgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XHJcbiAgICB2YXIgYmluYXJ5ID0gJyc7XHJcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBidG9hKGJpbmFyeSk7XHJcbn07XHJcblxyXG51dGlscy5zdWNjZXNzZnVsUHJvbWlzZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgIHJlc29sdmUoZGF0YSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnV0aWxzLnJlamVjdGVkUHJvbWlzZSA9IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxudXRpbHMudHJhbnNmb3JtUGxhdGZvcm1QYXRoID0gZnVuY3Rpb24gdHJhbnNmb3JtUGxhdGZvcm1QYXRoKHBsYXRmb3JtUGF0aCkge1xyXG4gICAgaWYgKCFwbGF0Zm9ybVBhdGgpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBsYXRmb3JtLmlzV2luZG93c1Bob25lKSB7XHJcbiAgICAgICAgaWYgKHBsYXRmb3JtUGF0aC5jaGFyQXQoMCkgPT09ICcvJyAmJiBwbGF0Zm9ybVBhdGguY2hhckF0KDEpICE9PSAnLycpIHtcclxuICAgICAgICAgICAgcGxhdGZvcm1QYXRoID0gJy8nICsgcGxhdGZvcm1QYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7IC8vVE9ETzogcHJvYmFibHkgZGVza3RvcCB0b29cclxuICAgICAgICBpZiAocGxhdGZvcm1QYXRoLmluZGV4T2YoJ2ZpbGU6LycpICE9PSAtMSAmJiBwbGF0Zm9ybVBhdGguaW5kZXhPZignZmlsZTovLy8nKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcGxhdGZvcm1QYXRoID0gcGxhdGZvcm1QYXRoLnJlcGxhY2UoJ2ZpbGU6LycsICdmaWxlOi8vLycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGxhdGZvcm1QYXRoO1xyXG59O1xyXG5cclxudXRpbHMuX3N0cmluZ0NvbXBhcmUgPSBmdW5jdGlvbiAoc3RyaW5nLCBjaGVjaykge1xyXG4gICAgcmV0dXJuIHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBjaGVjaztcclxufTtcclxuXHJcbnV0aWxzLmlzQ29udGVudFR5cGUgPSB7XHJcbiAgICBmaWxlczogZnVuY3Rpb24gKGNvbGxlY3Rpb25OYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLl9zdHJpbmdDb21wYXJlKGNvbGxlY3Rpb25OYW1lLCAnZmlsZXMnKTtcclxuICAgIH0sXHJcbiAgICB1c2VyczogZnVuY3Rpb24gKGNvbGxlY3Rpb25OYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLl9zdHJpbmdDb21wYXJlKGNvbGxlY3Rpb25OYW1lLCAndXNlcnMnKTtcclxuICAgIH1cclxufTtcclxuXHJcbnV0aWxzLmlzRWxlbWVudCA9IHtcclxuICAgIF9pc0VsZW1lbnQ6IGZ1bmN0aW9uIChlbCwgY2hlY2spIHtcclxuICAgICAgICB2YXIgdGFnID0gZWw7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdGFnID0gZWwudGFnTmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLl9zdHJpbmdDb21wYXJlKHRhZywgY2hlY2spO1xyXG4gICAgfSxcclxuICAgIGltYWdlOiBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICByZXR1cm4gdXRpbHMuaXNFbGVtZW50Ll9pc0VsZW1lbnQoZWwsICdpbWcnKTtcclxuICAgIH0sXHJcbiAgICBhbmNob3I6IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHJldHVybiB1dGlscy5pc0VsZW1lbnQuX2lzRWxlbWVudChlbCwgJ2EnKTtcclxuICAgIH1cclxufTtcclxuXHJcbnV0aWxzLmpvaW5QYXRoID0gZnVuY3Rpb24gam9pblBhdGgoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykubWFwKGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICByZXR1cm4gYXJnIHx8ICcnO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGpvaW5lZFBhdGggPSBwYXRoLmpvaW4uYXBwbHkocGF0aCwgYXJncyk7XHJcbiAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtUGxhdGZvcm1QYXRoKGpvaW5lZFBhdGgpO1xyXG59O1xyXG5cclxudXRpbHMudXVpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvY3JlYXRlLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0XHJcbiAgICB2YXIgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgdmFyIHV1aWQgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgdmFyIHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XHJcbiAgICAgICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcclxuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KSkudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHV1aWQ7XHJcbn07XHJcblxyXG51dGlscy5nZXRJZCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHJldHVybiBvYmouSWQgfHwgb2JqLl9pZCB8fCBvYmouaWQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxzO1xyXG4iXX0=
}())